<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>
<tagfile>
  <compound kind="page">
    <name>index</name>
    <title>qmcPlusPlus main page</title>
    <filename>index</filename>
    <docanchor file="index">Major</docanchor>
    <docanchor file="index">intro_sec</docanchor>
    <docanchor file="/home/jnkim/qmcPlusPlus/v0.2/docs/ohmms-config.h">license</docanchor>
  </compound>
  <compound kind="file">
    <name>Any2GridBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>Any2GridBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>Any2GridBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>Any2GridBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>Any2Slater.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>Any2Slater_8h</filename>
  </compound>
  <compound kind="file">
    <name>Assign.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>Assign_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>AsymmetricDistanceTableData.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>AsymmetricDistanceTableData_8h</filename>
    <namespace>ohmmsqmc</namespace>
    <member kind="define">
      <type>#define</type>
      <name>OHMMS_QMC_ASYMMETROCDISTANCETABLEDATAIMPL_H</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>AttributeSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>AttributeSet_8h</filename>
  </compound>
  <compound kind="file">
    <name>BareKineticEnergy.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>BareKineticEnergy_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>Blasf.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>Blasf_8h</filename>
    <member kind="function">
      <type>double</type>
      <name>ddot</name>
      <anchor>a0</anchor>
      <arglist>(const int &amp;n, const double *dx, const int &amp;incx, const double *dy, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>float</type>
      <name>sdot</name>
      <anchor>a1</anchor>
      <arglist>(const int &amp;n, const float *dx, const int &amp;incx, const float *dy, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>daxpy</name>
      <anchor>a2</anchor>
      <arglist>(const int &amp;n, const double &amp;da, const double *dx, const int &amp;incx, double *dy, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>saxpy</name>
      <anchor>a3</anchor>
      <arglist>(const int &amp;n, const float &amp;da, const float *dx, const int &amp;incx, float *dy, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>zaxpy</name>
      <anchor>a4</anchor>
      <arglist>(const int &amp;n, const complex&lt; double &gt; &amp;da, const complex&lt; double &gt; *dx, const int &amp;incx, complex&lt; double &gt; *dy, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dnrm2</name>
      <anchor>a5</anchor>
      <arglist>(const int &amp;n, const double *dx, const int &amp;incx)</arglist>
    </member>
    <member kind="function">
      <type>float</type>
      <name>snrm2</name>
      <anchor>a6</anchor>
      <arglist>(const int &amp;n, const float *dx, const int &amp;incx)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dznrm2</name>
      <anchor>a7</anchor>
      <arglist>(const int &amp;n, const complex&lt; double &gt; *dx, const int &amp;incx)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dscal</name>
      <anchor>a8</anchor>
      <arglist>(const int &amp;n, const double &amp;, double *x, const int &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dsymv</name>
      <anchor>a9</anchor>
      <arglist>(const char &amp;uplo, const int &amp;n, const double &amp;alpha, const double &amp;a, const int &amp;lda, const double *x, const int &amp;incx, const double &amp;beta, double *y, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ssymv</name>
      <anchor>a10</anchor>
      <arglist>(const char &amp;uplo, const int &amp;n, const float &amp;alpha, const float &amp;a, const int &amp;lda, const float *x, const int &amp;incx, const float &amp;beta, float *y, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>zsymv</name>
      <anchor>a11</anchor>
      <arglist>(const char &amp;uplo, const int &amp;n, const complex&lt; double &gt; &amp;alpha, complex&lt; double &gt; *a, const int &amp;lda, complex&lt; double &gt; *x, const int &amp;incx, const complex&lt; double &gt; &amp;beta, complex&lt; double &gt; *y, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>csymv</name>
      <anchor>a12</anchor>
      <arglist>(const char &amp;uplo, const int &amp;n, const complex&lt; float &gt; &amp;alpha, complex&lt; float &gt; *a, const int &amp;lda, complex&lt; float &gt; *x, const int &amp;incx, const complex&lt; float &gt; &amp;beta, complex&lt; float &gt; *y, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>zcopy</name>
      <anchor>a13</anchor>
      <arglist>(const int &amp;n, const complex&lt; double &gt; *x, const int &amp;incx, complex&lt; double &gt; *y, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dcopy</name>
      <anchor>a14</anchor>
      <arglist>(const int &amp;n, const double *, const int &amp;, double *, const int &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dsyr2k</name>
      <anchor>a15</anchor>
      <arglist>(const char &amp;, const char &amp;, const int &amp;, const int &amp;, const double &amp;, const double *, const int &amp;, const double *, const int &amp;, const double &amp;, double *, const int &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dsymm</name>
      <anchor>a16</anchor>
      <arglist>(const char &amp;, const char &amp;, const int &amp;, const int &amp;, const double &amp;, const double *A, const int &amp;lda, const double *B, const int &amp;ldb, const double &amp;beta, double *C, const int &amp;ldc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dgemm</name>
      <anchor>a17</anchor>
      <arglist>(const char &amp;, const char &amp;, const int &amp;, const int &amp;, const int &amp;, const double &amp;, const double *, const int &amp;, const double *, const int &amp;, const double &amp;, double *, const int &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dgemv</name>
      <anchor>a18</anchor>
      <arglist>(const char &amp;trans, const int &amp;nr, const int &amp;nc, const double &amp;alpha, const double *amat, const int &amp;lda, const double *bv, const int &amp;incx, const double &amp;beta, double *cv, const int &amp;incy)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dsyrk</name>
      <anchor>a19</anchor>
      <arglist>(const char &amp;, const char &amp;, const int &amp;, const int &amp;, const double &amp;, const double *, const int &amp;, const double &amp;, double *, const int &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dgetrf</name>
      <anchor>a20</anchor>
      <arglist>(const int &amp;n, const int &amp;m, double *a, const int &amp;n0, int *piv, int &amp;st)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>zgetrf</name>
      <anchor>a21</anchor>
      <arglist>(const int &amp;n, const int &amp;m, complex&lt; double &gt; *a, const int &amp;n0, int *piv, int &amp;st)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dgetri</name>
      <anchor>a22</anchor>
      <arglist>(const int &amp;n, double *a, const int &amp;n0, int *piv, double *work, const int &amp;, int &amp;st)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>zgetri</name>
      <anchor>a23</anchor>
      <arglist>(const int &amp;n, complex&lt; double &gt; *a, const int &amp;n0, int *piv, complex&lt; double &gt; *work, const int &amp;, int &amp;st)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>BoostRandom.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>BoostRandom_8h</filename>
  </compound>
  <compound kind="file">
    <name>CasinoParser.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>CasinoParser_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>CasinoParser.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>CasinoParser_8h</filename>
  </compound>
  <compound kind="file">
    <name>ChebyshevJastrow.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>ChebyshevJastrow_8h</filename>
  </compound>
  <compound kind="file">
    <name>Clebsch_Gordan.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>Clebsch__Gordan_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>Clebsch_Gordan.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>Clebsch__Gordan_8h</filename>
  </compound>
  <compound kind="file">
    <name>Clock.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>Clock_8h</filename>
    <namespace>Pooma</namespace>
  </compound>
  <compound kind="file">
    <name>ConservedEnergy.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>ConservedEnergy_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>ConstScale.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>ConstScale_8h</filename>
  </compound>
  <compound kind="file">
    <name>CosineFunction.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>CosineFunction_8h</filename>
  </compound>
  <compound kind="file">
    <name>CoulombPotential.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>CoulombPotential_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>CubicSplineFunctions.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>CubicSplineFunctions_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>CubicSplineFunctions.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>CubicSplineFunctions_8h</filename>
  </compound>
  <compound kind="file">
    <name>DataParserTemplate.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>DataParserTemplate_8h</filename>
  </compound>
  <compound kind="file">
    <name>DeterminantOperators.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>DeterminantOperators_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>LUFactorization</name>
      <anchor>a0</anchor>
      <arglist>(const int &amp;n, const int &amp;m, double *a, const int &amp;n0, int *piv)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>LUFactorization</name>
      <anchor>a1</anchor>
      <arglist>(const int &amp;n, const int &amp;m, complex&lt; double &gt; *a, const int &amp;n0, int *piv)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>InvertLU</name>
      <anchor>a2</anchor>
      <arglist>(const int &amp;n, double *a, const int &amp;n0, int *piv, double *work, const int &amp;n1)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>Invert</name>
      <anchor>a3</anchor>
      <arglist>(double *x, int n, int m)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>invert_matrix</name>
      <anchor>a4</anchor>
      <arglist>(MatrixA &amp;M, bool getdet=true)</arglist>
    </member>
    <member kind="function">
      <type>MatA::value_type</type>
      <name>DetRatio</name>
      <anchor>a5</anchor>
      <arglist>(const MatA &amp;Minv, Iter newrow, int rowchanged)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>DetUpdate</name>
      <anchor>a6</anchor>
      <arglist>(MatA &amp;Minv, VecT &amp;newrow, VecT &amp;rvec, VecT &amp;rvecinv, int rowchanged, typename MatA::value_type c_ratio)</arglist>
    </member>
    <member kind="function">
      <type>TinyVector&lt; T, D &gt;</type>
      <name>dot</name>
      <anchor>a7</anchor>
      <arglist>(const T *a, const TinyVector&lt; T, D &gt; *b, int n)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>dot</name>
      <anchor>a8</anchor>
      <arglist>(const T *restrict a, const T *restrict b, int n)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>DetSetBuilderWithBasisSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>DetSetBuilderWithBasisSet_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>DiracDeterminant.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>DiracDeterminant_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>DistanceTable.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>DistanceTable_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>DistanceTable.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>DistanceTable_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>DistanceTableData.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>DistanceTableData_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>DMCParticleByParticle.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>DMCParticleByParticle_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>DMCParticleByParticle.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>DMCParticleByParticle_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>DOMProcessor.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>DOMProcessor_8h</filename>
  </compound>
  <compound kind="file">
    <name>DummyQMC.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>DummyQMC_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>DummyQMC.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>DummyQMC_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>EffMKineticEnergy.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>EffMKineticEnergy_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>EwaldSum.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>EwaldSum_8h</filename>
  </compound>
  <compound kind="file">
    <name>extfunct.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>extfunct_8h</filename>
    <member kind="function">
      <type>herr_t</type>
      <name>file_info</name>
      <anchor>a0</anchor>
      <arglist>(hid_t loc_id, const char *name, void *opdata)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>FastParticleOperators.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>FastParticleOperators_8h</filename>
    <member kind="define">
      <type>#define</type>
      <name>SUPERCELL_BOUNDARY_LIMITS</name>
      <anchor>a0</anchor>
      <arglist>(T)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>THREE_DIM_BOUNDARY_BLOCK</name>
      <anchor>a1</anchor>
      <arglist>(X, Y, Z, EPS, PLUSONE)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>FileUtility.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>FileUtility_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>Tokenize</name>
      <anchor>a0</anchor>
      <arglist>(const std::string &amp;str, std::vector&lt; std::string &gt; &amp;tokens, const std::string &amp;delimiters=&quot; &quot;)</arglist>
    </member>
    <member kind="function">
      <type>std::string</type>
      <name>getExtension</name>
      <anchor>a1</anchor>
      <arglist>(const std::string &amp;str)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>GamesXmlParser.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>GamesXmlParser_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>GamesXmlParser.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>GamesXmlParser_8h</filename>
  </compound>
  <compound kind="file">
    <name>GaussianBasisSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>GaussianBasisSet_8h</filename>
  </compound>
  <compound kind="file">
    <name>GaussianFCHKParser.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>GaussianFCHKParser_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>GaussianFCHKParser.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>GaussianFCHKParser_8h</filename>
  </compound>
  <compound kind="file">
    <name>GaussianTypeOrbital.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>GaussianTypeOrbital_8h</filename>
  </compound>
  <compound kind="file">
    <name>GridMolecularOrbitals.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>GridMolecularOrbitals_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>GridMolecularOrbitals.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>GridMolecularOrbitals_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>gto2grid.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>gto2grid_8cpp</filename>
    <member kind="function">
      <type>void</type>
      <name>buildBasisSet</name>
      <anchor>a0</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a1</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>GTO2GridBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>GTO2GridBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>GTO2GridBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>GTO2GridBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>gto2slater.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>gto2slater_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>GTOMolecularOrbitals.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>GTOMolecularOrbitals_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>GTOMolecularOrbitals.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>GTOMolecularOrbitals_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>HamiltonianPool.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>HamiltonianPool_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>HamiltonianPool.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>HamiltonianPool_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>HarmonicPotential.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>HarmonicPotential_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>HDFAttribIO.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>HDFAttribIO_8h</filename>
    <member kind="typedef">
      <type>int</type>
      <name>hid_t</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>HDFNumericAttrib.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>HDFNumericAttrib_8h</filename>
  </compound>
  <compound kind="file">
    <name>HDFParticleAttrib.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>HDFParticleAttrib_8h</filename>
  </compound>
  <compound kind="file">
    <name>HDFSTLAttrib.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>HDFSTLAttrib_8h</filename>
  </compound>
  <compound kind="file">
    <name>HDFTriCubicSpline.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>HDFTriCubicSpline_8h</filename>
  </compound>
  <compound kind="file">
    <name>HDFWalkerIO.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>HDFWalkerIO_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>HDFWalkerIO.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>HDFWalkerIO_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>HeSTOClementiRottie.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/AtomicOrbitals/</path>
    <filename>HeSTOClementiRottie_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>HeSTOClementiRottie.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/AtomicOrbitals/</path>
    <filename>HeSTOClementiRottie_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>HFAtomicSTOSet.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/AtomicOrbitals/</path>
    <filename>HFAtomicSTOSet_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>HFAtomicSTOSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/AtomicOrbitals/</path>
    <filename>HFAtomicSTOSet_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>HFAtomicSTOSetBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/AtomicOrbitals/</path>
    <filename>HFAtomicSTOSetBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a12</anchor>
      <arglist>(std::ostream &amp;out, const ComboSTO&lt; T, POS &gt; &amp;asto)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>HFAtomicSTOSetBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/AtomicOrbitals/</path>
    <filename>HFAtomicSTOSetBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>InitMolecularSystem.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>InitMolecularSystem_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>InitMolecularSystem.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>InitMolecularSystem_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>IonIonPotential.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>IonIonPotential_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>IteratorUtility.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>IteratorUtility_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>delete_iter</name>
      <anchor>a0</anchor>
      <arglist>(IT first, IT last)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>JastrowBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>JastrowBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>JastrowBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>JastrowBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>LCOrbitals.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>LCOrbitals_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>libxmldefs.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>libxmldefs_8h</filename>
    <member kind="function">
      <type>bool</type>
      <name>putContent</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;a, xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>putContent</name>
      <anchor>a1</anchor>
      <arglist>(IT first, IT last, xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>getContent</name>
      <anchor>a2</anchor>
      <arglist>(const T &amp;a, xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>putContent</name>
      <anchor>a3</anchor>
      <arglist>(std::vector&lt; T &gt; &amp;a, xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>getContent</name>
      <anchor>a4</anchor>
      <arglist>(const std::vector&lt; T &gt; &amp;a, xmlNodePtr cur)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LibxmlNumericIO.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>LibxmlNumericIO_8h</filename>
    <member kind="function">
      <type>bool</type>
      <name>putContent</name>
      <anchor>a0</anchor>
      <arglist>(Vector&lt; T &gt; &amp;a, xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>putContent</name>
      <anchor>a1</anchor>
      <arglist>(Matrix&lt; T &gt; &amp;a, xmlNodePtr cur)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>LocalCorePolPotential.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>LocalCorePolPotential_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>LocalCorePolPotential.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>LocalCorePolPotential_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>LocalEnergyEstimator.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Estimators/</path>
    <filename>LocalEnergyEstimator_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>LocalPPotential.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>LocalPPotential_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>LocalPPotential.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>LocalPPotential_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MatGrid1D.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>MatGrid1D_8h</filename>
  </compound>
  <compound kind="file">
    <name>MCWalkerConfiguration.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>MCWalkerConfiguration_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>MCWalkerConfiguration.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>MCWalkerConfiguration_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MixedSPOSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>MixedSPOSet_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MO2Grid3D.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>MO2Grid3D_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MO2Grid3D.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>MO2Grid3D_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>mo2grid3d_main.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>mo2grid3d__main_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MolecuDMC.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>MolecuDMC_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MolecuDMC.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>MolecuDMC_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MolecuFixedNodeBranch.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>MolecuFixedNodeBranch_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MolecularOrbitalBasis.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>MolecularOrbitalBasis_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MolecularOrbitalBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>MolecularOrbitalBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MolecularOrbitalBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>MolecularOrbitalBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MultiChain.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>MultiChain_8h</filename>
    <namespace>ohmmsqmc</namespace>
    <member kind="function">
      <type>void</type>
      <name>delete_iter</name>
      <anchor>a14</anchor>
      <arglist>(IT first, IT last)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>MultipleEnergyEstimator.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Estimators/</path>
    <filename>MultipleEnergyEstimator_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MultipleEnergyEstimator.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Estimators/</path>
    <filename>MultipleEnergyEstimator_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>MultiSlaterDeterminant.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>MultiSlaterDeterminant_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>NDimGridBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>NDimGridBase_8h</filename>
  </compound>
  <compound kind="file">
    <name>NoCuspJastrow.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>NoCuspJastrow_8h</filename>
  </compound>
  <compound kind="file">
    <name>NonLocalPPotential.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>NonLocalPPotential_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>NonLocalPPotential.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>NonLocalPPotential_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>NRSplineFunctions.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>NRSplineFunctions_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>NRCubicSpline</name>
      <anchor>a0</anchor>
      <arglist>(const T *x, const T *y, int n, T yp1, T ypn, T *y2)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>NRCubicSplinePBC</name>
      <anchor>a1</anchor>
      <arglist>(const T *x, const T *y, int n, T *d1, T *d2)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>NRCubicSplineFirst</name>
      <anchor>a2</anchor>
      <arglist>(const T *x, const T *y, int n, T *d1, T *d2)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>NumericalMolecularOrbitals.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>NumericalMolecularOrbitals_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>NumericalMolecularOrbitals.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>NumericalMolecularOrbitals_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>NumericalOrbitalSetBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>NumericalOrbitalSetBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>NumericalOrbitalSetBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>NumericalOrbitalSetBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>NumericalRGFBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>NumericalRGFBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>NumericalRGFBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>NumericalRGFBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>ohmms-config.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/docs/</path>
    <filename>ohmms-config_8h</filename>
    <member kind="define">
      <type>#define</type>
      <name>HAVE_LIBHDF5</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>HAVE_LIBBOOST</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>HAVE_LIBBLITZ</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>HAVE_LIBXML2</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>HAVE_LIBGSL</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>OHMMS_DIM</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>OHMMS_INDEXTYPE</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>OHMMS_PRECISION</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>OHMMS_ORTHO</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>QMC_FASTWALKER</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OhmmsBlas.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>OhmmsBlas_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>OhmmsBlas.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>OhmmsBlas_8h</filename>
  </compound>
  <compound kind="file">
    <name>OhmmsElementBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>OhmmsElementBase_8h</filename>
    <member kind="define">
      <type>#define</type>
      <name>xmlDocPtr</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>xmlNodePtr</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>xmlNsPtr</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OhmmsInfo.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>OhmmsInfo_8cpp</filename>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>log</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>error</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>warning</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>debug</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OhmmsInfo.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>OhmmsInfo_8h</filename>
    <member kind="define">
      <type>#define</type>
      <name>LOGMSG</name>
      <anchor>a0</anchor>
      <arglist>(msg)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ERRORMSG</name>
      <anchor>a1</anchor>
      <arglist>(msg)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>WARNMSG</name>
      <anchor>a2</anchor>
      <arglist>(msg)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>XMLReport</name>
      <anchor>a3</anchor>
      <arglist>(msg)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>DEBUGMSG</name>
      <anchor>a4</anchor>
      <arglist>(msg)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>log</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>error</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>warning</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>debug</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OhmmsInform.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>OhmmsInform_8cpp</filename>
    <namespace>std</namespace>
  </compound>
  <compound kind="file">
    <name>OhmmsInform.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>OhmmsInform_8h</filename>
    <member kind="function">
      <type>OhmmsInform &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a0</anchor>
      <arglist>(OhmmsInform &amp;o, const T &amp;val)</arglist>
    </member>
    <member kind="function">
      <type>OhmmsInform &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a1</anchor>
      <arglist>(OhmmsInform &amp;o, const std::string &amp;s)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OhmmsIOBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>OhmmsIOBase_8h</filename>
  </compound>
  <compound kind="file">
    <name>OhmmsMatrix.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</path>
    <filename>OhmmsMatrix_8h</filename>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a0</anchor>
      <arglist>(ostream &amp;out, const Matrix&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>std::istream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a1</anchor>
      <arglist>(std::istream &amp;is, Matrix&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(Matrix&lt; T, C &gt; &amp;lhs, const Op &amp;op, const Expression&lt; RHS &gt; &amp;rhs)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OhmmsMatrixOperators.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</path>
    <filename>OhmmsMatrixOperators_8h</filename>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryMinus, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a0</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryPlus, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a1</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpBitwiseNot, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator~</name>
      <anchor>a2</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpIdentity, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>PETE_identity</name>
      <anchor>a3</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpCast&lt; T1 &gt;, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>peteCast</name>
      <anchor>a4</anchor>
      <arglist>(const T1 &amp;, const Matrix&lt; T2, C2 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a5</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a6</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a7</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a8</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a9</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a10</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a11</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a12</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a13</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a14</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a15</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a16</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a17</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a18</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a19</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a20</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a21</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a22</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a23</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a24</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a25</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a26</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a27</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a28</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a29</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a30</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a31</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a32</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a33</anchor>
      <arglist>(const T1 &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a34</anchor>
      <arglist>(const T1 &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a35</anchor>
      <arglist>(const T1 &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a36</anchor>
      <arglist>(const T1 &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a37</anchor>
      <arglist>(const T1 &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a38</anchor>
      <arglist>(const T1 &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Matrix&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a39</anchor>
      <arglist>(const T1 &amp;l, const Matrix&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; TrinaryNode&lt; FnWhere, typename CreateLeaf&lt; Matrix&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t, typename CreateLeaf&lt; T3 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>where</name>
      <anchor>a40</anchor>
      <arglist>(const Matrix&lt; T1, C1 &gt; &amp;c, const T2 &amp;t, const T3 &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryMinus, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a41</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryPlus, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a42</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpBitwiseNot, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator~</name>
      <anchor>a43</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpIdentity, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>PETE_identity</name>
      <anchor>a44</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpCast&lt; T1 &gt;, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>peteCast</name>
      <anchor>a45</anchor>
      <arglist>(const T1 &amp;, const Expression&lt; T2 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a46</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a47</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a48</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a49</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a50</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a51</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a52</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a53</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a54</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a55</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a56</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a57</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a58</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a59</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a60</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a61</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a62</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a63</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a64</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a65</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a66</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; TrinaryNode&lt; FnWhere, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t, typename CreateLeaf&lt; T3 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>where</name>
      <anchor>a67</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;c, const T2 &amp;t, const T3 &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>Matrix&lt; T1, C1 &gt; &amp;</type>
      <name>assign</name>
      <anchor>a68</anchor>
      <arglist>(Matrix&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Matrix&lt; T1, C1 &gt; &amp;</type>
      <name>operator+=</name>
      <anchor>a69</anchor>
      <arglist>(Matrix&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Matrix&lt; T1, C1 &gt; &amp;</type>
      <name>operator-=</name>
      <anchor>a70</anchor>
      <arglist>(Matrix&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Matrix&lt; T1, C1 &gt; &amp;</type>
      <name>operator *=</name>
      <anchor>a71</anchor>
      <arglist>(Matrix&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Matrix&lt; T1, C1 &gt; &amp;</type>
      <name>operator%=</name>
      <anchor>a72</anchor>
      <arglist>(Matrix&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Matrix&lt; T1, C1 &gt; &amp;</type>
      <name>operator|=</name>
      <anchor>a73</anchor>
      <arglist>(Matrix&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Matrix&lt; T1, C1 &gt; &amp;</type>
      <name>operator &amp;=</name>
      <anchor>a74</anchor>
      <arglist>(Matrix&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Matrix&lt; T1, C1 &gt; &amp;</type>
      <name>operator^=</name>
      <anchor>a75</anchor>
      <arglist>(Matrix&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OhmmsObject.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>OhmmsObject_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>OhmmsObject.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>OhmmsObject_8h</filename>
  </compound>
  <compound kind="file">
    <name>OhmmsParameter.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>OhmmsParameter_8h</filename>
  </compound>
  <compound kind="file">
    <name>OhmmsSpecies.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>OhmmsSpecies_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>OhmmsSpecies.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>OhmmsSpecies_8h</filename>
  </compound>
  <compound kind="file">
    <name>OhmmsSymmetricMatrix.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</path>
    <filename>OhmmsSymmetricMatrix_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a0</anchor>
      <arglist>(SymmetricMatrix&lt; T, C &gt; &amp;lhs, const Op &amp;op, const Expression&lt; RHS &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a1</anchor>
      <arglist>(ostream &amp;out, const SymmetricMatrix&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OhmmsVector.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</path>
    <filename>OhmmsVector_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a0</anchor>
      <arglist>(Vector&lt; T, C &gt; &amp;lhs, const Op &amp;op, const Expression&lt; RHS &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a1</anchor>
      <arglist>(ostream &amp;out, const Vector&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OhmmsVectorOperators.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</path>
    <filename>OhmmsVectorOperators_8h</filename>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnArcCos, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>acos</name>
      <anchor>a0</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnArcSin, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>asin</name>
      <anchor>a1</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnArcTan, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>atan</name>
      <anchor>a2</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnCeil, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>ceil</name>
      <anchor>a3</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnCos, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>cos</name>
      <anchor>a4</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnHypCos, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>cosh</name>
      <anchor>a5</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnExp, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>exp</name>
      <anchor>a6</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnFabs, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>fabs</name>
      <anchor>a7</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnFloor, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>floor</name>
      <anchor>a8</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnLog, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>log</name>
      <anchor>a9</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnLog10, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>log10</name>
      <anchor>a10</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnSin, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>sin</name>
      <anchor>a11</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnHypSin, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>sinh</name>
      <anchor>a12</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnSqrt, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>sqrt</name>
      <anchor>a13</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnTan, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>tan</name>
      <anchor>a14</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnHypTan, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>tanh</name>
      <anchor>a15</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryMinus, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a16</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryPlus, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a17</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpBitwiseNot, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator~</name>
      <anchor>a18</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpIdentity, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>PETE_identity</name>
      <anchor>a19</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpNot, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator!</name>
      <anchor>a20</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpCast&lt; T1 &gt;, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>peteCast</name>
      <anchor>a21</anchor>
      <arglist>(const T1 &amp;, const Vector&lt; T2, C2 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a22</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a23</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a24</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpDivide, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator/</name>
      <anchor>a25</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a26</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a27</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a28</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a29</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnLdexp, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>ldexp</name>
      <anchor>a30</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnPow, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>pow</name>
      <anchor>a31</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnFmod, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>fmod</name>
      <anchor>a32</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnArcTan2, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>atan2</name>
      <anchor>a33</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLT, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;</name>
      <anchor>a34</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLE, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;=</name>
      <anchor>a35</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGT, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;</name>
      <anchor>a36</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGE, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;=</name>
      <anchor>a37</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpEQ, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator==</name>
      <anchor>a38</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpNE, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator!=</name>
      <anchor>a39</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAnd, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;&amp;</name>
      <anchor>a40</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpOr, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator||</name>
      <anchor>a41</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLeftShift, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;&lt;</name>
      <anchor>a42</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpRightShift, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;&gt;</name>
      <anchor>a43</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a44</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a45</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a46</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpDivide, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator/</name>
      <anchor>a47</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a48</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a49</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a50</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a51</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnLdexp, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>ldexp</name>
      <anchor>a52</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnPow, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>pow</name>
      <anchor>a53</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnFmod, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>fmod</name>
      <anchor>a54</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnArcTan2, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>atan2</name>
      <anchor>a55</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLT, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;</name>
      <anchor>a56</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLE, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;=</name>
      <anchor>a57</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGT, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;</name>
      <anchor>a58</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGE, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;=</name>
      <anchor>a59</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpEQ, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator==</name>
      <anchor>a60</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpNE, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator!=</name>
      <anchor>a61</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAnd, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;&amp;</name>
      <anchor>a62</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpOr, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator||</name>
      <anchor>a63</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLeftShift, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;&lt;</name>
      <anchor>a64</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpRightShift, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;&gt;</name>
      <anchor>a65</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a66</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a67</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a68</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpDivide, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator/</name>
      <anchor>a69</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a70</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a71</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a72</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a73</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnLdexp, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>ldexp</name>
      <anchor>a74</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnPow, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>pow</name>
      <anchor>a75</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnFmod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>fmod</name>
      <anchor>a76</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnArcTan2, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>atan2</name>
      <anchor>a77</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLT, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;</name>
      <anchor>a78</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLE, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;=</name>
      <anchor>a79</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGT, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;</name>
      <anchor>a80</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGE, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;=</name>
      <anchor>a81</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpEQ, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator==</name>
      <anchor>a82</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpNE, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator!=</name>
      <anchor>a83</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;&amp;</name>
      <anchor>a84</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator||</name>
      <anchor>a85</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLeftShift, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;&lt;</name>
      <anchor>a86</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpRightShift, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;&gt;</name>
      <anchor>a87</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a88</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a89</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a90</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpDivide, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator/</name>
      <anchor>a91</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a92</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a93</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a94</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a95</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnLdexp, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>ldexp</name>
      <anchor>a96</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnPow, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>pow</name>
      <anchor>a97</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnFmod, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>fmod</name>
      <anchor>a98</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnArcTan2, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>atan2</name>
      <anchor>a99</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLT, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;</name>
      <anchor>a100</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLE, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;=</name>
      <anchor>a101</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGT, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;</name>
      <anchor>a102</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGE, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;=</name>
      <anchor>a103</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpEQ, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator==</name>
      <anchor>a104</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpNE, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator!=</name>
      <anchor>a105</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAnd, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;&amp;</name>
      <anchor>a106</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpOr, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator||</name>
      <anchor>a107</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLeftShift, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;&lt;</name>
      <anchor>a108</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpRightShift, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;&gt;</name>
      <anchor>a109</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a110</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a111</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a112</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpDivide, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator/</name>
      <anchor>a113</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a114</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a115</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a116</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a117</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnLdexp, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>ldexp</name>
      <anchor>a118</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnPow, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>pow</name>
      <anchor>a119</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnFmod, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>fmod</name>
      <anchor>a120</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnArcTan2, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>atan2</name>
      <anchor>a121</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLT, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;</name>
      <anchor>a122</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLE, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;=</name>
      <anchor>a123</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGT, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;</name>
      <anchor>a124</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGE, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;=</name>
      <anchor>a125</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpEQ, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator==</name>
      <anchor>a126</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpNE, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator!=</name>
      <anchor>a127</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAnd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;&amp;</name>
      <anchor>a128</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpOr, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Vector&lt; T2, C2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator||</name>
      <anchor>a129</anchor>
      <arglist>(const T1 &amp;l, const Vector&lt; T2, C2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; TrinaryNode&lt; FnWhere, typename CreateLeaf&lt; Vector&lt; T1, C1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t, typename CreateLeaf&lt; T3 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>where</name>
      <anchor>a130</anchor>
      <arglist>(const Vector&lt; T1, C1 &gt; &amp;c, const T2 &amp;t, const T3 &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnArcCos, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>acos</name>
      <anchor>a131</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnArcSin, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>asin</name>
      <anchor>a132</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnArcTan, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>atan</name>
      <anchor>a133</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnCeil, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>ceil</name>
      <anchor>a134</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnCos, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>cos</name>
      <anchor>a135</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnHypCos, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>cosh</name>
      <anchor>a136</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnExp, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>exp</name>
      <anchor>a137</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnFabs, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>fabs</name>
      <anchor>a138</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnFloor, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>floor</name>
      <anchor>a139</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnLog, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>log</name>
      <anchor>a140</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnLog10, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>log10</name>
      <anchor>a141</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnSin, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>sin</name>
      <anchor>a142</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnHypSin, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>sinh</name>
      <anchor>a143</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnSqrt, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>sqrt</name>
      <anchor>a144</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnTan, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>tan</name>
      <anchor>a145</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; FnHypTan, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>tanh</name>
      <anchor>a146</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryMinus, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a147</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryPlus, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a148</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpBitwiseNot, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator~</name>
      <anchor>a149</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpIdentity, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>PETE_identity</name>
      <anchor>a150</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpNot, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator!</name>
      <anchor>a151</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpCast&lt; T1 &gt;, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>peteCast</name>
      <anchor>a152</anchor>
      <arglist>(const T1 &amp;, const Expression&lt; T2 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a153</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a154</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a155</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpDivide, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator/</name>
      <anchor>a156</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a157</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a158</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a159</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a160</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnLdexp, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>ldexp</name>
      <anchor>a161</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnPow, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>pow</name>
      <anchor>a162</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnFmod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>fmod</name>
      <anchor>a163</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnArcTan2, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>atan2</name>
      <anchor>a164</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLT, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;</name>
      <anchor>a165</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLE, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;=</name>
      <anchor>a166</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGT, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;</name>
      <anchor>a167</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGE, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;=</name>
      <anchor>a168</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpEQ, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator==</name>
      <anchor>a169</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpNE, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator!=</name>
      <anchor>a170</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;&amp;</name>
      <anchor>a171</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator||</name>
      <anchor>a172</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLeftShift, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;&lt;</name>
      <anchor>a173</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpRightShift, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;&gt;</name>
      <anchor>a174</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a175</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a176</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a177</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpDivide, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator/</name>
      <anchor>a178</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a179</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a180</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a181</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a182</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnLdexp, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>ldexp</name>
      <anchor>a183</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnPow, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>pow</name>
      <anchor>a184</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnFmod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>fmod</name>
      <anchor>a185</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnArcTan2, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>atan2</name>
      <anchor>a186</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLT, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;</name>
      <anchor>a187</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLE, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;=</name>
      <anchor>a188</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGT, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;</name>
      <anchor>a189</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGE, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;=</name>
      <anchor>a190</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpEQ, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator==</name>
      <anchor>a191</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpNE, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator!=</name>
      <anchor>a192</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;&amp;</name>
      <anchor>a193</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator||</name>
      <anchor>a194</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLeftShift, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;&lt;</name>
      <anchor>a195</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpRightShift, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;&gt;</name>
      <anchor>a196</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a197</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a198</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a199</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpDivide, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator/</name>
      <anchor>a200</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a201</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a202</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a203</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a204</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnLdexp, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>ldexp</name>
      <anchor>a205</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnPow, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>pow</name>
      <anchor>a206</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnFmod, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>fmod</name>
      <anchor>a207</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; FnArcTan2, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>atan2</name>
      <anchor>a208</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLT, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;</name>
      <anchor>a209</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpLE, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&lt;=</name>
      <anchor>a210</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGT, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;</name>
      <anchor>a211</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpGE, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator&gt;=</name>
      <anchor>a212</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpEQ, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator==</name>
      <anchor>a213</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpNE, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator!=</name>
      <anchor>a214</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAnd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;&amp;</name>
      <anchor>a215</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpOr, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator||</name>
      <anchor>a216</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; TrinaryNode&lt; FnWhere, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t, typename CreateLeaf&lt; T3 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>where</name>
      <anchor>a217</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;c, const T2 &amp;t, const T3 &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>assign</name>
      <anchor>a218</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>operator+=</name>
      <anchor>a219</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>operator-=</name>
      <anchor>a220</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>operator *=</name>
      <anchor>a221</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>operator/=</name>
      <anchor>a222</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>operator%=</name>
      <anchor>a223</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>operator|=</name>
      <anchor>a224</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>operator &amp;=</name>
      <anchor>a225</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>operator^=</name>
      <anchor>a226</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>operator&lt;&lt;=</name>
      <anchor>a227</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Vector&lt; T1, C1 &gt; &amp;</type>
      <name>operator&gt;&gt;=</name>
      <anchor>a228</anchor>
      <arglist>(Vector&lt; T1, C1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OhmmsVectorRef.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</path>
    <filename>OhmmsVectorRef_8h</filename>
  </compound>
  <compound kind="file">
    <name>OneBodyJastrowFunction.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>OneBodyJastrowFunction_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>OneDimCubicSpline.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>OneDimCubicSpline_8h</filename>
  </compound>
  <compound kind="file">
    <name>OneDimGridBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>OneDimGridBase_8h</filename>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a0</anchor>
      <arglist>(ostream &amp;out, const OneDimGridBase&lt; T &gt; &amp;rhs)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OneDimGridFunctor.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>OneDimGridFunctor_8h</filename>
  </compound>
  <compound kind="file">
    <name>OneDimIntegration.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>OneDimIntegration_8h</filename>
    <member kind="function">
      <type>GF::value_type</type>
      <name>integrate_RK2</name>
      <anchor>a0</anchor>
      <arglist>(const GF &amp;f, GF &amp;g)</arglist>
    </member>
    <member kind="function">
      <type>GF::value_type</type>
      <name>integrate_RK2_forward</name>
      <anchor>a1</anchor>
      <arglist>(const GF &amp;f, GF &amp;g)</arglist>
    </member>
    <member kind="function">
      <type>GF::value_type</type>
      <name>integrate_RK2_backward</name>
      <anchor>a2</anchor>
      <arglist>(const GF &amp;f, GF &amp;g)</arglist>
    </member>
    <member kind="function">
      <type>GF::value_type</type>
      <name>integrate_RK2</name>
      <anchor>a3</anchor>
      <arglist>(const GF &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>normalize_RK2</name>
      <anchor>a4</anchor>
      <arglist>(GF &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>Fn::value_type</type>
      <name>integrate_RK2</name>
      <anchor>a5</anchor>
      <arglist>(const GT &amp;grid, const Fn &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>GF::value_type</type>
      <name>integrate</name>
      <anchor>a6</anchor>
      <arglist>(const GF &amp;f)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>OrbitalBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>OrbitalBase_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>OrbitalBuilderBase.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>OrbitalBuilderBase_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>OrbitalBuilderBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>OrbitalBuilderBase_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>PadeJastrow.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>PadeJastrow_8h</filename>
  </compound>
  <compound kind="file">
    <name>ParameterSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>ParameterSet_8h</filename>
  </compound>
  <compound kind="file">
    <name>parse.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>parse_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ParticleAttrib.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</path>
    <filename>ParticleAttrib_8cpp</filename>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryMinus, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a0</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryPlus, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a1</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpBitwiseNot, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator~</name>
      <anchor>a2</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpIdentity, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>PETE_identity</name>
      <anchor>a3</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpCast&lt; T1 &gt;, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>peteCast</name>
      <anchor>a4</anchor>
      <arglist>(const T1 &amp;, const ParticleAttrib&lt; T2 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a5</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a6</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a7</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a8</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a9</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a10</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a11</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a12</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a13</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a14</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a15</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a16</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a17</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a18</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a19</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a20</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a21</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a22</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a23</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a24</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a25</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a26</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a27</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a28</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a29</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a30</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a31</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a32</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a33</anchor>
      <arglist>(const T1 &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a34</anchor>
      <arglist>(const T1 &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a35</anchor>
      <arglist>(const T1 &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a36</anchor>
      <arglist>(const T1 &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a37</anchor>
      <arglist>(const T1 &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a38</anchor>
      <arglist>(const T1 &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; ParticleAttrib&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a39</anchor>
      <arglist>(const T1 &amp;l, const ParticleAttrib&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; TrinaryNode&lt; FnWhere, typename CreateLeaf&lt; ParticleAttrib&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t, typename CreateLeaf&lt; T3 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>where</name>
      <anchor>a40</anchor>
      <arglist>(const ParticleAttrib&lt; T1 &gt; &amp;c, const T2 &amp;t, const T3 &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryMinus, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a41</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpUnaryPlus, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a42</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpBitwiseNot, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator~</name>
      <anchor>a43</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpIdentity, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>PETE_identity</name>
      <anchor>a44</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; UnaryNode&lt; OpCast&lt; T1 &gt;, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>peteCast</name>
      <anchor>a45</anchor>
      <arglist>(const T1 &amp;, const Expression&lt; T2 &gt; &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a46</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a47</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a48</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a49</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a50</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a51</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a52</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a53</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a54</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a55</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a56</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a57</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a58</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a59</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;l, const T2 &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpAdd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator+</name>
      <anchor>a60</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpSubtract, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator-</name>
      <anchor>a61</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMultiply, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator *</name>
      <anchor>a62</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpMod, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator%</name>
      <anchor>a63</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseAnd, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator &amp;</name>
      <anchor>a64</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseOr, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator|</name>
      <anchor>a65</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; BinaryNode&lt; OpBitwiseXor, typename CreateLeaf&lt; T1 &gt;::Leaf_t, typename CreateLeaf&lt; Expression&lt; T2 &gt; &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>operator^</name>
      <anchor>a66</anchor>
      <arglist>(const T1 &amp;l, const Expression&lt; T2 &gt; &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>MakeReturn&lt; TrinaryNode&lt; FnWhere, typename CreateLeaf&lt; Expression&lt; T1 &gt; &gt;::Leaf_t, typename CreateLeaf&lt; T2 &gt;::Leaf_t, typename CreateLeaf&lt; T3 &gt;::Leaf_t &gt; &gt;::Expression_t</type>
      <name>where</name>
      <anchor>a67</anchor>
      <arglist>(const Expression&lt; T1 &gt; &amp;c, const T2 &amp;t, const T3 &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>ParticleAttrib&lt; T1 &gt; &amp;</type>
      <name>assign</name>
      <anchor>a68</anchor>
      <arglist>(ParticleAttrib&lt; T1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ParticleAttrib&lt; T1 &gt; &amp;</type>
      <name>operator+=</name>
      <anchor>a69</anchor>
      <arglist>(ParticleAttrib&lt; T1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ParticleAttrib&lt; T1 &gt; &amp;</type>
      <name>operator-=</name>
      <anchor>a70</anchor>
      <arglist>(ParticleAttrib&lt; T1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ParticleAttrib&lt; T1 &gt; &amp;</type>
      <name>operator *=</name>
      <anchor>a71</anchor>
      <arglist>(ParticleAttrib&lt; T1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ParticleAttrib&lt; T1 &gt; &amp;</type>
      <name>operator%=</name>
      <anchor>a72</anchor>
      <arglist>(ParticleAttrib&lt; T1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ParticleAttrib&lt; T1 &gt; &amp;</type>
      <name>operator|=</name>
      <anchor>a73</anchor>
      <arglist>(ParticleAttrib&lt; T1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ParticleAttrib&lt; T1 &gt; &amp;</type>
      <name>operator &amp;=</name>
      <anchor>a74</anchor>
      <arglist>(ParticleAttrib&lt; T1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ParticleAttrib&lt; T1 &gt; &amp;</type>
      <name>operator^=</name>
      <anchor>a75</anchor>
      <arglist>(ParticleAttrib&lt; T1 &gt; &amp;lhs, const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a76</anchor>
      <arglist>(ParticleAttrib&lt; T &gt; &amp;lhs, const Op &amp;op, const Expression&lt; RHS &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a77</anchor>
      <arglist>(ostream &amp;out, const ParticleAttrib&lt; T &gt; &amp;rhs)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ParticleAttrib.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</path>
    <filename>ParticleAttrib_8h</filename>
    <member kind="define">
      <type>#define</type>
      <name>DEBUGMSG</name>
      <anchor>a0</anchor>
      <arglist>(msg)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ParticleBase.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</path>
    <filename>ParticleBase_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>ParticleBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</path>
    <filename>ParticleBase_8h</filename>
  </compound>
  <compound kind="file">
    <name>ParticleFunctions.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</path>
    <filename>ParticleFunctions_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>PartitionGrid</name>
      <anchor>a0</anchor>
      <arglist>(PL &amp;lattice, GIM &amp;grid)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>ExpandSuperCell</name>
      <anchor>a1</anchor>
      <arglist>(PT &amp;in_, PT &amp;out_, GIV &amp;uc_grid, GIM &amp;grid)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>ExpandSuperCellOMP</name>
      <anchor>a2</anchor>
      <arglist>(PT &amp;in_, PT &amp;out_, GIV &amp;uc_grid, GIM &amp;grid)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>ExpandSuperCell</name>
      <anchor>a3</anchor>
      <arglist>(PT &amp;inout_, GIV &amp;uc_grid)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ParticleMessage.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</path>
    <filename>ParticleMessage_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>gsum</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;, int)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ParticleSet.BC.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>ParticleSet_8BC_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>ParticleSet.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>ParticleSet_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>ParticleSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>ParticleSet_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>ParticleSetPool.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>ParticleSetPool_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>ParticleSetPool.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>ParticleSetPool_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>ParticleTags.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/</path>
    <filename>ParticleTags_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>ParticleTags.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/</path>
    <filename>ParticleTags_8h</filename>
  </compound>
  <compound kind="file">
    <name>ParticleUtility.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</path>
    <filename>ParticleUtility_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>convert</name>
      <anchor>a0</anchor>
      <arglist>(const PL &amp;lat, const PV &amp;pin, PV &amp;pout)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>convert2Cart</name>
      <anchor>a1</anchor>
      <arglist>(const PL &amp;lat, PV &amp;pin)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>convert2Unit</name>
      <anchor>a2</anchor>
      <arglist>(const PL &amp;lat, PV &amp;pin)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>wrapAroundBox</name>
      <anchor>a3</anchor>
      <arglist>(const PL &amp;lat, const PV &amp;pin, PV &amp;pout)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>Dot</name>
      <anchor>a4</anchor>
      <arglist>(const ParticleAttrib&lt; TinyVector&lt; T, D &gt; &gt; &amp;pa, const ParticleAttrib&lt; TinyVector&lt; T, D &gt; &gt; &amp;pb)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>normalize</name>
      <anchor>a5</anchor>
      <arglist>(ParticleAttrib&lt; TinyVector&lt; T, D &gt; &gt; &amp;pa)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>PC.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>PC_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>PLayoutFunctions.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>PLayoutFunctions_8h</filename>
    <namespace>OHMMS</namespace>
  </compound>
  <compound kind="file">
    <name>PolarizationEstimator.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Estimators/</path>
    <filename>PolarizationEstimator_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>PolarizationPotential.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>PolarizationPotential_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>PolarizedJastrow.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>PolarizedJastrow_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>PolymerChain.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>PolymerChain_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>PolymerEstimator.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>PolymerEstimator_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>PolymerEstimator.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>PolymerEstimator_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>PooledData.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>PooledData_8h</filename>
  </compound>
  <compound kind="file">
    <name>ProjectData.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsApp/</path>
    <filename>ProjectData_8cpp</filename>
    <namespace>OHMMS</namespace>
  </compound>
  <compound kind="file">
    <name>ProjectData.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsApp/</path>
    <filename>ProjectData_8h</filename>
    <namespace>OHMMS</namespace>
    <member kind="define">
      <type>#define</type>
      <name>OHHMS_PROJECTDATA_H__</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>QDwf.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>QDwf_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>QDwf.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>QDwf_8h</filename>
  </compound>
  <compound kind="file">
    <name>QDwfBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>QDwfBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>QDwfBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>QDwfBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>qmcapp.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>qmcapp_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>QMCAppBase.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>QMCAppBase_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>QMCAppBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>QMCAppBase_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>QMCDriver.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>QMCDriver_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>QMCDriver.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>QMCDriver_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>QMCGaussianParserBase.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>QMCGaussianParserBase_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>QMCGaussianParserBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>QMCGaussianParserBase_8h</filename>
  </compound>
  <compound kind="file">
    <name>QMCHamiltonian.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>QMCHamiltonian_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>QMCHamiltonian.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>QMCHamiltonian_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>QMCHamiltonianBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>QMCHamiltonianBase_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>QMCMain.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>QMCMain_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>QMCMain.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>QMCMain_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>QMCUtilities.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>QMCUtilities_8h</filename>
    <namespace>ohmmsqmc</namespace>
    <member kind="function">
      <type>bool</type>
      <name>determineNumOfElectrons</name>
      <anchor>a13</anchor>
      <arglist>(ParticleSet &amp;el, xmlXPathContextPtr acontext)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>RadialFunctorUtility.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>RadialFunctorUtility_8h</filename>
    <member kind="function">
      <type>T</type>
      <name>Phisq_x_Yk</name>
      <anchor>a0</anchor>
      <arglist>(const GF &amp;g, const GF &amp;a, const GF &amp;b, T prefactor)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>Ykofr</name>
      <anchor>a1</anchor>
      <arglist>(GF &amp;g, const GF &amp;a, const GF &amp;b, int k)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>Make_Loc_Pot</name>
      <anchor>a2</anchor>
      <arglist>(GF &amp;g, const GF &amp;y, const GF &amp;a, const GF &amp;b, typename GF::value_type coeff)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>RadialOrbitalBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>RadialOrbitalBase_8h</filename>
  </compound>
  <compound kind="file">
    <name>RandomFunctors.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>RandomFunctors_8h</filename>
  </compound>
  <compound kind="file">
    <name>RandomGenerator.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>RandomGenerator_8cpp</filename>
    <member kind="variable">
      <type>RandomGenerator_t</type>
      <name>Random</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>RandomGenerator.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>RandomGenerator_8h</filename>
    <member kind="typedef">
      <type>RandRandom</type>
      <name>RandomGenerator_t</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RandomGenerator_t</type>
      <name>Random</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>RandomNumberControl.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsApp/</path>
    <filename>RandomNumberControl_8cpp</filename>
    <namespace>OHMMS</namespace>
  </compound>
  <compound kind="file">
    <name>RandomNumberControl.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsApp/</path>
    <filename>RandomNumberControl_8h</filename>
    <namespace>OHMMS</namespace>
  </compound>
  <compound kind="file">
    <name>RandomSeqGenerator.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</path>
    <filename>RandomSeqGenerator_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>assignGaussRand</name>
      <anchor>a0</anchor>
      <arglist>(T *restrict a, unsigned n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>assignUniformRand</name>
      <anchor>a1</anchor>
      <arglist>(T *restrict a, unsigned n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>makeGaussRandom</name>
      <anchor>a2</anchor>
      <arglist>(Matrix&lt; TinyVector&lt; double, 3 &gt; &gt; &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>makeGaussRandom</name>
      <anchor>a3</anchor>
      <arglist>(ParticleAttrib&lt; TinyVector&lt; double, 3 &gt; &gt; &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>makeGaussRandom</name>
      <anchor>a4</anchor>
      <arglist>(ParticleAttrib&lt; double &gt; &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>makeUniformRandom</name>
      <anchor>a5</anchor>
      <arglist>(ParticleAttrib&lt; TinyVector&lt; double, 3 &gt; &gt; &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>makeUniformRandom</name>
      <anchor>a6</anchor>
      <arglist>(ParticleAttrib&lt; double &gt; &amp;a)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>RandRandom.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>RandRandom_8cpp</filename>
    <member kind="define">
      <type>#define</type>
      <name>struct_t</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>RandRandom.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>RandRandom_8h</filename>
  </compound>
  <compound kind="file">
    <name>RecordProperty.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>RecordProperty_8h</filename>
  </compound>
  <compound kind="file">
    <name>ReptationMC.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>ReptationMC_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>ReptationMC.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>ReptationMC_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>RGFBuilderBase.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>RGFBuilderBase_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>RGFBuilderBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>RGFBuilderBase_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>RPAJastrow.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>RPAJastrow_8h</filename>
  </compound>
  <compound kind="file">
    <name>RQMCMultiple.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>RQMCMultiple_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>RQMCMultiple.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>RQMCMultiple_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>ScalarEstimatorBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Estimators/</path>
    <filename>ScalarEstimatorBase_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>ScalarEstimatorManager.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Estimators/</path>
    <filename>ScalarEstimatorManager_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>ScalarEstimatorManager.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Estimators/</path>
    <filename>ScalarEstimatorManager_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>SimpleParser.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>SimpleParser_8cpp</filename>
    <member kind="function">
      <type>char *</type>
      <name>readLine</name>
      <anchor>a0</anchor>
      <arglist>(char *s, int max, istream &amp;fp)</arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>parsewords</name>
      <anchor>a1</anchor>
      <arglist>(char *inbuf, vector&lt; string &gt; &amp;slist)</arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>parsewords</name>
      <anchor>a2</anchor>
      <arglist>(char *inbuf, list&lt; string &gt; &amp;slist)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getwords</name>
      <anchor>a3</anchor>
      <arglist>(vector&lt; string &gt; &amp;slist, istream &amp;fp)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>readXmol</name>
      <anchor>a4</anchor>
      <arglist>(istream &amp;fxmol, double *data, int numvar)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getwords</name>
      <anchor>a5</anchor>
      <arglist>(vector&lt; string &gt; &amp;slist, istream &amp;fpos, const char *field, const char *terminate)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getwords</name>
      <anchor>a6</anchor>
      <arglist>(vector&lt; string &gt; &amp;slist, istream &amp;fpos, const char *terminate)</arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>parseXwords</name>
      <anchor>a7</anchor>
      <arglist>(char *inbuf, vector&lt; string &gt; &amp;slist)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getXwords</name>
      <anchor>a8</anchor>
      <arglist>(vector&lt; string &gt; &amp;slist, istream &amp;fp)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getXwords</name>
      <anchor>a9</anchor>
      <arglist>(vector&lt; string &gt; &amp;slist, istream &amp;fpos, const char *terminate)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>SimpleParser.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>SimpleParser_8h</filename>
    <member kind="function">
      <type>char *</type>
      <name>readLine</name>
      <anchor>a0</anchor>
      <arglist>(char *s, int max, istream &amp;fp)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getwords</name>
      <anchor>a1</anchor>
      <arglist>(vector&lt; string &gt; &amp;slist, istream &amp;fp)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getwords</name>
      <anchor>a2</anchor>
      <arglist>(vector&lt; string &gt; &amp;slist, istream &amp;fpos, const char *field, const char *terminate)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getwords</name>
      <anchor>a3</anchor>
      <arglist>(vector&lt; string &gt; &amp;slist, istream &amp;fpos, const char *terminate)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getXwords</name>
      <anchor>a4</anchor>
      <arglist>(vector&lt; string &gt; &amp;slist, istream &amp;fp)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getXwords</name>
      <anchor>a5</anchor>
      <arglist>(vector&lt; string &gt; &amp;slist, istream &amp;fpos, const char *terminate)</arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>parsewords</name>
      <anchor>a6</anchor>
      <arglist>(char *inbuf, vector&lt; string &gt; &amp;slist)</arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>parsewords</name>
      <anchor>a7</anchor>
      <arglist>(char *inbuf, list&lt; string &gt; &amp;slist)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>readXmol</name>
      <anchor>a8</anchor>
      <arglist>(istream &amp;, double *, int)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>SingleParticleOrbitalSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>SingleParticleOrbitalSet_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>SlaterBasisSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>SlaterBasisSet_8h</filename>
  </compound>
  <compound kind="file">
    <name>SlaterDeterminant.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>SlaterDeterminant_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>SlaterTypeOrbital.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>SlaterTypeOrbital_8h</filename>
  </compound>
  <compound kind="file">
    <name>SpeciesSet.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>SpeciesSet_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>SpeciesSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>SpeciesSet_8h</filename>
  </compound>
  <compound kind="file">
    <name>SphericalOrbitalSet.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>SphericalOrbitalSet_8h</filename>
    <namespace>ohmmsqmc</namespace>
    <member kind="typedef">
      <type>TinyVector&lt; int, 4 &gt;</type>
      <name>QuantumNumberType</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>q_n</name>
      <anchor>a16a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>q_l</name>
      <anchor>a16a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>q_m</name>
      <anchor>a16a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>q_s</name>
      <anchor>a16a10</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>SphericalTensor.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>SphericalTensor_8h</filename>
  </compound>
  <compound kind="file">
    <name>spline.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>spline_8cpp</filename>
    <member kind="define">
      <type>#define</type>
      <name>FUNCTION</name>
      <anchor>a0</anchor>
      <arglist>(r)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>DFUNCTION</name>
      <anchor>a1</anchor>
      <arglist>(r)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a2</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>spline3.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>spline3_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>spline3_io.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>spline3__io_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>Spline3DBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/Spline3D/</path>
    <filename>Spline3DBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>Spline3DBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/Spline3D/</path>
    <filename>Spline3DBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>Spline3DPotential.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>Spline3DPotential_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>SPOSetBase.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>SPOSetBase_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>SprngRandom.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>SprngRandom_8h</filename>
    <member kind="define">
      <type>#define</type>
      <name>SRSEED</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>STO2GridBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>STO2GridBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>STO2GridBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>STO2GridBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>STOMolecularOrbitals.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>STOMolecularOrbitals_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>STOMolecularOrbitals.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>STOMolecularOrbitals_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>SymmetricDistanceTableData.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>SymmetricDistanceTableData_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>Tensor.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</path>
    <filename>Tensor_8h</filename>
    <member kind="function">
      <type>T</type>
      <name>trace</name>
      <anchor>a0</anchor>
      <arglist>(const Tensor&lt; T, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt;</type>
      <name>transpose</name>
      <anchor>a1</anchor>
      <arglist>(const Tensor&lt; T, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; typename BinaryReturn&lt; T1, T2, OpMultiply &gt;::Type_t, D &gt;</type>
      <name>dot</name>
      <anchor>a2</anchor>
      <arglist>(const Tensor&lt; T1, D &gt; &amp;lhs, const Tensor&lt; T2, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>TinyVector&lt; typename BinaryReturn&lt; T1, T2, OpMultiply &gt;::Type_t, D &gt;</type>
      <name>dot</name>
      <anchor>a3</anchor>
      <arglist>(const TinyVector&lt; T1, D &gt; &amp;lhs, const Tensor&lt; T2, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>TinyVector&lt; typename BinaryReturn&lt; T1, T2, OpMultiply &gt;::Type_t, D &gt;</type>
      <name>dot</name>
      <anchor>a4</anchor>
      <arglist>(const Tensor&lt; T1, D &gt; &amp;lhs, const TinyVector&lt; T2, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a5</anchor>
      <arglist>(std::ostream &amp;out, const Tensor&lt; T, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>std::istream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a6</anchor>
      <arglist>(std::istream &amp;is, Tensor&lt; T, D &gt; &amp;rhs)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>TinyMatrixRef.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</path>
    <filename>TinyMatrixRef_8h</filename>
  </compound>
  <compound kind="file">
    <name>TinyVector.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</path>
    <filename>TinyVector_8h</filename>
    <member kind="function">
      <type>BinaryReturn&lt; T1, T2, OpMultiply &gt;::Type_t</type>
      <name>dot</name>
      <anchor>a0</anchor>
      <arglist>(const TinyVector&lt; T1, D &gt; &amp;lhs, const TinyVector&lt; T2, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>TinyVector&lt; typename BinaryReturn&lt; T1, T2, OpMultiply &gt;::Type_t, D &gt;</type>
      <name>cross</name>
      <anchor>a1</anchor>
      <arglist>(const TinyVector&lt; T1, D &gt; &amp;lhs, const TinyVector&lt; T2, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; typename BinaryReturn&lt; T1, T2, OpMultiply &gt;::Type_t, D &gt;</type>
      <name>outerProduct</name>
      <anchor>a2</anchor>
      <arglist>(const TinyVector&lt; T1, D &gt; &amp;lhs, const TinyVector&lt; T2, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a3</anchor>
      <arglist>(std::ostream &amp;out, const TinyVector&lt; T, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>std::istream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a4</anchor>
      <arglist>(std::istream &amp;is, TinyVector&lt; T, D &gt; &amp;rhs)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>Transform2GridFunctor.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>Transform2GridFunctor_8h</filename>
    <member kind="function">
      <type>Transform2GridFunctorBase&lt; FnOut &gt; *</type>
      <name>createTransform2GridFunctor</name>
      <anchor>a0</anchor>
      <arglist>(FnIn &amp;in, FnOut &amp;out)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>TrialWaveFunction.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>TrialWaveFunction_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>TrialWaveFunction.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>TrialWaveFunction_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>TriCubicSplineBuilder.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>TriCubicSplineBuilder_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>TriCubicSplineBuilder.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>TriCubicSplineBuilder_8h</filename>
    <namespace>ohmmsqmc</namespace>
    <member kind="define">
      <type>#define</type>
      <name>OHMMS_QMC_TRICUBICSPLINE3DBUILDER_H</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>TriCubicSplinePotential.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>TriCubicSplinePotential_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>TriCubicSplineT.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>TriCubicSplineT_8h</filename>
  </compound>
  <compound kind="file">
    <name>TwoBodyJastrowFunction.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>TwoBodyJastrowFunction_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>TwoBodyJastrowFunction.Shared.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>TwoBodyJastrowFunction_8Shared_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>UOverRN.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>UOverRN_8h</filename>
  </compound>
  <compound kind="file">
    <name>UtilityFunctions.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>UtilityFunctions_8h</filename>
    <member kind="function">
      <type>void</type>
      <name>FairDivide</name>
      <anchor>a0</anchor>
      <arglist>(int ntot, int npart, IV &amp;adist)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>VMC.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMC_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMC.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMC_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMC_OPT.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMC__OPT_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMC_OPT.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMC__OPT_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMCMoveAll.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMCMoveAll_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMCMoveAll.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMCMoveAll_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMCMultiple.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMCMultiple_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMCMultiple.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMCMultiple_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMCParticleByParticle.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMCParticleByParticle_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMCParticleByParticle.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMCParticleByParticle_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMCPbyPMultiple.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMCPbyPMultiple_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>VMCPbyPMultiple.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>VMCPbyPMultiple_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>Walker.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>Walker_8h</filename>
    <namespace>ohmmsqmc</namespace>
    <member kind="enumvalue">
      <name>LOGPSI</name>
      <anchor>a15a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SIGN</name>
      <anchor>a15a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>UMBRELLAWEIGHT</name>
      <anchor>a15a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LOCALENERGY</name>
      <anchor>a15a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LOCALPOTENTIAL</name>
      <anchor>a15a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>NUMPROPERTIES</name>
      <anchor>a15a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a11</anchor>
      <arglist>(ostream &amp;out, const Walker&lt; T, PA &gt; &amp;rhs)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>WaveFunctionPool.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>WaveFunctionPool_8cpp</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>WaveFunctionPool.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>WaveFunctionPool_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>WaveFunctionTester.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>WaveFunctionTester_8cpp</filename>
  </compound>
  <compound kind="file">
    <name>WaveFunctionTester.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>WaveFunctionTester_8h</filename>
    <namespace>ohmmsqmc</namespace>
  </compound>
  <compound kind="file">
    <name>XMLTemplate.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>XMLTemplate_8h</filename>
    <namespace>OHMMS</namespace>
    <member kind="function">
      <type>void</type>
      <name>printXML</name>
      <anchor>a0</anchor>
      <arglist>(const T &amp;, ostream &amp;)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>XYZCubicGrid.h</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>XYZCubicGrid_8h</filename>
  </compound>
  <compound kind="file">
    <name>ylmtest.cpp</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>ylmtest_8cpp</filename>
    <member kind="function">
      <type>int</type>
      <name>main</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>Any2Slater</name>
    <filename>classAny2Slater.html</filename>
    <base>MinimizeFunction</base>
    <member kind="typedef">
      <type>OneDimGridFunctor&lt; scalar &gt;</type>
      <name>SourceType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>LogGrid&lt; scalar &gt;</type>
      <name>GridType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Any2Slater</name>
      <anchor>a0</anchor>
      <arglist>(SourceType &amp;in)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>NumParams</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>scalar &amp;</type>
      <name>Params</name>
      <anchor>a3</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>scalar</type>
      <name>Params</name>
      <anchor>a4</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>scalar</type>
      <name>Cost</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>WriteStuff</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>optimize</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SourceType &amp;</type>
      <name>Source</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>scalar</type>
      <name>cg_tolerance</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>scalar</type>
      <name>cg_stepsize</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>scalar</type>
      <name>cg_epsilon</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>minIndex</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>xmlNodePtr</type>
      <name>mPtr</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GenericSTO&lt; scalar &gt;</type>
      <name>Target</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; scalar &gt;</type>
      <name>OptParams</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Vector&lt; scalar &gt;</type>
      <name>psi_sq</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Vector&lt; scalar &gt;</type>
      <name>psi_norm</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ApplyBConds</name>
    <filename>structApplyBConds.html</filename>
    <templarg>T1</templarg>
    <templarg>T2</templarg>
    <templarg>ORTHO</templarg>
  </compound>
  <compound kind="struct">
    <name>ApplyBConds&lt; ParticleAttrib&lt; TinyVector&lt; T, 3 &gt; &gt;, Tensor&lt; T, 3 &gt;, false &gt;</name>
    <filename>structApplyBConds_3_01ParticleAttrib_3_01TinyVector_3_01T_00_013_01_4_01_4_00_01Tensor_3_01T_00_013_01_4_00_01false_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>ParticleAttrib&lt; TinyVector&lt; T, 3 &gt; &gt;</type>
      <name>Array_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Array_t::Type_t</type>
      <name>Component_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Tensor&lt; T, 3 &gt;</type>
      <name>Transformer_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Cart2Cart</name>
      <anchor>e0</anchor>
      <arglist>(const Array_t &amp;pin, const Transformer_t &amp;G, const Transformer_t &amp;R, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Cart2Unit</name>
      <anchor>e1</anchor>
      <arglist>(const Array_t &amp;pin, const Transformer_t &amp;G, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Unit2Cart</name>
      <anchor>e2</anchor>
      <arglist>(const Array_t &amp;pin, const Transformer_t &amp;R, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Unit2Unit</name>
      <anchor>e3</anchor>
      <arglist>(const Array_t &amp;pin, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Unit2Unit</name>
      <anchor>e4</anchor>
      <arglist>(Array_t &amp;pinout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Cart2Cart</name>
      <anchor>e5</anchor>
      <arglist>(Array_t &amp;pinout, const Transformer_t &amp;G, const Transformer_t &amp;R, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Component_t</type>
      <name>Unit2Unit</name>
      <anchor>e6</anchor>
      <arglist>(const Component_t &amp;pos)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Component_t</type>
      <name>Cart2Unit</name>
      <anchor>e7</anchor>
      <arglist>(const Component_t &amp;pos, const Transformer_t &amp;G)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Component_t</type>
      <name>Unit2Cart</name>
      <anchor>e8</anchor>
      <arglist>(const Component_t &amp;pos, const Transformer_t &amp;R)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Component_t</type>
      <name>Cart2Cart</name>
      <anchor>e9</anchor>
      <arglist>(const Component_t &amp;pos, const Transformer_t &amp;G, const Transformer_t &amp;R)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ApplyBConds&lt; ParticleAttrib&lt; TinyVector&lt; T, 3 &gt; &gt;, Tensor&lt; T, 3 &gt;, true &gt;</name>
    <filename>structApplyBConds_3_01ParticleAttrib_3_01TinyVector_3_01T_00_013_01_4_01_4_00_01Tensor_3_01T_00_013_01_4_00_01true_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>ParticleAttrib&lt; TinyVector&lt; T, 3 &gt; &gt;</type>
      <name>Array_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Array_t::Type_t</type>
      <name>Component_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Tensor&lt; T, 3 &gt;</type>
      <name>Transformer_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Unit2Unit</name>
      <anchor>e0</anchor>
      <arglist>(const Array_t &amp;pin, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Unit2Cart</name>
      <anchor>e1</anchor>
      <arglist>(const Array_t &amp;pin, const Transformer_t &amp;R, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Cart2Unit</name>
      <anchor>e2</anchor>
      <arglist>(const Array_t &amp;pin, const Transformer_t &amp;G, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Cart2Cart</name>
      <anchor>e3</anchor>
      <arglist>(const Array_t &amp;pin, const Transformer_t &amp;G, const Transformer_t &amp;R, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Unit2Unit</name>
      <anchor>e4</anchor>
      <arglist>(Array_t &amp;pinout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>Cart2Cart</name>
      <anchor>e5</anchor>
      <arglist>(Array_t &amp;pinout, const Transformer_t &amp;G, const Transformer_t &amp;R, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Component_t</type>
      <name>Unit2Unit</name>
      <anchor>e6</anchor>
      <arglist>(const Component_t &amp;pos)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Component_t</type>
      <name>Cart2Unit</name>
      <anchor>e7</anchor>
      <arglist>(const Component_t &amp;pos, const Transformer_t &amp;G)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Component_t</type>
      <name>Unit2Cart</name>
      <anchor>e8</anchor>
      <arglist>(const Component_t &amp;pos, const Transformer_t &amp;R)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Component_t</type>
      <name>Cart2Cart</name>
      <anchor>e9</anchor>
      <arglist>(const Component_t &amp;pos, const Transformer_t &amp;G, const Transformer_t &amp;R)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>BLAS</name>
    <filename>structBLAS.html</filename>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>axpy</name>
      <anchor>e0</anchor>
      <arglist>(int n, double x, const double *a, double *b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>axpy</name>
      <anchor>e1</anchor>
      <arglist>(int n, double x, const double *a, int incx, double *b, int incy)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>axpy</name>
      <anchor>e2</anchor>
      <arglist>(int n, const double *a, double *b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>axpy</name>
      <anchor>e3</anchor>
      <arglist>(int n, float x, const float *a, int incx, float *b, int incy)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>axpy</name>
      <anchor>e4</anchor>
      <arglist>(int n, const complex&lt; double &gt; x, const complex&lt; double &gt; *a, int incx, complex&lt; double &gt; *b, int incy)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static double</type>
      <name>norm2</name>
      <anchor>e5</anchor>
      <arglist>(int n, const double *a, int incx=1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static double</type>
      <name>norm2</name>
      <anchor>e6</anchor>
      <arglist>(int n, const complex&lt; double &gt; *a, int incx=1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static float</type>
      <name>norm2</name>
      <anchor>e7</anchor>
      <arglist>(int n, const float *a, int incx=1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>scal</name>
      <anchor>e8</anchor>
      <arglist>(int n, double alpha, double *x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>gemv</name>
      <anchor>e9</anchor>
      <arglist>(int n, int m, const double *amat, const double *x, double *y)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static double</type>
      <name>dot</name>
      <anchor>e10</anchor>
      <arglist>(int n, const double *a, const double *b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static float</type>
      <name>dot</name>
      <anchor>e11</anchor>
      <arglist>(int n, const float *a, const float *b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>copy</name>
      <anchor>e12</anchor>
      <arglist>(int n, const double *a, double *b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>copy</name>
      <anchor>e13</anchor>
      <arglist>(int n, const double *a, int ia, double *b, int ib)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>copy</name>
      <anchor>e14</anchor>
      <arglist>(int n, const complex&lt; double &gt; *a, complex&lt; double &gt; *b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>copy</name>
      <anchor>e15</anchor>
      <arglist>(int n, const complex&lt; double &gt; *a, int ia, complex&lt; double &gt; *b, int ib)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const int</type>
      <name>INCX</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const int</type>
      <name>INCY</name>
      <anchor>s1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const char</type>
      <name>UPLO</name>
      <anchor>s2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const char</type>
      <name>TRANS</name>
      <anchor>s3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const float</type>
      <name>sone</name>
      <anchor>s4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const float</type>
      <name>szero</name>
      <anchor>s5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const double</type>
      <name>done</name>
      <anchor>s6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const double</type>
      <name>dzero</name>
      <anchor>s7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const complex&lt; float &gt;</type>
      <name>cone</name>
      <anchor>s8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const complex&lt; float &gt;</type>
      <name>czero</name>
      <anchor>s9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const complex&lt; double &gt;</type>
      <name>zone</name>
      <anchor>s10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const complex&lt; double &gt;</type>
      <name>zzero</name>
      <anchor>s11</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>BoostRandom</name>
    <filename>classBoostRandom.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Return_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>boost::minstd_rand</type>
      <name>base_generator_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>boost::mt19937</type>
      <name>generator_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>boost::variate_generator&lt; generator_type, boost::uniform_real&lt; T &gt; &gt;</type>
      <name>uniform_generator_type</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BoostRandom</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BoostRandom</name>
      <anchor>a1</anchor>
      <arglist>(int iseed)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~BoostRandom</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a3</anchor>
      <arglist>(int i, int nstr, int iseed)</arglist>
    </member>
    <member kind="function">
      <type>uniform_generator_type &amp;</type>
      <name>getGenerator</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>getRandom</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>operator()</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>irand</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>bivariate</name>
      <anchor>a8</anchor>
      <arglist>(Return_t &amp;g1, Return_t &amp;g2)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>baseSeed</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>base_generator_type</type>
      <name>base_generator</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>boost::uniform_real&lt; T &gt;</type>
      <name>unit_dist</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>generator_type *</type>
      <name>generator</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>uniform_generator_type *</type>
      <name>uni</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>CasinoParser</name>
    <filename>classCasinoParser.html</filename>
    <base>QMCGaussianParserBase</base>
    <base>OhmmsAsciiParser</base>
    <member kind="function">
      <type></type>
      <name>CasinoParser</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CasinoParser</name>
      <anchor>a1</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>parse</name>
      <anchor>a2</anchor>
      <arglist>(const std::string &amp;fname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getGeometry</name>
      <anchor>a3</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getGaussianCenters</name>
      <anchor>a4</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getNumberOfAtoms</name>
      <anchor>a5</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getAtomicPositions</name>
      <anchor>a6</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getAtomicNumbers</name>
      <anchor>a7</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getValenceCharges</name>
      <anchor>a8</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>contractionCorrection</name>
      <anchor>a9</anchor>
      <arglist>(int shell_id, double alpha)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>makeCorrections</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>BasisCorrection</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ChebyshevJastrow</name>
    <filename>structChebyshevJastrow.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>ChebyshevJastrow</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>(vector&lt; T &gt; a)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(T r, T &amp;dudr, T &amp;d2udr2)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur, VarRegistry&lt; T1 &gt; &amp;vlist)</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>B</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>L</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>lmax</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; T &gt;</type>
      <name>alpha</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; T &gt;</type>
      <name>TT</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; T &gt;</type>
      <name>dTT</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; T &gt;</type>
      <name>d2TT</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>Clebsch_Gordan</name>
    <filename>classClebsch__Gordan.html</filename>
    <member kind="function">
      <type></type>
      <name>Clebsch_Gordan</name>
      <anchor>a0</anchor>
      <arglist>(const int lmax)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Clebsch_Gordan</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>index</name>
      <anchor>a2</anchor>
      <arglist>(int l1, int l2, int l3, int m1, int m2) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>cg</name>
      <anchor>a3</anchor>
      <arglist>(int l1, int l2, int l3, int m1, int m2) const </arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; double &gt;</type>
      <name>CG_coeff</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Clebsch_Gordan</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>Lmax</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>L1max</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>L2max</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ComboFunc</name>
    <filename>structComboFunc.html</filename>
    <member kind="function">
      <type></type>
      <name>ComboFunc</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>push_back</name>
      <anchor>a1</anchor>
      <arglist>(double c, TestFunc *fn)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>f</name>
      <anchor>a2</anchor>
      <arglist>(double x, double y, double z)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>d2f</name>
      <anchor>a3</anchor>
      <arglist>(double x, double y, double z)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>f</name>
      <anchor>a4</anchor>
      <arglist>(const TinyVector&lt; double, 3 &gt; &amp;pos)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>d2f</name>
      <anchor>a5</anchor>
      <arglist>(const TinyVector&lt; double, 3 &gt; &amp;pos)</arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; double &gt;</type>
      <name>C</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; TestFunc * &gt;</type>
      <name>F</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ConstScale</name>
    <filename>structConstScale.html</filename>
    <member kind="function">
      <type></type>
      <name>ConstScale</name>
      <anchor>a0</anchor>
      <arglist>(double c=1.0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ConstScale</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(double r)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>a3</anchor>
      <arglist>(double r, double &amp;vr)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>a4</anchor>
      <arglist>(double r, double &amp;vr, double &amp;dvr)</arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>C</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ConvertPosUnit</name>
    <filename>structConvertPosUnit.html</filename>
    <templarg>T1</templarg>
    <templarg>T2</templarg>
    <templarg>ORTHO</templarg>
  </compound>
  <compound kind="struct">
    <name>ConvertPosUnit&lt; ParticleAttrib&lt; TinyVector&lt; T, 3 &gt; &gt;, Tensor&lt; T, 3 &gt;, false &gt;</name>
    <filename>structConvertPosUnit_3_01ParticleAttrib_3_01TinyVector_3_01T_00_013_01_4_01_4_00_01Tensor_3_01T_00_013_01_4_00_01false_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>ParticleAttrib&lt; TinyVector&lt; T, 3 &gt; &gt;</type>
      <name>Array_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Tensor&lt; T, 3 &gt;</type>
      <name>Transformer_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const Array_t &amp;pin, const Transformer_t &amp;X, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e1</anchor>
      <arglist>(const Transformer_t &amp;X, const Array_t &amp;pin, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e2</anchor>
      <arglist>(Array_t &amp;pinout, const Transformer_t &amp;X, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e3</anchor>
      <arglist>(const Transformer_t &amp;X, Array_t &amp;pinout, int first, int last)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ConvertPosUnit&lt; ParticleAttrib&lt; TinyVector&lt; T, 3 &gt; &gt;, Tensor&lt; T, 3 &gt;, true &gt;</name>
    <filename>structConvertPosUnit_3_01ParticleAttrib_3_01TinyVector_3_01T_00_013_01_4_01_4_00_01Tensor_3_01T_00_013_01_4_00_01true_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>ParticleAttrib&lt; TinyVector&lt; T, 3 &gt; &gt;</type>
      <name>Array_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Tensor&lt; T, 3 &gt;</type>
      <name>Transformer_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const Array_t &amp;pin, const Transformer_t &amp;X, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e1</anchor>
      <arglist>(const Transformer_t &amp;X, const Array_t &amp;pin, Array_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e2</anchor>
      <arglist>(Array_t &amp;pinout, const Transformer_t &amp;X, int first, int last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e3</anchor>
      <arglist>(const Transformer_t &amp;X, Array_t &amp;pinout, int first, int last)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>Cosine3D</name>
    <filename>structCosine3D.html</filename>
    <templarg>T</templarg>
    <templarg>PT</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT</type>
      <name>pos_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Cosine3D</name>
      <anchor>a0</anchor>
      <arglist>(value_type kx=0, value_type ky=0, value_type kz=0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a1</anchor>
      <arglist>(value_type kx, value_type ky, value_type kz)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(const PT &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>PT</type>
      <name>gradient</name>
      <anchor>a3</anchor>
      <arglist>(const PT &amp;r, value_type &amp;v)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>laplacian</name>
      <anchor>a4</anchor>
      <arglist>(const PT &amp;r, value_type &amp;v, PT &amp;gr)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>laplacian</name>
      <anchor>a5</anchor>
      <arglist>(const PT &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>operator()</name>
      <anchor>a6</anchor>
      <arglist>(const PT &amp;r)</arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Kx</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Ky</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Kz</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Knorm2</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Val</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Lap</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>pos_type</type>
      <name>Grad</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>CreateLeaf&lt; Matrix&lt; T, C &gt; &gt;</name>
    <filename>structCreateLeaf_3_01Matrix_3_01T_00_01C_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>C</templarg>
    <member kind="typedef">
      <type>Reference&lt; Matrix&lt; T, C &gt; &gt;</type>
      <name>Leaf_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Leaf_t</type>
      <name>make</name>
      <anchor>e0</anchor>
      <arglist>(const Matrix&lt; T, C &gt; &amp;a)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>CreateLeaf&lt; ParticleAttrib&lt; T &gt; &gt;</name>
    <filename>structCreateLeaf_3_01ParticleAttrib_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>Reference&lt; ParticleAttrib&lt; T &gt; &gt;</type>
      <name>Leaf_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Leaf_t</type>
      <name>make</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleAttrib&lt; T &gt; &amp;a)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>CreateLeaf&lt; Vector&lt; T, C &gt; &gt;</name>
    <filename>structCreateLeaf_3_01Vector_3_01T_00_01C_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>C</templarg>
    <member kind="typedef">
      <type>Reference&lt; Vector&lt; T, C &gt; &gt;</type>
      <name>Leaf_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Leaf_t</type>
      <name>make</name>
      <anchor>e0</anchor>
      <arglist>(const Vector&lt; T, C &gt; &amp;a)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>CubicSpline</name>
    <filename>classCubicSpline.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>CubicSpline</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CubicSpline</name>
      <anchor>a1</anchor>
      <arglist>(const int n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a2</anchor>
      <arglist>(const int n)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a3</anchor>
      <arglist>(T x0)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a4</anchor>
      <arglist>(T x0, T &amp;yval)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a5</anchor>
      <arglist>(T x0, T &amp;yval, T &amp;yp)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a7</anchor>
      <arglist>(const int n, T *x, T *y, const T yp1, const T ypn)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Npt</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Yp1</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Ypn</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; T &gt;</type>
      <name>X</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; T &gt;</type>
      <name>Y</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; T &gt;</type>
      <name>Y2</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>std::deque</name>
    <filename>classstd_1_1deque.html</filename>
  </compound>
  <compound kind="class">
    <name>std::deque</name>
    <filename>classstd_1_1deque.html</filename>
  </compound>
  <compound kind="struct">
    <name>EwaldSum</name>
    <filename>structEwaldSum.html</filename>
    <templarg>PT</templarg>
    <base>EwaldSumTraits&lt; PT::Scalar_t, false, false &gt;</base>
    <member kind="typedef">
      <type>ParticleBase&lt; PT &gt;</type>
      <name>Particle_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle_t::ParticleLayout_t</type>
      <name>ParticleLayout_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle_t::Scalar_t</type>
      <name>Scalar_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle_t::SingleParticleIndex_t</type>
      <name>SingleParticleIndex_t</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle_t::SingleParticlePos_t</type>
      <name>SingleParticlePos_t</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle_t::Tensor_t</type>
      <name>Tensor_t</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle_t::ParticlePos_t</type>
      <name>ParticlePos_t</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle_t::ParticleScalar_t</type>
      <name>ParticleScalar_t</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PtclPairListBase&lt; double, 3 &gt;</type>
      <name>PtclPairList_t</name>
      <anchor>w8</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EwaldSum</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~EwaldSum</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a2</anchor>
      <arglist>(ParticleLayout_t &amp;lat, const ParticleScalar_t &amp;q)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>makecells</name>
      <anchor>a3</anchor>
      <arglist>(const ParticleLayout_t &amp;lattice)</arglist>
    </member>
    <member kind="function">
      <type>Scalar_t</type>
      <name>energyG</name>
      <anchor>a4</anchor>
      <arglist>(const ParticleLayout_t &amp;lattice, const ParticlePos_t &amp;r, const ParticleScalar_t &amp;q)</arglist>
    </member>
    <member kind="function">
      <type>Scalar_t</type>
      <name>energyR</name>
      <anchor>a5</anchor>
      <arglist>(const ParticleLayout_t &amp;lattice, const ParticlePos_t &amp;r, const ParticleScalar_t &amp;q)</arglist>
    </member>
    <member kind="function">
      <type>Scalar_t</type>
      <name>energyR</name>
      <anchor>a6</anchor>
      <arglist>(const PtclPairList_t &amp;nnlist, int first, int last, const ParticleScalar_t &amp;q)</arglist>
    </member>
    <member kind="function">
      <type>Scalar_t</type>
      <name>forcestress</name>
      <anchor>a7</anchor>
      <arglist>(const ParticleLayout_t &amp;lattice, const ParticlePos_t &amp;r, const ParticleScalar_t &amp;q, ParticlePos_t &amp;f, Tensor_t &amp;stress)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>print</name>
      <anchor>a8</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>Eps</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>Tr_over_Tg</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SingleParticleIndex_t</type>
      <name>maxG</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SingleParticleIndex_t</type>
      <name>maxR</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>Rmax</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>acclog</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>g2max</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>x2max</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>sqeps</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>gamrec</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>gamdir</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>s3</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>s4</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>Volume</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>E0</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>Cg</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Scalar_t</type>
      <name>Cr</name>
      <anchor>o16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; SingleParticleIndex_t &gt;</type>
      <name>RShell</name>
      <anchor>o17</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>EwaldSumTraits</name>
    <filename>structEwaldSumTraits.html</filename>
    <templarg>T</templarg>
    <templarg>EVUNIT</templarg>
    <templarg>AAUNIT</templarg>
  </compound>
  <compound kind="struct">
    <name>EwaldSumTraits&lt; T, false, false &gt;</name>
    <filename>structEwaldSumTraits_3_01T_00_01false_00_01false_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>EwaldSumTraits</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>ConvE</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>ConvF</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>EwaldSumTraits&lt; T, true, true &gt;</name>
    <filename>structEwaldSumTraits_3_01T_00_01true_00_01true_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>EwaldSumTraits</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>ConvE</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>ConvF</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>FunctorBase</name>
    <filename>structFunctorBase.html</filename>
    <templarg>T</templarg>
    <templarg>D</templarg>
  </compound>
  <compound kind="class">
    <name>GamesXmlParser</name>
    <filename>classGamesXmlParser.html</filename>
    <base>QMCGaussianParserBase</base>
    <base>OhmmsAsciiParser</base>
    <member kind="function">
      <type></type>
      <name>GamesXmlParser</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GamesXmlParser</name>
      <anchor>a1</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>parse</name>
      <anchor>a2</anchor>
      <arglist>(const std::string &amp;fname)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>getGeometry</name>
      <anchor>d0</anchor>
      <arglist>(vector&lt; xmlNodePtr &gt; &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>getGaussianCenters</name>
      <anchor>d1</anchor>
      <arglist>(vector&lt; xmlNodePtr &gt; &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>getEigVectors</name>
      <anchor>d2</anchor>
      <arglist>(vector&lt; xmlNodePtr &gt; &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>getControlParameters</name>
      <anchor>d3</anchor>
      <arglist>(xmlNodePtr)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>GaussianCombo</name>
    <filename>structGaussianCombo.html</filename>
    <templarg>T</templarg>
    <base>RadialOrbitalBase</base>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GaussianCombo</name>
      <anchor>a0</anchor>
      <arglist>(int l=0, bool normalized=false, const char *node_name=&quot;radfunc&quot;, const char *exp_name=&quot;exponent&quot;, const char *c_name=&quot;contraction&quot;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~GaussianCombo</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>f</name>
      <anchor>a4</anchor>
      <arglist>(value_type r) const </arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>df</name>
      <anchor>a5</anchor>
      <arglist>(value_type r) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a6</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>putBasisGroup</name>
      <anchor>a7</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>DFactorial</name>
      <anchor>a8</anchor>
      <arglist>(int num)</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>Normalized</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>L</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>NormL</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>NormPow</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>nodeName</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>expName</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>coeffName</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; xmlNodePtr &gt;</type>
      <name>InParam</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; BasicGaussian &gt;</type>
      <name>gset</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <class kind="struct">GaussianCombo::BasicGaussian</class>
  </compound>
  <compound kind="struct">
    <name>GaussianCombo::BasicGaussian</name>
    <filename>structGaussianCombo_1_1BasicGaussian.html</filename>
    <member kind="function">
      <type></type>
      <name>BasicGaussian</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasicGaussian</name>
      <anchor>a1</anchor>
      <arglist>(T sig, T c)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>(T sig, T c)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setgrid</name>
      <anchor>a3</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>f</name>
      <anchor>a4</anchor>
      <arglist>(T r2) const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>df</name>
      <anchor>a5</anchor>
      <arglist>(T r, T r2) const </arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Sigma</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Coeff</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>CoeffP</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>GaussianFCHKParser</name>
    <filename>classGaussianFCHKParser.html</filename>
    <base>QMCGaussianParserBase</base>
    <base>OhmmsAsciiParser</base>
    <member kind="function">
      <type></type>
      <name>GaussianFCHKParser</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GaussianFCHKParser</name>
      <anchor>a1</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>parse</name>
      <anchor>a2</anchor>
      <arglist>(const std::string &amp;fname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getGeometry</name>
      <anchor>a3</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getGaussianCenters</name>
      <anchor>a4</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>GenericSTO</name>
    <filename>structGenericSTO.html</filename>
    <templarg>T</templarg>
    <base>RadialOrbitalBase</base>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GenericSTO</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GenericSTO</name>
      <anchor>a1</anchor>
      <arglist>(int power, T z, T norm=1.0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GenericSTO</name>
      <anchor>a2</anchor>
      <arglist>(int n, int l, T z)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setgrid</name>
      <anchor>a4</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>f</name>
      <anchor>a5</anchor>
      <arglist>(T r) const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>df</name>
      <anchor>a6</anchor>
      <arglist>(T r) const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a7</anchor>
      <arglist>(T r, T rinv)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluateAll</name>
      <anchor>a8</anchor>
      <arglist>(T r, T rinv)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a9</anchor>
      <arglist>(T r, T rinv, T &amp;drnl, T &amp;d2rnl)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>ID</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>N</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Power</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Z</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Norm</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Y</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>dY</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2Y</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>GTO2Slater</name>
    <filename>structGTO2Slater.html</filename>
    <member kind="typedef">
      <type>GaussianCombo&lt; double &gt;</type>
      <name>GTOType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>LogGrid&lt; double &gt;</type>
      <name>GridType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GTO2Slater</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>parse</name>
      <anchor>a1</anchor>
      <arglist>(const char *fname)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>optimize</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>Normalized</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>GridType</type>
      <name>myGrid</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>xmlNodePtr</type>
      <name>gridPtr</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>map&lt; string, xmlNodePtr &gt;</type>
      <name>sPtr</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO</name>
    <filename>structHDFAttribIO.html</filename>
    <templarg>T</templarg>
    <base>HDFAttribIOBase</base>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a0</anchor>
      <arglist>(hid_t, const char *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a1</anchor>
      <arglist>(hid_t, const char *)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; hsize_t &gt;</name>
    <filename>structHDFAttribIO_3_01hsize__t_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(hsize_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>hsize_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; Matrix&lt; double &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01Matrix_3_01double_01_4_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>Matrix&lt; double &gt;</type>
      <name>ArrayType_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; Matrix&lt; TinyVector&lt; double, D &gt; &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01Matrix_3_01TinyVector_3_01double_00_01D_01_4_01_4_01_4.html</filename>
    <templarg>D</templarg>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>TinyVector&lt; double, D &gt;</type>
      <name>Component_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matrix&lt; Component_t &gt;</type>
      <name>ArrayType_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; ParticleAttrib&lt; double &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01ParticleAttrib_3_01double_01_4_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>ParticleAttrib&lt; double &gt;</type>
      <name>ArrayType_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; ParticleAttrib&lt; int &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01ParticleAttrib_3_01int_01_4_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>ParticleAttrib&lt; int &gt;</type>
      <name>ArrayType_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; ParticleAttrib&lt; TinyVector&lt; double, 3 &gt; &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01ParticleAttrib_3_01TinyVector_3_01double_00_013_01_4_01_4_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>TinyVector&lt; double, 3 &gt;</type>
      <name>SingleParticlePos_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleAttrib&lt; SingleParticlePos_t &gt;</type>
      <name>ArrayType_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HDFAttribIO</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a3</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; std::vector&lt; double &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01std_1_1vector_3_01double_01_4_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>std::vector&lt; double &gt;</type>
      <name>ArrayType_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a1</anchor>
      <arglist>(ArrayType_t &amp;a, std::vector&lt; int &gt; &amp;dim)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a3</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; hsize_t &gt;</type>
      <name>Dim</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; std::vector&lt; int &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01std_1_1vector_3_01int_01_4_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>std::vector&lt; int &gt;</type>
      <name>ArrayType_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; string &gt;</name>
    <filename>structHDFAttribIO_3_01string_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>string</type>
      <name>ArrayType_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>hid_t</type>
      <name>str80</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; TriCubicSplineT&lt; double &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01TriCubicSplineT_3_01double_01_4_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>TriCubicSplineT&lt; double &gt;</type>
      <name>Data_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(Data_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>Data_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; Vector&lt; double &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01Vector_3_01double_01_4_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>Vector&lt; double &gt;</type>
      <name>ArrayType_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; Vector&lt; int &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01Vector_3_01int_01_4_01_4.html</filename>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>Vector&lt; int &gt;</type>
      <name>ArrayType_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIO&lt; Vector&lt; TinyVector&lt; double, D &gt; &gt; &gt;</name>
    <filename>structHDFAttribIO_3_01Vector_3_01TinyVector_3_01double_00_01D_01_4_01_4_01_4.html</filename>
    <templarg>D</templarg>
    <base>HDFAttribIOBase</base>
    <member kind="typedef">
      <type>Vector&lt; TinyVector&lt; double, D &gt; &gt;</type>
      <name>ArrayType_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HDFAttribIO</name>
      <anchor>a0</anchor>
      <arglist>(ArrayType_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a1</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>read</name>
      <anchor>a2</anchor>
      <arglist>(hid_t grp, const char *name)</arglist>
    </member>
    <member kind="variable">
      <type>ArrayType_t &amp;</type>
      <name>ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>HDFAttribIOBase</name>
    <filename>structHDFAttribIOBase.html</filename>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>write</name>
      <anchor>a0</anchor>
      <arglist>(hid_t, const char *)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>read</name>
      <anchor>a1</anchor>
      <arglist>(hid_t, const char *)=0</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LeafFunctor&lt; Matrix&lt; T, C &gt;, EvalLeaf2 &gt;</name>
    <filename>structLeafFunctor_3_01Matrix_3_01T_00_01C_01_4_00_01EvalLeaf2_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>C</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Type_t</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const Matrix&lt; T, C &gt; &amp;mat, const EvalLeaf2 &amp;f)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LeafFunctor&lt; Matrix&lt; T, C &gt;, SizeLeaf2 &gt;</name>
    <filename>structLeafFunctor_3_01Matrix_3_01T_00_01C_01_4_00_01SizeLeaf2_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>C</templarg>
    <member kind="typedef">
      <type>bool</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static bool</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const Matrix&lt; T, C &gt; &amp;v, const SizeLeaf2 &amp;s)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LeafFunctor&lt; ParticleAttrib&lt; T &gt;, EvalLeaf1 &gt;</name>
    <filename>structLeafFunctor_3_01ParticleAttrib_3_01T_01_4_00_01EvalLeaf1_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Type_t</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleAttrib&lt; T &gt; &amp;vec, const EvalLeaf1 &amp;f)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LeafFunctor&lt; ParticleAttrib&lt; T &gt;, SizeLeafPA &gt;</name>
    <filename>structLeafFunctor_3_01ParticleAttrib_3_01T_01_4_00_01SizeLeafPA_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>bool</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static bool</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleAttrib&lt; T &gt; &amp;v, const SizeLeafPA &amp;s)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LeafFunctor&lt; Scalar&lt; T &gt;, SizeLeaf &gt;</name>
    <filename>structLeafFunctor_3_01Scalar_3_01T_01_4_00_01SizeLeaf_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>bool</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static bool</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const Scalar&lt; T &gt; &amp;, const SizeLeaf &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LeafFunctor&lt; Scalar&lt; T &gt;, SizeLeaf2 &gt;</name>
    <filename>structLeafFunctor_3_01Scalar_3_01T_01_4_00_01SizeLeaf2_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>bool</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static bool</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const Scalar&lt; T &gt; &amp;, const SizeLeaf2 &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LeafFunctor&lt; Scalar&lt; T &gt;, SizeLeafPA &gt;</name>
    <filename>structLeafFunctor_3_01Scalar_3_01T_01_4_00_01SizeLeafPA_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>bool</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static bool</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const Scalar&lt; T &gt; &amp;, const SizeLeafPA &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LeafFunctor&lt; Vector&lt; T, C &gt;, EvalLeaf1 &gt;</name>
    <filename>structLeafFunctor_3_01Vector_3_01T_00_01C_01_4_00_01EvalLeaf1_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>C</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Type_t</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const Vector&lt; T, C &gt; &amp;vec, const EvalLeaf1 &amp;f)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LeafFunctor&lt; Vector&lt; T, C &gt;, SizeLeaf &gt;</name>
    <filename>structLeafFunctor_3_01Vector_3_01T_00_01C_01_4_00_01SizeLeaf_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>C</templarg>
    <member kind="typedef">
      <type>bool</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static bool</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const Vector&lt; T, C &gt; &amp;v, const SizeLeaf &amp;s)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LinearGrid</name>
    <filename>structLinearGrid.html</filename>
    <templarg>T</templarg>
    <templarg>CT</templarg>
    <base>OneDimGridBase</base>
    <member kind="function">
      <type>void</type>
      <name>locate</name>
      <anchor>a0</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a1</anchor>
      <arglist>(T ri, T rf, int n)</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>DeltaInv</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LogGrid</name>
    <filename>structLogGrid.html</filename>
    <templarg>T</templarg>
    <templarg>CT</templarg>
    <base>OneDimGridBase</base>
    <member kind="function">
      <type>void</type>
      <name>locate</name>
      <anchor>a0</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a1</anchor>
      <arglist>(T ri, T rf, int n)</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>OneOverLogDelta</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>LogGridZero</name>
    <filename>structLogGridZero.html</filename>
    <templarg>T</templarg>
    <templarg>CT</templarg>
    <base>OneDimGridBase</base>
    <member kind="function">
      <type>void</type>
      <name>locate</name>
      <anchor>a0</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a1</anchor>
      <arglist>(T ri, T rf, int n)</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>OneOverA</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>OneOverB</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>std::map</name>
    <filename>classstd_1_1map.html</filename>
  </compound>
  <compound kind="class">
    <name>std::map</name>
    <filename>classstd_1_1map.html</filename>
  </compound>
  <compound kind="class">
    <name>MatGrid1D</name>
    <filename>classMatGrid1D.html</filename>
    <member kind="function">
      <type></type>
      <name>MatGrid1D</name>
      <anchor>a0</anchor>
      <arglist>(int nsections)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a1</anchor>
      <arglist>(const Grid1D &amp;aGrid1D, const std::vector&lt; int &gt; &amp;ix, const std::vector&lt; int &gt; &amp;prior, const std::vector&lt; double &gt; &amp;props)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>prop</name>
      <anchor>a2</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nsecs_m</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>ix0_m</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>iaxis</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; int &gt;</type>
      <name>d_ivals</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; int &gt;</type>
      <name>prior_m</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; double &gt;</type>
      <name>prop_m</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; double &gt;</type>
      <name>dx_ivals</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>Matrix</name>
    <filename>classMatrix.html</filename>
    <templarg>T</templarg>
    <templarg>C</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>C</type>
      <name>Container_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>C::size_type</type>
      <name>size_type</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matrix&lt; T, C &gt;</type>
      <name>This_t</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Matrix</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Matrix</name>
      <anchor>a1</anchor>
      <arglist>(size_type n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Matrix</name>
      <anchor>a2</anchor>
      <arglist>(size_type n, size_type m)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Matrix</name>
      <anchor>a3</anchor>
      <arglist>(const Matrix&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Matrix</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>size</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>rows</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>cols</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>size1</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>size2</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>size</name>
      <anchor>a10</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>extent</name>
      <anchor>a11</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>Container_t::iterator</type>
      <name>begin</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Container_t::iterator</type>
      <name>end</name>
      <anchor>a13</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Container_t::const_iterator</type>
      <name>begin</name>
      <anchor>a14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Container_t::const_iterator</type>
      <name>end</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Container_t::iterator</type>
      <name>begin</name>
      <anchor>a16</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>Container_t::const_iterator</type>
      <name>begin</name>
      <anchor>a17</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a18</anchor>
      <arglist>(size_type n, size_type m)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a19</anchor>
      <arglist>(size_type n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copy</name>
      <anchor>a20</anchor>
      <arglist>(const Matrix&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>This_t &amp;</type>
      <name>operator=</name>
      <anchor>a21</anchor>
      <arglist>(const Matrix&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>const This_t &amp;</type>
      <name>operator=</name>
      <anchor>a22</anchor>
      <arglist>(const Matrix&lt; T, C &gt; &amp;rhs) const </arglist>
    </member>
    <member kind="function">
      <type>This_t &amp;</type>
      <name>operator=</name>
      <anchor>a23</anchor>
      <arglist>(const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Type_t *</type>
      <name>data</name>
      <anchor>a24</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const Type_t *</type>
      <name>data</name>
      <anchor>a25</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const Type_t *</type>
      <name>operator[]</name>
      <anchor>a26</anchor>
      <arglist>(size_type i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t *</type>
      <name>operator[]</name>
      <anchor>a27</anchor>
      <arglist>(size_type i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a28</anchor>
      <arglist>(size_type i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a29</anchor>
      <arglist>(size_type i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a30</anchor>
      <arglist>(size_type i, size_type j)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a31</anchor>
      <arglist>(size_type i, size_type j) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a32</anchor>
      <arglist>(const T1 *sub, size_type d1, size_type d2, size_type i0, size_type j0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a33</anchor>
      <arglist>(const T1 *sub, size_type d1, size_type d2, size_type i0, size_type j0, const T &amp;phi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a34</anchor>
      <arglist>(const SubMat_t &amp;sub, unsigned int i0, unsigned int j0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a35</anchor>
      <arglist>(const This_t &amp;sub, unsigned int i0, unsigned int j0)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>size_type</type>
      <name>D1</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>size_type</type>
      <name>D2</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Container_t</type>
      <name>X</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>MinimizeFunction</name>
    <filename>classMinimizeFunction.html</filename>
  </compound>
  <compound kind="struct">
    <name>NDimGrid</name>
    <filename>structNDimGrid.html</filename>
    <templarg>T</templarg>
    <templarg>D</templarg>
    <templarg>CT</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OneDimGridBase&lt; T, CT &gt;</type>
      <name>OneDimGridType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>index</name>
      <anchor>a0</anchor>
      <arglist>(const PV &amp;pos)</arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; OneDimGridType * &gt;</type>
      <name>Component</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Index</name>
      <anchor>o1</anchor>
      <arglist>[D]</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>NoBConds</name>
    <filename>structNoBConds.html</filename>
    <templarg>T</templarg>
    <templarg>D</templarg>
    <member kind="function" static="yes">
      <type>static T</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const CrystalLattice&lt; T, D &gt; &amp;lat, const TinyVector&lt; T, D &gt; &amp;a)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>NoCuspJastrow</name>
    <filename>structNoCuspJastrow.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>NoCuspJastrow</name>
      <anchor>a0</anchor>
      <arglist>(T a=1.0, T b=1.0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>(T a, T b)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(T r, T &amp;dudr, T &amp;d2udr2)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>put</name>
      <anchor>a5</anchor>
      <arglist>(xmlNodePtr cur, VarRegistry&lt; T1 &gt; &amp;vlist)</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>A</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>B</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>AB2</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>NormRandomSeq</name>
    <filename>structNormRandomSeq.html</filename>
    <templarg>VT</templarg>
    <templarg>RNG</templarg>
  </compound>
  <compound kind="struct">
    <name>NormRandomSeq&lt; TinyVector&lt; double, 3 &gt;, RNG &gt;</name>
    <filename>structNormRandomSeq_3_01TinyVector_3_01double_00_013_01_4_00_01RNG_01_4.html</filename>
    <templarg>RNG</templarg>
    <member kind="typedef">
      <type>TinyVector&lt; double, 3 &gt;</type>
      <name>Return_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Return_t</type>
      <name>get</name>
      <anchor>e0</anchor>
      <arglist>(RNG &amp;rng)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>NormRandomSeq&lt; TinyVector&lt; T, D &gt;, RNG &gt;</name>
    <filename>structNormRandomSeq_3_01TinyVector_3_01T_00_01D_01_4_00_01RNG_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>D</templarg>
    <templarg>RNG</templarg>
    <member kind="typedef">
      <type>TinyVector&lt; double, D &gt;</type>
      <name>Return_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Return_t</type>
      <name>get</name>
      <anchor>e0</anchor>
      <arglist>(RNG &amp;rng)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>NumericalGrid</name>
    <filename>structNumericalGrid.html</filename>
    <templarg>T</templarg>
    <templarg>CT</templarg>
    <base>OneDimGridBase</base>
    <member kind="function">
      <type></type>
      <name>NumericalGrid</name>
      <anchor>a0</anchor>
      <arglist>(const VA &amp;nv)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>locate</name>
      <anchor>a1</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a2</anchor>
      <arglist>(T ri, T rf, int n)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>OhmmsAsciiParser</name>
    <filename>structOhmmsAsciiParser.html</filename>
    <member kind="function">
      <type>void</type>
      <name>skiplines</name>
      <anchor>a0</anchor>
      <arglist>(std::istream &amp;is, int n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getValue</name>
      <anchor>a1</anchor>
      <arglist>(std::istream &amp;is, T &amp;aval)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getValues</name>
      <anchor>a2</anchor>
      <arglist>(std::istream &amp;is, IT first, IT last)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>search</name>
      <anchor>a3</anchor>
      <arglist>(std::istream &amp;is, const std::string &amp;keyword)</arglist>
    </member>
    <member kind="variable">
      <type>char</type>
      <name>dbuffer</name>
      <anchor>o0</anchor>
      <arglist>[bufferSize]</arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; string &gt;</type>
      <name>currentWords</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const int</type>
      <name>bufferSize</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>OhmmsAttributeSet</name>
    <filename>structOhmmsAttributeSet.html</filename>
    <base>std::map</base>
    <member kind="function">
      <type></type>
      <name>OhmmsAttributeSet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~OhmmsAttributeSet</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a2</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a3</anchor>
      <arglist>(PDT &amp;aparam, const string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>xmlNodePtr</type>
      <name>myNode</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OhmmsElementBase</name>
    <filename>classOhmmsElementBase.html</filename>
    <member kind="enumvalue">
      <name>useLIBXML</name>
      <anchor>w3w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>useLIBXMLPP</name>
      <anchor>w3w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>usePLAIN</name>
      <anchor>w3w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OhmmsElementBase</name>
      <anchor>a0</anchor>
      <arglist>(const char *aname=&quot;none&quot;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~OhmmsElementBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const std::string &amp;</type>
      <name>getName</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setName</name>
      <anchor>a3</anchor>
      <arglist>(const std::string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setIOMode</name>
      <anchor>a4</anchor>
      <arglist>(int imode)</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>get</name>
      <anchor>a5</anchor>
      <arglist>(std::ostream &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>put</name>
      <anchor>a6</anchor>
      <arglist>(std::istream &amp;)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>put</name>
      <anchor>a7</anchor>
      <arglist>(xmlNodePtr cur)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>reset</name>
      <anchor>a8</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>add</name>
      <anchor>a9</anchor>
      <arglist>(xmlNodePtr parent)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>put</name>
      <anchor>a10</anchor>
      <arglist>(const std::string &amp;s)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>begin_node</name>
      <anchor>a11</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>end_node</name>
      <anchor>a12</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>OhmmsElementBase</name>
      <anchor>b0</anchor>
      <arglist>(const OhmmsElementBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>myIOMode</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>std::string</type>
      <name>myName</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OhmmsInfo</name>
    <filename>classOhmmsInfo.html</filename>
    <member kind="function">
      <type></type>
      <name>OhmmsInfo</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv, int master=-1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~OhmmsInfo</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OhmmsInfo</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>initialize</name>
      <anchor>e0</anchor>
      <arglist>(const char *froot, int master)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>die</name>
      <anchor>e1</anchor>
      <arglist>(const char *)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static OhmmsInform *</type>
      <name>Debug</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static OhmmsInform *</type>
      <name>Warn</name>
      <anchor>s1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static OhmmsInform *</type>
      <name>Error</name>
      <anchor>s2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static OhmmsInform *</type>
      <name>Log</name>
      <anchor>s3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OhmmsInform</name>
    <filename>classOhmmsInform.html</filename>
    <member kind="enumvalue">
      <name>OVERWRITE</name>
      <anchor>w2w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>APPEND</name>
      <anchor>w2w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OhmmsInform</name>
      <anchor>a0</anchor>
      <arglist>(bool allcanwrite=true, bool writenode=true)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OhmmsInform</name>
      <anchor>a1</anchor>
      <arglist>(const char *prompt, bool allcanwrite=true, bool writenode=true)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OhmmsInform</name>
      <anchor>a2</anchor>
      <arglist>(const char *prompt, const char *fname, int appmode=OVERWRITE)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OhmmsInform</name>
      <anchor>a3</anchor>
      <arglist>(const char *prompt, std::ostream &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~OhmmsInform</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a5</anchor>
      <arglist>(const char *fname, int appmode=OVERWRITE)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a6</anchor>
      <arglist>(OhmmsInform &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>flush</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>getStream</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>open</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::string</type>
      <name>thisPrompt</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::ostream *</type>
      <name>thisStream</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>OwnStream</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>CanWrite</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OhmmsIOBase</name>
    <filename>classOhmmsIOBase.html</filename>
    <member kind="function">
      <type></type>
      <name>OhmmsIOBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>open</name>
      <anchor>a1</anchor>
      <arglist>(const char *, ios_base::openmode iomode)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>close</name>
      <anchor>a2</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>flush</name>
      <anchor>a3</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>read</name>
      <anchor>a4</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>write</name>
      <anchor>a5</anchor>
      <arglist>(int iter)=0</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ios_base::openmode</type>
      <name>Mode</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>stride</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>OhmmsIOBase</name>
      <anchor>d0</anchor>
      <arglist>(OhmmsIOBase &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OhmmsObject</name>
    <filename>classOhmmsObject.html</filename>
    <base>OhmmsElementBase</base>
    <member kind="function">
      <type></type>
      <name>OhmmsObject</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OhmmsObject</name>
      <anchor>a1</anchor>
      <arglist>(const std::string &amp;tname, const std::string &amp;oname)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~OhmmsObject</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>id</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setID</name>
      <anchor>a4</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>elementByteSize</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTypeName</name>
      <anchor>a6</anchor>
      <arglist>(const std::string &amp;tname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setObjName</name>
      <anchor>a7</anchor>
      <arglist>(const std::string &amp;oname)</arglist>
    </member>
    <member kind="function">
      <type>const std::string &amp;</type>
      <name>typeName</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const std::string &amp;</type>
      <name>objName</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>std::string</type>
      <name>TypeName</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>ObjectID</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>ElementByteSize</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>static int</type>
      <name>ObjectCounter</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OhmmsParameter</name>
    <filename>classOhmmsParameter.html</filename>
    <templarg>T</templarg>
    <base>OhmmsElementBase</base>
    <member kind="function">
      <type></type>
      <name>OhmmsParameter</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;a, const char *aname, const char *uname=&quot;none&quot;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a1</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>add</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr parent)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T &amp;</type>
      <name>ref_</name>
      <anchor>z7_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>unit_</name>
      <anchor>z7_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>xmlNodePtr</type>
      <name>node_</name>
      <anchor>z7_2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OhmmsParameter&lt; bool &gt;</name>
    <filename>classOhmmsParameter_3_01bool_01_4.html</filename>
    <base>OhmmsElementBase</base>
    <member kind="function">
      <type></type>
      <name>OhmmsParameter</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;a, const char *aname, const char *uname=&quot;none&quot;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a1</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>add</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr parent)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool &amp;</type>
      <name>ref_</name>
      <anchor>z8_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>unit_</name>
      <anchor>z8_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>xmlNodePtr</type>
      <name>node_</name>
      <anchor>z8_2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OneDimConstFunctor</name>
    <filename>classOneDimConstFunctor.html</filename>
    <templarg>Td</templarg>
    <templarg>Tg</templarg>
    <templarg>CTd</templarg>
    <templarg>CTg</templarg>
    <base>OneDimGridFunctor</base>
    <member kind="typedef">
      <type>OneDimGridFunctor&lt; Td, Tg, CTd, CTg &gt;</type>
      <name>base_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::value_type</type>
      <name>value_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::point_type</type>
      <name>point_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::data_type</type>
      <name>data_type</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::grid_type</type>
      <name>grid_type</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OneDimConstFunctor</name>
      <anchor>a0</anchor>
      <arglist>(grid_type *gt=0)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>splint</name>
      <anchor>a1</anchor>
      <arglist>(point_type r)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>splint</name>
      <anchor>a2</anchor>
      <arglist>(point_type r, value_type &amp;du, value_type &amp;d2u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a3</anchor>
      <arglist>(int imin, value_type yp1, int imax, value_type ypn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>Td</type>
      <name>ConstValue</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OneDimCubicSpline</name>
    <filename>classOneDimCubicSpline.html</filename>
    <templarg>Td</templarg>
    <templarg>Tg</templarg>
    <templarg>CTd</templarg>
    <templarg>CTg</templarg>
    <base>OneDimGridFunctor</base>
    <member kind="typedef">
      <type>OneDimGridFunctor&lt; Td, Tg, CTd, CTg &gt;</type>
      <name>base_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::value_type</type>
      <name>value_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::point_type</type>
      <name>point_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::data_type</type>
      <name>data_type</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::grid_type</type>
      <name>grid_type</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OneDimCubicSpline</name>
      <anchor>a0</anchor>
      <arglist>(grid_type *gt=NULL)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OneDimCubicSpline</name>
      <anchor>a1</anchor>
      <arglist>(grid_type *gt, const VV &amp;nv)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>splint</name>
      <anchor>a2</anchor>
      <arglist>(point_type r)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>splint</name>
      <anchor>a3</anchor>
      <arglist>(point_type r, value_type &amp;du, value_type &amp;d2u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a4</anchor>
      <arglist>(int imin, value_type yp1, int imax, value_type ypn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>data_type</type>
      <name>m_Y2</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>point_type</type>
      <name>r_min</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>point_type</type>
      <name>r_max</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>first_deriv</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>last_deriv</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OneDimCubicSplineFirst</name>
    <filename>classOneDimCubicSplineFirst.html</filename>
    <templarg>Td</templarg>
    <templarg>Tg</templarg>
    <templarg>CTd</templarg>
    <templarg>CTg</templarg>
    <base>OneDimGridFunctor</base>
    <member kind="typedef">
      <type>OneDimGridFunctor&lt; Td, Tg, CTd, CTg &gt;</type>
      <name>base_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::value_type</type>
      <name>value_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::point_type</type>
      <name>point_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::data_type</type>
      <name>data_type</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::grid_type</type>
      <name>grid_type</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OneDimCubicSplineFirst</name>
      <anchor>a0</anchor>
      <arglist>(grid_type *gt=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OneDimCubicSplineFirst</name>
      <anchor>a1</anchor>
      <arglist>(grid_type *gt, const VV &amp;nv, bool pbc=true)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>splint</name>
      <anchor>a2</anchor>
      <arglist>(point_type r)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>splint</name>
      <anchor>a3</anchor>
      <arglist>(point_type r, value_type &amp;du, value_type &amp;d2u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a4</anchor>
      <arglist>(int imin, value_type yp1, int imax, value_type ypn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>data_type</type>
      <name>m_Y1</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>First</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Last</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>point_type</type>
      <name>r_min</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>point_type</type>
      <name>r_max</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OneDimCubicSplinePBC</name>
    <filename>classOneDimCubicSplinePBC.html</filename>
    <templarg>Td</templarg>
    <templarg>Tg</templarg>
    <templarg>CTd</templarg>
    <templarg>CTg</templarg>
    <base>OneDimGridFunctor</base>
    <member kind="typedef">
      <type>OneDimGridFunctor&lt; Td, Tg, CTd, CTg &gt;</type>
      <name>base_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::value_type</type>
      <name>value_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::point_type</type>
      <name>point_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::data_type</type>
      <name>data_type</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>base_type::grid_type</type>
      <name>grid_type</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OneDimCubicSplinePBC</name>
      <anchor>a0</anchor>
      <arglist>(grid_type *gt=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OneDimCubicSplinePBC</name>
      <anchor>a1</anchor>
      <arglist>(grid_type *gt, const VV &amp;nv)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>splint</name>
      <anchor>a2</anchor>
      <arglist>(point_type r)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>splint</name>
      <anchor>a3</anchor>
      <arglist>(point_type r, value_type &amp;du, value_type &amp;d2u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a4</anchor>
      <arglist>(int imin, value_type yp1, int imax, value_type ypn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>data_type</type>
      <name>m_Y1</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>First</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Last</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Difference</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Length</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>OneDimGridBase</name>
    <filename>structOneDimGridBase.html</filename>
    <templarg>T</templarg>
    <templarg>CT</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CT</type>
      <name>Array_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>currentIndex</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator[]</name>
      <anchor>a1</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator[]</name>
      <anchor>a3</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a4</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>const T *</type>
      <name>data</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T *</type>
      <name>data</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>dh</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>r</name>
      <anchor>a8</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>dr</name>
      <anchor>a9</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>rmin</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>rmax</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>updateFirstOrder</name>
      <anchor>a13</anchor>
      <arglist>(T r, bool all)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>cubicInterpolateFirst</name>
      <anchor>a14</anchor>
      <arglist>(T a, T b, T a1, T b1)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>cubicInterpolateFirst</name>
      <anchor>a15</anchor>
      <arglist>(T a, T b, T a1, T b1, T &amp;du, T &amp;d2u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>updateSecondOrder</name>
      <anchor>a16</anchor>
      <arglist>(T r, bool all)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>cubicInterpolateSecond</name>
      <anchor>a17</anchor>
      <arglist>(T y1, T y2, T d2y1, T d2y2)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>cubicInterpolateSecond</name>
      <anchor>a18</anchor>
      <arglist>(T y1, T y2, T d2y1, T d2y2, T &amp;du, T &amp;d2u)</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>locate</name>
      <anchor>a19</anchor>
      <arglist>(T r)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a20</anchor>
      <arglist>(T ri, T rf, int n)=0</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Loc</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Delta</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>dL</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>dLinv</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>cL</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>cR</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>p1</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>p2</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>q1</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>q2</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>dp1</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>dq1</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>dq2</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>d2p1</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>d2q1</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>d2q2</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Array_t</type>
      <name>X</name>
      <anchor>o16</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>OneDimGridFunctor</name>
    <filename>structOneDimGridFunctor.html</filename>
    <templarg>Td</templarg>
    <templarg>Tg</templarg>
    <templarg>CTd</templarg>
    <templarg>CTg</templarg>
    <member kind="typedef">
      <type>Td</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Tg</type>
      <name>point_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CTd</type>
      <name>data_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OneDimGridBase&lt; Tg, CTg &gt;</type>
      <name>grid_type</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OneDimGridFunctor&lt; Td, Tg, CTd, CTg &gt;</type>
      <name>this_type</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OneDimGridFunctor</name>
      <anchor>a0</anchor>
      <arglist>(grid_type *gt=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~OneDimGridFunctor</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OneDimGridFunctor</name>
      <anchor>a2</anchor>
      <arglist>(const this_type &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>const this_type &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const this_type &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>const this_type &amp;</type>
      <name>operator=</name>
      <anchor>a4</anchor>
      <arglist>(const T1 &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setNumOfNodes</name>
      <anchor>a5</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getNumOfNodes</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>value_type *</type>
      <name>data</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const value_type *</type>
      <name>data</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a10</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>const grid_type &amp;</type>
      <name>grid</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>grid_type &amp;</type>
      <name>grid</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGridManager</name>
      <anchor>a13</anchor>
      <arglist>(bool willmanage)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>operator()</name>
      <anchor>a14</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>value_type &amp;</type>
      <name>operator()</name>
      <anchor>a15</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>value_type *</type>
      <name>data</name>
      <anchor>a16</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>point_type</type>
      <name>dh</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>point_type</type>
      <name>r</name>
      <anchor>a18</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>point_type</type>
      <name>dr</name>
      <anchor>a19</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>f</name>
      <anchor>a20</anchor>
      <arglist>(point_type r)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>df</name>
      <anchor>a21</anchor>
      <arglist>(point_type r)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>evaluate</name>
      <anchor>a22</anchor>
      <arglist>(point_type r, point_type rinv)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>evaluateAll</name>
      <anchor>a23</anchor>
      <arglist>(point_type r, point_type rinv)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>reset</name>
      <anchor>a24</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual value_type</type>
      <name>splint</name>
      <anchor>a25</anchor>
      <arglist>(point_type r, value_type &amp;du, value_type &amp;d2u)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual value_type</type>
      <name>splint</name>
      <anchor>a26</anchor>
      <arglist>(point_type r)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>spline</name>
      <anchor>a27</anchor>
      <arglist>(int imin, value_type yp1, int imax, value_type ypn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>spline</name>
      <anchor>a28</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>evaluate</name>
      <anchor>a29</anchor>
      <arglist>(point_type r, point_type rinv, value_type &amp;du, value_type &amp;d2u)</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>GridManager</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>grid_type *</type>
      <name>m_grid</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Y</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>dY</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>d2Y</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>data_type</type>
      <name>m_Y</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumNodes</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; value_type * &gt;</type>
      <name>FirstAddress</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>PadeJastrow</name>
    <filename>structPadeJastrow.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>PadeJastrow</name>
      <anchor>a0</anchor>
      <arglist>(T a=1.0, T b=1.0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>(T a, T b)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(T r, T &amp;dudr, T &amp;d2udr2)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>put</name>
      <anchor>a5</anchor>
      <arglist>(xmlNodePtr cur, VarRegistry&lt; T1 &gt; &amp;vlist)</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>A</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>B</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>AB</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>B2</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>PadeJastrow2</name>
    <filename>structPadeJastrow2.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>PadeJastrow2</name>
      <anchor>a0</anchor>
      <arglist>(T a=1.0, T b=1.0, T c=1.0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>(T a, T b, T c)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(T r, T &amp;dudr, T &amp;d2udr2)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>put</name>
      <anchor>a5</anchor>
      <arglist>(xmlNodePtr cur, VarRegistry&lt; T1 &gt; &amp;vlist)</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>A</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>B</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>C</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>C2</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ParameterSet</name>
    <filename>structParameterSet.html</filename>
    <base>OhmmsElementBase</base>
    <base>std::map</base>
    <member kind="function">
      <type></type>
      <name>ParameterSet</name>
      <anchor>a0</anchor>
      <arglist>(const char *aname=&quot;parameter&quot;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ParameterSet</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a2</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a6</anchor>
      <arglist>(PDT &amp;aparam, const char *aname, const char *uname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValue</name>
      <anchor>a7</anchor>
      <arglist>(const string &amp;aname, PDT aval)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ParticleAttrib</name>
    <filename>classParticleAttrib.html</filename>
    <templarg>T</templarg>
    <base>OhmmsObject</base>
    <member kind="typedef">
      <type>T</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; T &gt;</type>
      <name>Container_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Container_t::iterator</type>
      <name>iterator</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Container_t::const_iterator</type>
      <name>const_iterator</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleAttrib&lt; T &gt;</type>
      <name>This_t</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleAttrib</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleAttrib</name>
      <anchor>ga0</anchor>
      <arglist>(const std::string &amp;tname, const std::string &amp;oname)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleAttrib</name>
      <anchor>ga1</anchor>
      <arglist>(const std::string &amp;tname, const std::string &amp;oname, int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleAttrib</name>
      <anchor>ga2</anchor>
      <arglist>(unsigned n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleAttrib</name>
      <anchor>ga3</anchor>
      <arglist>(const ParticleAttrib&lt; T &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ParticleAttrib</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>size</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a7</anchor>
      <arglist>(unsigned n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>create</name>
      <anchor>a8</anchor>
      <arglist>(unsigned n)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getNumGhosts</name>
      <anchor>ga4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>ga5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clearGhosts</name>
      <anchor>ga6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addGhosts</name>
      <anchor>ga7</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>This_t &amp;</type>
      <name>operator=</name>
      <anchor>a13</anchor>
      <arglist>(const ParticleAttrib&lt; T &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>const This_t &amp;</type>
      <name>operator=</name>
      <anchor>a14</anchor>
      <arglist>(const ParticleAttrib&lt; T &gt; &amp;rhs) const </arglist>
    </member>
    <member kind="function">
      <type>This_t &amp;</type>
      <name>operator=</name>
      <anchor>a15</anchor>
      <arglist>(const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator[]</name>
      <anchor>a16</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator[]</name>
      <anchor>a17</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a18</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a19</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a20</anchor>
      <arglist>(std::ostream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a21</anchor>
      <arglist>(std::istream &amp;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a22</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a23</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>begin_node</name>
      <anchor>a24</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>end_node</name>
      <anchor>a25</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUnit</name>
      <anchor>z2_0</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getUnit</name>
      <anchor>z2_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>begin</name>
      <anchor>z3_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>end</name>
      <anchor>z3_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>iterator</type>
      <name>begin</name>
      <anchor>z3_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>iterator</type>
      <name>end</name>
      <anchor>z3_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>InUnit</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nLocal</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nGhosts</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Container_t</type>
      <name>X</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ParticleBase</name>
    <filename>classParticleBase.html</filename>
    <templarg>PT</templarg>
    <base>ParticleTags</base>
    <member kind="typedef">
      <type>PT::ParticleLayout_t</type>
      <name>ParticleLayout_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT::Index_t</type>
      <name>Index_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT::Scalar_t</type>
      <name>Scalar_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT::SingleParticleIndex_t</type>
      <name>SingleParticleIndex_t</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT::SingleParticlePos_t</type>
      <name>SingleParticlePos_t</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT::Tensor_t</type>
      <name>Tensor_t</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, OhmmsObject * &gt;::iterator</type>
      <name>PAListIterator</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT::ParticleIndex_t</type>
      <name>ParticleIndex_t</name>
      <anchor>z4_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT::ParticleScalar_t</type>
      <name>ParticleScalar_t</name>
      <anchor>z4_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT::ParticlePos_t</type>
      <name>ParticlePos_t</name>
      <anchor>z4_2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT::ParticleTensor_t</type>
      <name>ParticleTensor_t</name>
      <anchor>z4_3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleBase</name>
      <anchor>a1</anchor>
      <arglist>(const ParticleBase&lt; PT &gt; &amp;P)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParticleBase</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getAttribType</name>
      <anchor>a3</anchor>
      <arglist>(const string &amp;tname)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getNumAttrib</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PAListIterator</type>
      <name>first_attrib</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PAListIterator</type>
      <name>last_attrib</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasAttrib</name>
      <anchor>a7</anchor>
      <arglist>(const std::string &amp;attrib_name)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>addAttribute</name>
      <anchor>a8</anchor>
      <arglist>(const std::string &amp;tname, const std::string &amp;oname)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>addAttribute</name>
      <anchor>a9</anchor>
      <arglist>(ParticleIndex_t &amp;pa)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>addAttribute</name>
      <anchor>a10</anchor>
      <arglist>(ParticleScalar_t &amp;pa)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>addAttribute</name>
      <anchor>a11</anchor>
      <arglist>(ParticlePos_t &amp;pa)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>addAttribute</name>
      <anchor>a12</anchor>
      <arglist>(ParticleTensor_t &amp;pa)</arglist>
    </member>
    <member kind="function">
      <type>const ParticleIndex_t *</type>
      <name>getIndexAttrib</name>
      <anchor>a13</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleScalar_t *</type>
      <name>getScalarAttrib</name>
      <anchor>a14</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>const ParticlePos_t *</type>
      <name>getVectorAttrib</name>
      <anchor>a15</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleTensor_t *</type>
      <name>getTensorAttrib</name>
      <anchor>a16</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>ParticleIndex_t *</type>
      <name>getIndexAttrib</name>
      <anchor>a17</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>ParticleScalar_t *</type>
      <name>getScalarAttrib</name>
      <anchor>a18</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>ParticlePos_t *</type>
      <name>getVectorAttrib</name>
      <anchor>a19</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>ParticleTensor_t *</type>
      <name>getTensorAttrib</name>
      <anchor>a20</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>create</name>
      <anchor>a21</anchor>
      <arglist>(unsigned m)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>create</name>
      <anchor>a22</anchor>
      <arglist>(const vector&lt; int &gt; &amp;agroup)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a23</anchor>
      <arglist>(unsigned m)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a24</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>assign</name>
      <anchor>a25</anchor>
      <arglist>(const ParticleBase&lt; PT &gt; &amp;ptclin)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getLocalNum</name>
      <anchor>a26</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getTotalNum</name>
      <anchor>a27</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>groups</name>
      <anchor>a28</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>first</name>
      <anchor>a29</anchor>
      <arglist>(int igroup) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>last</name>
      <anchor>a30</anchor>
      <arglist>(int igroup) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>current</name>
      <anchor>a31</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>advance</name>
      <anchor>a32</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setCounter</name>
      <anchor>a33</anchor>
      <arglist>(int i=0)</arglist>
    </member>
    <member kind="function">
      <type>ParticleIndex_t *</type>
      <name>getIndexAttrib</name>
      <anchor>z0_0</anchor>
      <arglist>(const std::string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>ParticleScalar_t *</type>
      <name>getScalarAttrib</name>
      <anchor>z0_1</anchor>
      <arglist>(const std::string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>ParticlePos_t *</type>
      <name>getVectorAttrib</name>
      <anchor>z0_2</anchor>
      <arglist>(const std::string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>ParticleTensor_t *</type>
      <name>getTensorAttrib</name>
      <anchor>z0_3</anchor>
      <arglist>(const std::string &amp;aname)</arglist>
    </member>
    <member kind="variable">
      <type>ParticleLayout_t</type>
      <name>Lattice</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleIndex_t</type>
      <name>ID</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleIndex_t</type>
      <name>GroupID</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticlePos_t</type>
      <name>R</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticlePos_t</type>
      <name>curR</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>initBase</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>Counter</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>LocalNum</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>GlobalNum</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ParticleIndex_t</type>
      <name>SubPtcl</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>map&lt; string, int &gt;</type>
      <name>AttribTypeMap</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>map&lt; string, int &gt;</type>
      <name>Name2Index</name>
      <anchor>p5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>map&lt; string, OhmmsObject * &gt;</type>
      <name>AttribList</name>
      <anchor>p6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; ParticleIndex_t * &gt;</type>
      <name>INDEX</name>
      <anchor>p7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; ParticleScalar_t * &gt;</type>
      <name>VAL</name>
      <anchor>p8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; ParticlePos_t * &gt;</type>
      <name>POS</name>
      <anchor>p9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; ParticleTensor_t * &gt;</type>
      <name>TENZOR</name>
      <anchor>p10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; OhmmsObject * &gt;</type>
      <name>myAttribList</name>
      <anchor>p11</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ParticleTags</name>
    <filename>structParticleTags.html</filename>
    <member kind="enumvalue">
      <name>PA_IndexType</name>
      <anchor>w5w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>PA_ScalarType</name>
      <anchor>w5w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>PA_StringType</name>
      <anchor>w5w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>PA_PositionType</name>
      <anchor>w5w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>PA_TensorType</name>
      <anchor>w5w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>null_tag</name>
      <anchor>ga0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>indextype_tag</name>
      <anchor>s1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>scalartype_tag</name>
      <anchor>s2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>stringtype_tag</name>
      <anchor>s3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>postype_tag</name>
      <anchor>s4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>tensortype_tag</name>
      <anchor>s5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>xmoltype_tag</name>
      <anchor>s6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>position_tag</name>
      <anchor>ga1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>id_tag</name>
      <anchor>s8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>ionid_tag</name>
      <anchor>s9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>trajectory_tag</name>
      <anchor>s10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>force_tag</name>
      <anchor>s11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>velocity_tag</name>
      <anchor>s12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>energy_tag</name>
      <anchor>s13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>sumbc_tag</name>
      <anchor>s14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>root_tag</name>
      <anchor>ga2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>attrib_tag</name>
      <anchor>s16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>name_tag</name>
      <anchor>s17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>datatype_tag</name>
      <anchor>s18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>condition_tag</name>
      <anchor>s19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>size_tag</name>
      <anchor>s20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>format_tag</name>
      <anchor>s21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>role_tag</name>
      <anchor>s22</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>PeriodicBConds</name>
    <filename>structPeriodicBConds.html</filename>
    <templarg>T</templarg>
    <templarg>D</templarg>
    <member kind="function" static="yes">
      <type>static T</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const CrystalLattice&lt; T, D &gt; &amp;lat, const TinyVector&lt; T, D &gt; &amp;a)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>PeriodicBConds&lt; T, 3 &gt;</name>
    <filename>structPeriodicBConds_3_01T_00_013_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="function" static="yes">
      <type>static T</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(const CrystalLattice&lt; T, 3 &gt; &amp;lat, const TinyVector&lt; T, 3 &gt; &amp;a)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>PooledData</name>
    <filename>classPooledData.html</filename>
    <templarg>T</templarg>
    <base>std::vector</base>
    <member kind="function">
      <type></type>
      <name>PooledData</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PooledData</name>
      <anchor>a1</anchor>
      <arglist>(const PooledData &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>PooledData&lt; T &gt; &amp;</type>
      <name>operator=</name>
      <anchor>a2</anchor>
      <arglist>(const PooledData&lt; T &gt; &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>current</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rewind</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a5</anchor>
      <arglist>(T x)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a6</anchor>
      <arglist>(_InputIterator first, _InputIterator last)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>get</name>
      <anchor>a7</anchor>
      <arglist>(T &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>get</name>
      <anchor>a8</anchor>
      <arglist>(_OutputIterator first, _OutputIterator last)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>put</name>
      <anchor>a9</anchor>
      <arglist>(T x)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>put</name>
      <anchor>a10</anchor>
      <arglist>(_InputIterator first, _InputIterator last)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>print</name>
      <anchor>a11</anchor>
      <arglist>(std::ostream &amp;os)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_t</type>
      <name>Current</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>printTinyVector</name>
    <filename>structprintTinyVector.html</filename>
    <templarg>T</templarg>
  </compound>
  <compound kind="struct">
    <name>printTinyVector&lt; TinyVector&lt; T, 2 &gt; &gt;</name>
    <filename>structprintTinyVector_3_01TinyVector_3_01T_00_012_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>print</name>
      <anchor>e0</anchor>
      <arglist>(std::ostream &amp;os, const TinyVector&lt; T, 2 &gt; &amp;r)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>printTinyVector&lt; TinyVector&lt; T, 3 &gt; &gt;</name>
    <filename>structprintTinyVector_3_01TinyVector_3_01T_00_013_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>print</name>
      <anchor>e0</anchor>
      <arglist>(std::ostream &amp;os, const TinyVector&lt; T, 3 &gt; &amp;r)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>printTinyVector&lt; TinyVector&lt; T, D &gt; &gt;</name>
    <filename>structprintTinyVector_3_01TinyVector_3_01T_00_01D_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>D</templarg>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>print</name>
      <anchor>e0</anchor>
      <arglist>(std::ostream &amp;os, const TinyVector&lt; T, D &gt; &amp;r)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>PtclOnLatticeTraits</name>
    <filename>classPtclOnLatticeTraits.html</filename>
  </compound>
  <compound kind="class">
    <name>QDwf</name>
    <filename>classQDwf.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QDwf</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur, VarRegistry&lt; T1 &gt; &amp;vlist)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set_point</name>
      <anchor>a3</anchor>
      <arglist>(const posvec_t &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(const posvec_t &amp;r, posvec_t &amp;gradf, double &amp;lapf)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>funcz</name>
      <anchor>d0</anchor>
      <arglist>(double z)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>zprime</name>
      <anchor>d1</anchor>
      <arglist>(double z)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>X</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>sigx</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>a</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>sigy</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>Y0</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>z0</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>Ez</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>VB</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>zB</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>kappa</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>EL</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>psiB</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>onethird</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>fac1</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>fac2</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>uGrid1D *</type>
      <name>m_grid</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CubicSpline *</type>
      <name>m_spline</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>gsl_mode_t</type>
      <name>mode</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>QMCGaussianParserBase</name>
    <filename>structQMCGaussianParserBase.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSet::SingleParticlePos_t</type>
      <name>SingleParticlePos_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QMCGaussianParserBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QMCGaussianParserBase</name>
      <anchor>a1</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setOccupationNumbers</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>createGridNode</name>
      <anchor>a3</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
    <member kind="function">
      <type>xmlNodePtr</type>
      <name>createElectronSet</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>xmlNodePtr</type>
      <name>createIonSet</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>xmlNodePtr</type>
      <name>createBasisSet</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>xmlNodePtr</type>
      <name>createCenter</name>
      <anchor>a7</anchor>
      <arglist>(int iat, int _off)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>createShell</name>
      <anchor>a8</anchor>
      <arglist>(int n, int ig, int off_, xmlNodePtr abasis)</arglist>
    </member>
    <member kind="function">
      <type>xmlNodePtr</type>
      <name>createDeterminantSet</name>
      <anchor>a9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>map2GridFunctors</name>
      <anchor>a10</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>parse</name>
      <anchor>a11</anchor>
      <arglist>(const std::string &amp;fname)=0</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>BohrUnit</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>SpinRestricted</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>IonChargeIndex</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>ValenceChargeIndex</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>AtomicNumberIndex</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumberOfAtoms</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumberOfEls</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>SpinMultiplicity</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumberOfAlpha</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumberOfBeta</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>SizeOfBasisSet</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>Title</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>basisType</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>basisName</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>Normalized</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>CurrentCenter</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet</type>
      <name>IonSystem</name>
      <anchor>o16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; string &gt;</type>
      <name>GroupName</name>
      <anchor>o17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; int &gt;</type>
      <name>gShell</name>
      <anchor>o18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; int &gt;</type>
      <name>gNumber</name>
      <anchor>o19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; int &gt;</type>
      <name>gBound</name>
      <anchor>o20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; int &gt;</type>
      <name>Occ_alpha</name>
      <anchor>o21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; int &gt;</type>
      <name>Occ_beta</name>
      <anchor>o22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>Qv</name>
      <anchor>o23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>gExp</name>
      <anchor>o24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>gC0</name>
      <anchor>o25</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>gC1</name>
      <anchor>o26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>EigVal_alpha</name>
      <anchor>o27</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>EigVal_beta</name>
      <anchor>o28</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>EigVec</name>
      <anchor>o29</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>xmlNodePtr</type>
      <name>gridPtr</name>
      <anchor>o30</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::map&lt; int, std::string &gt;</type>
      <name>IonName</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::vector&lt; std::string &gt;</type>
      <name>gShellType</name>
      <anchor>s1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::vector&lt; int &gt;</type>
      <name>gShellID</name>
      <anchor>s2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>QMCTraits</name>
    <filename>classQMCTraits.html</filename>
  </compound>
  <compound kind="struct">
    <name>RadialGaussian</name>
    <filename>structRadialGaussian.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>RadialGaussian</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RadialGaussian</name>
      <anchor>a1</anchor>
      <arglist>(int l, T sig, T norm=1.0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setgrid</name>
      <anchor>a2</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(T r, T rinv, T &amp;drnl, T &amp;d2rnl)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>L</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Sigma</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Norm</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RadialOrbitalBase</name>
    <filename>structRadialOrbitalBase.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>RadialOrbitalBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RadialOrbitalBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual T</type>
      <name>f</name>
      <anchor>a2</anchor>
      <arglist>(T r) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual T</type>
      <name>df</name>
      <anchor>a3</anchor>
      <arglist>(T r) const =0</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RadialOrbitalSet</name>
    <filename>structRadialOrbitalSet.html</filename>
    <templarg>T</templarg>
    <base>RadialOrbitalBase</base>
    <member kind="function">
      <type></type>
      <name>~RadialOrbitalSet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addRadialOrbital</name>
      <anchor>a1</anchor>
      <arglist>(RadialOrbitalBase&lt; T &gt; *arad)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>f</name>
      <anchor>a2</anchor>
      <arglist>(T r) const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>df</name>
      <anchor>a3</anchor>
      <arglist>(T r) const </arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; RadialOrbitalBase&lt; T &gt; * &gt;</type>
      <name>InFunc</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RadialSTO</name>
    <filename>structRadialSTO.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RadialSTO</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RadialSTO</name>
      <anchor>a1</anchor>
      <arglist>(int n, double z, double norm=1.0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setgrid</name>
      <anchor>a2</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>f</name>
      <anchor>a3</anchor>
      <arglist>(T r) const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>df</name>
      <anchor>a4</anchor>
      <arglist>(T r) const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluateAll</name>
      <anchor>a6</anchor>
      <arglist>(T r, T rinv)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a7</anchor>
      <arglist>(T r, T rinv, T &amp;drnl, T &amp;d2rnl)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NminusOne</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Z</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Norm</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Y</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>dY</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2Y</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RandomSeq</name>
    <filename>structRandomSeq.html</filename>
    <templarg>VT</templarg>
    <templarg>RNG</templarg>
  </compound>
  <compound kind="struct">
    <name>RandomSeq&lt; TinyVector&lt; double, 3 &gt;, RNG &gt;</name>
    <filename>structRandomSeq_3_01TinyVector_3_01double_00_013_01_4_00_01RNG_01_4.html</filename>
    <templarg>RNG</templarg>
    <member kind="typedef">
      <type>TinyVector&lt; double, 3 &gt;</type>
      <name>Return_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Return_t</type>
      <name>get</name>
      <anchor>e0</anchor>
      <arglist>(RNG &amp;rng)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RandomSeq&lt; TinyVector&lt; T, D &gt;, RNG &gt;</name>
    <filename>structRandomSeq_3_01TinyVector_3_01T_00_01D_01_4_00_01RNG_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>D</templarg>
    <templarg>RNG</templarg>
    <member kind="typedef">
      <type>TinyVector&lt; double, D &gt;</type>
      <name>Return_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static Return_t</type>
      <name>get</name>
      <anchor>e0</anchor>
      <arglist>(RNG &amp;rng)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RandomSequence</name>
    <filename>structRandomSequence.html</filename>
    <templarg>RA</templarg>
    <templarg>RNG</templarg>
  </compound>
  <compound kind="struct">
    <name>RandomSequence&lt; vector&lt; double &gt;, RNG &gt;</name>
    <filename>structRandomSequence_3_01vector_3_01double_01_4_00_01RNG_01_4.html</filename>
    <templarg>RNG</templarg>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(vector&lt; double &gt; &amp;s, RNG &amp;rnd)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RandomSequence&lt; vector&lt; T &gt;, RNG &gt;</name>
    <filename>structRandomSequence_3_01vector_3_01T_01_4_00_01RNG_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>RNG</templarg>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(vector&lt; T &gt; &amp;v, RandomVector&lt; T, RNG &gt; &amp;rnd)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>RandomUniformPos</name>
    <filename>classRandomUniformPos.html</filename>
    <templarg>Vec</templarg>
    <templarg>RNG</templarg>
  </compound>
  <compound kind="class">
    <name>RandomUniformPos&lt; TinyVector&lt; double, 2 &gt;, RNG &gt;</name>
    <filename>classRandomUniformPos_3_01TinyVector_3_01double_00_012_01_4_00_01RNG_01_4.html</filename>
    <templarg>RNG</templarg>
    <member kind="typedef">
      <type>TinyVector&lt; double, 2 &gt;</type>
      <name>Return_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RandomUniformPos</name>
      <anchor>a0</anchor>
      <arglist>(RNG &amp;rg)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>operator()</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RNG &amp;</type>
      <name>d_engine</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>RandomUniformPos&lt; TinyVector&lt; double, 3 &gt;, RNG &gt;</name>
    <filename>classRandomUniformPos_3_01TinyVector_3_01double_00_013_01_4_00_01RNG_01_4.html</filename>
    <templarg>RNG</templarg>
    <member kind="typedef">
      <type>TinyVector&lt; double, 3 &gt;</type>
      <name>Return_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RandomUniformPos</name>
      <anchor>a0</anchor>
      <arglist>(RNG &amp;rg)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>operator()</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RNG &amp;</type>
      <name>d_engine</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RandomVector</name>
    <filename>structRandomVector.html</filename>
    <templarg>VT</templarg>
    <templarg>RNG</templarg>
  </compound>
  <compound kind="class">
    <name>RandRandom</name>
    <filename>classRandRandom.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>Return_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RandRandom</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RandRandom</name>
      <anchor>a1</anchor>
      <arglist>(int i, int nstr, int iseed)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~RandRandom</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a3</anchor>
      <arglist>(int i=0, int nstr=1, int iseed=-1)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>getRandom</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>operator()</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>irand</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>bivariate</name>
      <anchor>a7</anchor>
      <arglist>(Return_t &amp;g1, Return_t &amp;g2)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>thisStreamID</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>nStreams</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>thisSeed</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>static const Return_t</type>
      <name>rand_max_inv</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RecordNamedProperty</name>
    <filename>structRecordNamedProperty.html</filename>
    <templarg>T</templarg>
    <base>RecordProperty</base>
    <member kind="function">
      <type></type>
      <name>RecordNamedProperty</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RecordNamedProperty</name>
      <anchor>a1</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~RecordNamedProperty</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator[]</name>
      <anchor>a3</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator[]</name>
      <anchor>a4</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>add</name>
      <anchor>a5</anchor>
      <arglist>(const char *aname)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setValues</name>
      <anchor>a7</anchor>
      <arglist>(T v)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a8</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a9</anchor>
      <arglist>(const char *fileroot)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>report</name>
      <anchor>a10</anchor>
      <arglist>(int iter)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>finalize</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a12</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>std::ostream *</type>
      <name>OutStream</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; T &gt;</type>
      <name>Values</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; std::string &gt;</type>
      <name>Name</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RecordProperty</name>
    <filename>structRecordProperty.html</filename>
    <member kind="function">
      <type></type>
      <name>RecordProperty</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RecordProperty</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>(const char *fileroot)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>report</name>
      <anchor>a3</anchor>
      <arglist>(int i)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>finalize</name>
      <anchor>a4</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>put</name>
      <anchor>a5</anchor>
      <arglist>(xmlNodePtr cur)=0</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>stride</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>FileName</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>RecordPropertyList</name>
    <filename>classRecordPropertyList.html</filename>
    <member kind="typedef">
      <type>std::vector&lt; RecordProperty * &gt;</type>
      <name>RecordList_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RecordPropertyList</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RecordPropertyList</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addRecord</name>
      <anchor>a2</anchor>
      <arglist>(RecordProperty *a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setstride</name>
      <anchor>a3</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>report</name>
      <anchor>a4</anchor>
      <arglist>(int iter)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>finalize</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>std::vector&lt; RecordProperty * &gt;</type>
      <name>Properties</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>RegCubicSpline</name>
    <filename>classRegCubicSpline.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>RegCubicSpline</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RegCubicSpline</name>
      <anchor>a1</anchor>
      <arglist>(const int n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a2</anchor>
      <arglist>(const int n)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a3</anchor>
      <arglist>(T x0)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a4</anchor>
      <arglist>(T x0, T &amp;yval)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a5</anchor>
      <arglist>(T x0, T &amp;yval, T &amp;yp)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spline</name>
      <anchor>a7</anchor>
      <arglist>(const int n, const T x0, const T dx, const T yp1, const T ypn, T *y)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>Npt</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>Xmin</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>Xmax</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>Dx</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>DxInv</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>Yp1</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>Ypn</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>h2over6</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; T &gt;</type>
      <name>Y</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; T &gt;</type>
      <name>Y2</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>RPAJastrow</name>
    <filename>structRPAJastrow.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>RPAJastrow</name>
      <anchor>a0</anchor>
      <arglist>(T a=1.0, T b=1.0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>(T a, T b)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(T r, T &amp;dudr, T &amp;d2udr2)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>put</name>
      <anchor>a5</anchor>
      <arglist>(xmlNodePtr cur, VarRegistry&lt; T1 &gt; &amp;vlist)</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>A</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>A2</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>B</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Finv</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>AFinv_sq</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>SCTFunctor</name>
    <filename>structSCTFunctor.html</filename>
    <templarg>SCT</templarg>
    <templarg>L</templarg>
    <member kind="typedef">
      <type>SCT::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SCT::pos_type</type>
      <name>pos_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(std::vector&lt; value_type &gt; &amp;Ylm, std::vector&lt; pos_type &gt; &amp;gYlm, const pos_type &amp;p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>SCTFunctor&lt; SCT, 1 &gt;</name>
    <filename>structSCTFunctor_3_01SCT_00_011_01_4.html</filename>
    <templarg>SCT</templarg>
    <member kind="typedef">
      <type>SCT::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SCT::pos_type</type>
      <name>pos_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(std::vector&lt; value_type &gt; &amp;Ylm, std::vector&lt; pos_type &gt; &amp;gYlm, const pos_type &amp;p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>SCTFunctor&lt; SCT, 2 &gt;</name>
    <filename>structSCTFunctor_3_01SCT_00_012_01_4.html</filename>
    <templarg>SCT</templarg>
    <member kind="typedef">
      <type>SCT::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SCT::pos_type</type>
      <name>pos_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(std::vector&lt; value_type &gt; &amp;Ylm, std::vector&lt; pos_type &gt; &amp;gYlm, const pos_type &amp;p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>SCTFunctor&lt; SCT, 3 &gt;</name>
    <filename>structSCTFunctor_3_01SCT_00_013_01_4.html</filename>
    <templarg>SCT</templarg>
    <member kind="typedef">
      <type>SCT::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SCT::pos_type</type>
      <name>pos_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>apply</name>
      <anchor>e0</anchor>
      <arglist>(std::vector&lt; value_type &gt; &amp;Ylm, std::vector&lt; pos_type &gt; &amp;gYlm, const pos_type &amp;p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>Sine3D</name>
    <filename>structSine3D.html</filename>
    <templarg>T</templarg>
    <templarg>PT</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PT</type>
      <name>pos_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Sine3D</name>
      <anchor>a0</anchor>
      <arglist>(value_type kx=0, value_type ky=0, value_type kz=0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a1</anchor>
      <arglist>(value_type kx, value_type ky, value_type kz)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(const PT &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(const PT &amp;r, PT &amp;gr, value_type &amp;lap)</arglist>
    </member>
    <member kind="function">
      <type>PT</type>
      <name>gradient</name>
      <anchor>a4</anchor>
      <arglist>(const PT &amp;r, value_type &amp;v)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>laplacian</name>
      <anchor>a5</anchor>
      <arglist>(const PT &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>operator()</name>
      <anchor>a6</anchor>
      <arglist>(const PT &amp;r)</arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Kx</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Ky</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Kz</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Knorm2</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Val</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Lap</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>pos_type</type>
      <name>Grad</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SizeLeaf</name>
    <filename>classSizeLeaf.html</filename>
    <member kind="function">
      <type></type>
      <name>SizeLeaf</name>
      <anchor>a0</anchor>
      <arglist>(int s)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SizeLeaf</name>
      <anchor>a1</anchor>
      <arglist>(const SizeLeaf &amp;model)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(int s) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>size_m</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SizeLeaf2</name>
    <filename>classSizeLeaf2.html</filename>
    <member kind="typedef">
      <type>int</type>
      <name>size_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SizeLeaf2</name>
      <anchor>a0</anchor>
      <arglist>(size_type s, size_type p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SizeLeaf2</name>
      <anchor>a1</anchor>
      <arglist>(const SizeLeaf2 &amp;model)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(size_type s, size_type p) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_type</type>
      <name>size_m</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_type</type>
      <name>size_n</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SizeLeafPA</name>
    <filename>classSizeLeafPA.html</filename>
    <member kind="function">
      <type></type>
      <name>SizeLeafPA</name>
      <anchor>a0</anchor>
      <arglist>(int s)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SizeLeafPA</name>
      <anchor>a1</anchor>
      <arglist>(const SizeLeafPA &amp;model)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(int s) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>size_m</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>SlaterCombo</name>
    <filename>structSlaterCombo.html</filename>
    <templarg>T</templarg>
    <base>RadialOrbitalBase</base>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>GenericSTO&lt; T &gt;</type>
      <name>Component_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SlaterCombo</name>
      <anchor>a0</anchor>
      <arglist>(int l=0, bool normalized=true, const char *node_name=&quot;radfunc&quot;, const char *exp_name=&quot;exponent&quot;, const char *c_name=&quot;contraction&quot;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SlaterCombo</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>f</name>
      <anchor>a3</anchor>
      <arglist>(value_type r) const </arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>df</name>
      <anchor>a4</anchor>
      <arglist>(value_type r) const </arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(T r, T rinv)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluateAll</name>
      <anchor>a6</anchor>
      <arglist>(T r, T rinv)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>evaluate</name>
      <anchor>a7</anchor>
      <arglist>(T r, T rinv, T &amp;drnl, T &amp;d2rnl)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>putBasisGroup</name>
      <anchor>a8</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>L</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>Normalized</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>nodeName</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>expName</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>coeffName</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; xmlNodePtr &gt;</type>
      <name>InParam</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; Component_t &gt;</type>
      <name>sset</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Y</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>dY</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2Y</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SpeciesBase</name>
    <filename>classSpeciesBase.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>Scalar_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Scalar_t &gt;</type>
      <name>SpeciesAttrib_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; SpeciesAttrib_t * &gt;</type>
      <name>AttribList_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpeciesBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SpeciesBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>getTotalNum</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTotalNum</name>
      <anchor>a3</anchor>
      <arglist>(const unsigned n)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>numAttributes</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>addAttrib</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>a6</anchor>
      <arglist>(int i, int j) const </arglist>
    </member>
    <member kind="function">
      <type>double &amp;</type>
      <name>operator()</name>
      <anchor>a7</anchor>
      <arglist>(int i, int j)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>create</name>
      <anchor>a8</anchor>
      <arglist>(unsigned m)</arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>find</name>
      <anchor>a9</anchor>
      <arglist>(const string &amp;name) const </arglist>
    </member>
    <member kind="function">
      <type>const string &amp;</type>
      <name>getName</name>
      <anchor>a10</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>getSpeciesID</name>
      <anchor>a11</anchor>
      <arglist>(const string &amp;name)</arglist>
    </member>
    <member kind="variable">
      <type>unsigned</type>
      <name>TotalNum</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; string &gt;</type>
      <name>Name</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>AttribList_t</type>
      <name>d_attrib</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SpeciesSet</name>
    <filename>classSpeciesSet.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>Scalar_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; Scalar_t &gt;</type>
      <name>SpeciesAttrib_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; SpeciesAttrib_t * &gt;</type>
      <name>AttribList_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpeciesSet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SpeciesSet</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getTotalNum</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTotalNum</name>
      <anchor>a3</anchor>
      <arglist>(const unsigned n)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>numAttributes</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>addSpecies</name>
      <anchor>a5</anchor>
      <arglist>(const std::string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>addAttribute</name>
      <anchor>a6</anchor>
      <arglist>(const std::string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>a7</anchor>
      <arglist>(int i, int j) const </arglist>
    </member>
    <member kind="function">
      <type>double &amp;</type>
      <name>operator()</name>
      <anchor>a8</anchor>
      <arglist>(int i, int j)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>create</name>
      <anchor>a9</anchor>
      <arglist>(unsigned m)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>findSpecies</name>
      <anchor>a10</anchor>
      <arglist>(const std::string &amp;name) const </arglist>
    </member>
    <member kind="variable">
      <type>unsigned</type>
      <name>TotalNum</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; std::string &gt;</type>
      <name>speciesName</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; std::string &gt;</type>
      <name>attribName</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>AttribList_t</type>
      <name>d_attrib</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SphericalTensor</name>
    <filename>classSphericalTensor.html</filename>
    <templarg>T</templarg>
    <templarg>Point_t</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Point_t</type>
      <name>pos_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SphericalTensor&lt; T, Point_t &gt;</type>
      <name>This_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SphericalTensor</name>
      <anchor>a0</anchor>
      <arglist>(const int l_max, bool addsign=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a1</anchor>
      <arglist>(const Point_t &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluateAll</name>
      <anchor>a2</anchor>
      <arglist>(const Point_t &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluateTest</name>
      <anchor>a3</anchor>
      <arglist>(const Point_t &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>index</name>
      <anchor>a4</anchor>
      <arglist>(int l, int m) const </arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>getYlm</name>
      <anchor>a5</anchor>
      <arglist>(int l, int m) const </arglist>
    </member>
    <member kind="function">
      <type>Point_t</type>
      <name>getGradYlm</name>
      <anchor>a6</anchor>
      <arglist>(int l, int m) const </arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>getYlm</name>
      <anchor>a7</anchor>
      <arglist>(int lm) const </arglist>
    </member>
    <member kind="function">
      <type>Point_t</type>
      <name>getGradYlm</name>
      <anchor>a8</anchor>
      <arglist>(int lm) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>lmax</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Lmax</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>Ylm</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>NormFactor</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>FactorLM</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>FactorL</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; value_type &gt;</type>
      <name>Factor2L</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; Point_t &gt;</type>
      <name>gradYlm</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SprngRandom</name>
    <filename>classSprngRandom.html</filename>
    <templarg>rg</templarg>
    <member kind="typedef">
      <type>double</type>
      <name>Return_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SprngRandom</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SprngRandom</name>
      <anchor>a1</anchor>
      <arglist>(int i, int nstr, int iseed)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a2</anchor>
      <arglist>(int i, int nstr, int iseed)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>getRandom</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>operator()</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>irand</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>bivariate</name>
      <anchor>a6</anchor>
      <arglist>(Return_t &amp;g1, Return_t &amp;g2)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>thisStreamID</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>nStreams</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>thisSeed</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int *</type>
      <name>thisStream</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>STONorm</name>
    <filename>structSTONorm.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>STONorm</name>
      <anchor>a0</anchor>
      <arglist>(int nmax=1)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a1</anchor>
      <arglist>(int nmax)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(int n, T screen)</arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; T &gt;</type>
      <name>Factorial</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>StreamIO</name>
    <filename>classStreamIO.html</filename>
    <templarg>T</templarg>
    <base>OhmmsIOBase</base>
    <member kind="function">
      <type></type>
      <name>StreamIO</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;a, ios_base::openmode mode)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~StreamIO</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>open</name>
      <anchor>a2</anchor>
      <arglist>(const char *fname, ios_mode::openmode mode)</arglist>
    </member>
    <member kind="function">
      <type>inlin void</type>
      <name>setBuffer</name>
      <anchor>a3</anchor>
      <arglist>(iostream *ebuffer)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>flush</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>close</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>read</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>write</name>
      <anchor>a7</anchor>
      <arglist>(int iter)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T &amp;</type>
      <name>ref_</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>iostream *</type>
      <name>m_buffer</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>OwnBuffer</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>SymmetricMatrix</name>
    <filename>classSymmetricMatrix.html</filename>
    <templarg>T</templarg>
    <templarg>C</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>C</type>
      <name>Container_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SymmetricMatrix&lt; T, C &gt;</type>
      <name>This_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Container_t::iterator</type>
      <name>iterator</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Container_t::const_iterator</type>
      <name>const_iterator</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SymmetricMatrix</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SymmetricMatrix</name>
      <anchor>a1</anchor>
      <arglist>(unsigned n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SymmetricMatrix</name>
      <anchor>a2</anchor>
      <arglist>(unsigned n, unsigned m)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SymmetricMatrix</name>
      <anchor>a3</anchor>
      <arglist>(const SymmetricMatrix&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SymmetricMatrix</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>size</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>size</name>
      <anchor>a6</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>nrows</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>ncols</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>begin</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>iterator</type>
      <name>begin</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>end</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const T *</type>
      <name>data</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T *</type>
      <name>data</name>
      <anchor>a14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a15</anchor>
      <arglist>(unsigned n, unsigned m)</arglist>
    </member>
    <member kind="function">
      <type>This_t &amp;</type>
      <name>operator=</name>
      <anchor>a16</anchor>
      <arglist>(const SymmetricMatrix&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>const This_t &amp;</type>
      <name>operator=</name>
      <anchor>a17</anchor>
      <arglist>(const SymmetricMatrix&lt; T, C &gt; &amp;rhs) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t *</type>
      <name>operator[]</name>
      <anchor>a18</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>const Type_t *</type>
      <name>operator[]</name>
      <anchor>a19</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a20</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a21</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a22</anchor>
      <arglist>(unsigned int i, unsigned int j)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a23</anchor>
      <arglist>(unsigned int i, unsigned int j) const </arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>D1</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>D2</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Container_t</type>
      <name>X</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>Tensor</name>
    <filename>classTensor.html</filename>
    <templarg>T</templarg>
    <templarg>D</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ElemDim</name>
      <anchor>w3w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Size</name>
      <anchor>w4w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tensor</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tensor</name>
      <anchor>a1</anchor>
      <arglist>(DontInitialize)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tensor</name>
      <anchor>a2</anchor>
      <arglist>(const Tensor&lt; T, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tensor</name>
      <anchor>a3</anchor>
      <arglist>(const T &amp;x00)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tensor</name>
      <anchor>a4</anchor>
      <arglist>(const T &amp;x00, const T &amp;x10, const T &amp;x01, const T &amp;x11)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tensor</name>
      <anchor>a5</anchor>
      <arglist>(const T &amp;x00, const T &amp;x10, const T &amp;x20, const T &amp;x01, const T &amp;x11, const T &amp;x21, const T &amp;x02, const T &amp;x12, const T &amp;x22)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tensor</name>
      <anchor>a6</anchor>
      <arglist>(const SymTensor&lt; T, D &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tensor</name>
      <anchor>a7</anchor>
      <arglist>(const AntiSymTensor&lt; T, D &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Tensor</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator=</name>
      <anchor>a9</anchor>
      <arglist>(const Tensor&lt; T, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator=</name>
      <anchor>a10</anchor>
      <arglist>(const Tensor&lt; T1, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator=</name>
      <anchor>a11</anchor>
      <arglist>(const T &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator+=</name>
      <anchor>a12</anchor>
      <arglist>(const Tensor&lt; T1, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator+=</name>
      <anchor>a13</anchor>
      <arglist>(const T &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator-=</name>
      <anchor>a14</anchor>
      <arglist>(const Tensor&lt; T1, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator-=</name>
      <anchor>a15</anchor>
      <arglist>(const T &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator *=</name>
      <anchor>a16</anchor>
      <arglist>(const Tensor&lt; T1, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator *=</name>
      <anchor>a17</anchor>
      <arglist>(const T &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator/=</name>
      <anchor>a18</anchor>
      <arglist>(const Tensor&lt; T1, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Tensor&lt; T, D &gt; &amp;</type>
      <name>operator/=</name>
      <anchor>a19</anchor>
      <arglist>(const T &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>diagonal</name>
      <anchor>a20</anchor>
      <arglist>(const T &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>len</name>
      <anchor>a21</anchor>
      <arglist>(void) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a22</anchor>
      <arglist>(void) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator[]</name>
      <anchor>a23</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator[]</name>
      <anchor>a24</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a25</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a26</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a27</anchor>
      <arglist>(unsigned int i, unsigned int j) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a28</anchor>
      <arglist>(unsigned int i, unsigned int j)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>X</name>
      <anchor>r0</anchor>
      <arglist>[Size]</arglist>
    </member>
    <class kind="class">Tensor::DontInitialize</class>
  </compound>
  <compound kind="class">
    <name>Tensor::DontInitialize</name>
    <filename>classTensor_1_1DontInitialize.html</filename>
    <templarg>T</templarg>
    <templarg>D</templarg>
  </compound>
  <compound kind="struct">
    <name>TestFunc</name>
    <filename>structTestFunc.html</filename>
    <member kind="function">
      <type></type>
      <name>TestFunc</name>
      <anchor>a0</anchor>
      <arglist>(int nk0=1, int nk1=1, int nk2=1)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>f</name>
      <anchor>a1</anchor>
      <arglist>(const TinyVector&lt; double, 3 &gt; &amp;pos)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>f</name>
      <anchor>a2</anchor>
      <arglist>(double x, double y, double z)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>d2f</name>
      <anchor>a3</anchor>
      <arglist>(const TinyVector&lt; double, 3 &gt; &amp;pos)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>d2f</name>
      <anchor>a4</anchor>
      <arglist>(double x, double y, double z)</arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>k0</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>k1</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>k2</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>d2factor</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>TestTransform</name>
    <filename>structTestTransform.html</filename>
    <templarg>FnIn</templarg>
    <templarg>FnOut</templarg>
    <member kind="typedef">
      <type>FnOut::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>FnOut::point_type</type>
      <name>point_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>check</name>
      <anchor>e0</anchor>
      <arglist>(FnIn &amp;af, FnOut &amp;nf, point_type ri, point_type rf, int n)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>TinyMatrixRef</name>
    <filename>classTinyMatrixRef.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TinyMatrixRef</name>
      <anchor>a0</anchor>
      <arglist>(T *datain, int d1, int d2)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TinyMatrixRef</name>
      <anchor>a1</anchor>
      <arglist>(TinyMatrix&lt; T, N, M &gt; &amp;mat)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TinyMatrixRef</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nrow</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>ncol</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>byteSize</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator[]</name>
      <anchor>a6</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator[]</name>
      <anchor>a7</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a8</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a9</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a10</anchor>
      <arglist>(unsigned int i, unsigned int j) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a11</anchor>
      <arglist>(unsigned int i, unsigned int j)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>TinyMatrixRef</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>D1</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>D2</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T *</type>
      <name>data</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>TinyVector</name>
    <filename>classTinyVector.html</filename>
    <templarg>T</templarg>
    <templarg>D</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Size</name>
      <anchor>w2w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TinyVector</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TinyVector</name>
      <anchor>a1</anchor>
      <arglist>(DontInitialize)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TinyVector</name>
      <anchor>a2</anchor>
      <arglist>(const TinyVector&lt; T, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TinyVector</name>
      <anchor>a3</anchor>
      <arglist>(const TinyVector&lt; T1, D1 &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TinyVector</name>
      <anchor>a4</anchor>
      <arglist>(const T &amp;x00)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TinyVector</name>
      <anchor>a5</anchor>
      <arglist>(const T &amp;x00, const T &amp;x01)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TinyVector</name>
      <anchor>a6</anchor>
      <arglist>(const T &amp;x00, const T &amp;x01, const T &amp;x02)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TinyVector</name>
      <anchor>a7</anchor>
      <arglist>(const T &amp;x00, const T &amp;x01, const T &amp;x02, const T &amp;x03)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TinyVector</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>byteSize</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>TinyVector&lt; T, D &gt; &amp;</type>
      <name>operator=</name>
      <anchor>a11</anchor>
      <arglist>(const TinyVector&lt; T, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>TinyVector&lt; T, D &gt; &amp;</type>
      <name>operator=</name>
      <anchor>a12</anchor>
      <arglist>(const TinyVector&lt; T1, D &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>TinyVector&lt; T, D &gt; &amp;</type>
      <name>operator=</name>
      <anchor>a13</anchor>
      <arglist>(const T &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator[]</name>
      <anchor>a14</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator[]</name>
      <anchor>a15</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a16</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a17</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t *</type>
      <name>begin</name>
      <anchor>a18</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const Type_t *</type>
      <name>begin</name>
      <anchor>a19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Type_t *</type>
      <name>end</name>
      <anchor>a20</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const Type_t *</type>
      <name>end</name>
      <anchor>a21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>X</name>
      <anchor>r0</anchor>
      <arglist>[Size]</arglist>
    </member>
    <class kind="class">TinyVector::DontInitialize</class>
  </compound>
  <compound kind="class">
    <name>TinyVector::DontInitialize</name>
    <filename>classTinyVector_1_1DontInitialize.html</filename>
  </compound>
  <compound kind="struct">
    <name>Transform2GridFunctor</name>
    <filename>structTransform2GridFunctor.html</filename>
    <templarg>FnIn</templarg>
    <templarg>FnOut</templarg>
    <base>Transform2GridFunctorBase</base>
    <member kind="typedef">
      <type>FnIn::value_type</type>
      <name>result_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>FnOut::point_type</type>
      <name>point_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transform2GridFunctor</name>
      <anchor>a0</anchor>
      <arglist>(FnIn &amp;in, FnOut &amp;out)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>generate</name>
      <anchor>a1</anchor>
      <arglist>(point_type ri, point_type rf, int ng, int np=0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>generate</name>
      <anchor>a2</anchor>
      <arglist>(point_type rf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>generate</name>
      <anchor>a3</anchor>
      <arglist>(int np=0)</arglist>
    </member>
    <member kind="variable">
      <type>FnIn &amp;</type>
      <name>in_</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>FnOut &amp;</type>
      <name>out_</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>Transform2GridFunctorBase</name>
    <filename>structTransform2GridFunctorBase.html</filename>
    <templarg>FnOut</templarg>
    <member kind="typedef">
      <type>FnOut::point_type</type>
      <name>point_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>generate</name>
      <anchor>a0</anchor>
      <arglist>(point_type ri, point_type rf, int ng, int np=0)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>generate</name>
      <anchor>a1</anchor>
      <arglist>(int np=0)=0</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>TriCubicSplineT</name>
    <filename>classTriCubicSplineT.html</filename>
    <templarg>T</templarg>
    <templarg>Tg</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Tg</type>
      <name>point_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>XYZCubicGrid&lt; Tg &gt;</type>
      <name>GridType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TriCubicSplineT&lt; T, Tg &gt;</type>
      <name>ThisType</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>GridType::KnotType</type>
      <name>KnotType</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>GridType::Grid1DType</type>
      <name>Grid1DType</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TriCubicSplineT</name>
      <anchor>a0</anchor>
      <arglist>(GridType *agrid)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGridManager</name>
      <anchor>a1</anchor>
      <arglist>(bool willmanage)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>(bool periodic=true)</arglist>
    </member>
    <member kind="function">
      <type>T *</type>
      <name>data</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const T *</type>
      <name>data</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a5</anchor>
      <arglist>(int n) const </arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator()</name>
      <anchor>a6</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a7</anchor>
      <arglist>(int i, int j, int k) const </arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator()</name>
      <anchor>a8</anchor>
      <arglist>(int i, int j, int k)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>index</name>
      <anchor>a9</anchor>
      <arglist>(int i, int j, int k)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a10</anchor>
      <arglist>(IT first, IT last)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a11</anchor>
      <arglist>(const PV &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a12</anchor>
      <arglist>(const PV &amp;r, PV &amp;gradf, T &amp;lapf)</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>GridManager</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>UpToDate</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nX</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nY</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nZ</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>n001</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>n010</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>n011</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>n100</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>n101</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>n110</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>n111</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>GridType *</type>
      <name>m_grid</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; KnotType &gt;</type>
      <name>F</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>UpdateX</name>
      <anchor>d0</anchor>
      <arglist>(int source, int target, bool periodic)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>UpdateY</name>
      <anchor>d1</anchor>
      <arglist>(int source, int target, bool periodic)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>UpdateZ</name>
      <anchor>d2</anchor>
      <arglist>(int source, int target, bool periodic)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>UOverRN</name>
    <filename>structUOverRN.html</filename>
    <templarg>Rin</templarg>
    <member kind="typedef">
      <type>Rin::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Rin::point_type</type>
      <name>point_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UOverRN</name>
      <anchor>a0</anchor>
      <arglist>(int x, Rin &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~UOverRN</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setgrid</name>
      <anchor>a2</anchor>
      <arglist>(value_type r)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>f</name>
      <anchor>a3</anchor>
      <arglist>(value_type r) const </arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>df</name>
      <anchor>a4</anchor>
      <arglist>(value_type r) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(value_type r, value_type rinv)</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>evaluate</name>
      <anchor>a6</anchor>
      <arglist>(value_type r, value_type rinv, value_type &amp;drnl, value_type &amp;d2rnl)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>X</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>Y</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>dY</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>value_type</type>
      <name>d2Y</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Rin &amp;</type>
      <name>U</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>std::vector</name>
    <filename>classstd_1_1vector.html</filename>
  </compound>
  <compound kind="class">
    <name>std::vector</name>
    <filename>classstd_1_1vector.html</filename>
  </compound>
  <compound kind="class">
    <name>Vector</name>
    <filename>classVector.html</filename>
    <templarg>T</templarg>
    <templarg>C</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>Type_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>C</type>
      <name>Container_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Vector&lt; T, C &gt;</type>
      <name>This_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Container_t::iterator</type>
      <name>iterator</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Container_t::const_iterator</type>
      <name>const_iterator</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Vector</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Vector</name>
      <anchor>a1</anchor>
      <arglist>(unsigned n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Vector</name>
      <anchor>a2</anchor>
      <arglist>(const Vector&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Vector</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned</type>
      <name>size</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a5</anchor>
      <arglist>(unsigned n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>create</name>
      <anchor>a6</anchor>
      <arglist>(unsigned n)</arglist>
    </member>
    <member kind="function">
      <type>This_t &amp;</type>
      <name>operator=</name>
      <anchor>a7</anchor>
      <arglist>(const Vector&lt; T, C &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>const This_t &amp;</type>
      <name>operator=</name>
      <anchor>a8</anchor>
      <arglist>(const Vector&lt; T, C &gt; &amp;rhs) const </arglist>
    </member>
    <member kind="function">
      <type>This_t &amp;</type>
      <name>operator=</name>
      <anchor>a9</anchor>
      <arglist>(const RHS &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>Type_t *</type>
      <name>data</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const Type_t *</type>
      <name>data</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>iterator</type>
      <name>begin</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>begin</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>iterator</type>
      <name>end</name>
      <anchor>a14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>end</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator[]</name>
      <anchor>a16</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator[]</name>
      <anchor>a17</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type_t &amp;</type>
      <name>operator()</name>
      <anchor>a18</anchor>
      <arglist>(unsigned int i)</arglist>
    </member>
    <member kind="function">
      <type>Type_t</type>
      <name>operator()</name>
      <anchor>a19</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Container_t</type>
      <name>X</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>VectorRef</name>
    <filename>structVectorRef.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VectorRef</name>
      <anchor>a0</anchor>
      <arglist>(T *datain)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator[]</name>
      <anchor>a1</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator[]</name>
      <anchor>a2</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="variable">
      <type>T *</type>
      <name>dptr</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>XYZCubicGrid</name>
    <filename>structXYZCubicGrid.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>TinyVector&lt; T, 8 &gt;</type>
      <name>KnotType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OneDimGridBase&lt; T &gt;</type>
      <name>Grid1DType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>p1</name>
      <anchor>a0</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>p2</name>
      <anchor>a1</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>q1</name>
      <anchor>a2</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>q2</name>
      <anchor>a3</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>dp1</name>
      <anchor>a4</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>dq1</name>
      <anchor>a5</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>dp2</name>
      <anchor>a6</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>dq2</name>
      <anchor>a7</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>d2p1</name>
      <anchor>a8</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>d2q1</name>
      <anchor>a9</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>d2p2</name>
      <anchor>a10</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>d2q2</name>
      <anchor>a11</anchor>
      <arglist>(T t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>XYZCubicGrid</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>XYZCubicGrid</name>
      <anchor>a13</anchor>
      <arglist>(Grid1DType *xgrid, Grid1DType *ygrid, Grid1DType *zgrid)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGridXYZ</name>
      <anchor>a14</anchor>
      <arglist>(Grid1DType *xgrid, Grid1DType *ygrid, Grid1DType *zgrid)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a16</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setBC</name>
      <anchor>a17</anchor>
      <arglist>(bool pbc)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>index</name>
      <anchor>a18</anchor>
      <arglist>(int i, int j, int k) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>locate</name>
      <anchor>a19</anchor>
      <arglist>(T x, T y, T z, bool updateall)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a20</anchor>
      <arglist>(bool all)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a21</anchor>
      <arglist>(const KnotType &amp;f000, const KnotType &amp;f001, const KnotType &amp;f010, const KnotType &amp;f011, const KnotType &amp;f100, const KnotType &amp;f101, const KnotType &amp;f110, const KnotType &amp;f111)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluateAll</name>
      <anchor>a22</anchor>
      <arglist>(const KnotType &amp;f000, const KnotType &amp;f001, const KnotType &amp;f010, const KnotType &amp;f011, const KnotType &amp;f100, const KnotType &amp;f101, const KnotType &amp;f110, const KnotType &amp;f111)</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>OwnGrid</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>Periodic</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Loc</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>ix</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>iy</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>iz</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nX</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nY</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nZ</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>x_min</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>x_max</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>LengthX</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>y_min</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>y_max</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>LengthY</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>z_min</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>z_max</name>
      <anchor>o16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>LengthZ</name>
      <anchor>o17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>h</name>
      <anchor>o18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>k</name>
      <anchor>o19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>l</name>
      <anchor>o20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>hinv</name>
      <anchor>o21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>kinv</name>
      <anchor>o22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>linv</name>
      <anchor>o23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>u</name>
      <anchor>o24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>v</name>
      <anchor>o25</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>w</name>
      <anchor>o26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>val</name>
      <anchor>o27</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>gradfX</name>
      <anchor>o28</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>gradfY</name>
      <anchor>o29</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>gradfZ</name>
      <anchor>o30</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>lapf</name>
      <anchor>o31</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>a0</name>
      <anchor>o32</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>a1</name>
      <anchor>o33</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>a2</name>
      <anchor>o34</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>a3</name>
      <anchor>o35</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>b0</name>
      <anchor>o36</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>b1</name>
      <anchor>o37</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>b2</name>
      <anchor>o38</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>b3</name>
      <anchor>o39</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>c0</name>
      <anchor>o40</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>c1</name>
      <anchor>o41</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>c2</name>
      <anchor>o42</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>c3</name>
      <anchor>o43</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>da0</name>
      <anchor>o44</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>da1</name>
      <anchor>o45</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>da2</name>
      <anchor>o46</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>da3</name>
      <anchor>o47</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>db0</name>
      <anchor>o48</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>db1</name>
      <anchor>o49</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>db2</name>
      <anchor>o50</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>db3</name>
      <anchor>o51</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>dc0</name>
      <anchor>o52</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>dc1</name>
      <anchor>o53</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>dc2</name>
      <anchor>o54</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>dc3</name>
      <anchor>o55</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2a0</name>
      <anchor>o56</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2a1</name>
      <anchor>o57</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2a2</name>
      <anchor>o58</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2a3</name>
      <anchor>o59</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2b0</name>
      <anchor>o60</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2b1</name>
      <anchor>o61</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2b2</name>
      <anchor>o62</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2b3</name>
      <anchor>o63</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2c0</name>
      <anchor>o64</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2c1</name>
      <anchor>o65</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2c2</name>
      <anchor>o66</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>d2c3</name>
      <anchor>o67</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Grid1DType *</type>
      <name>gridX</name>
      <anchor>o68</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Grid1DType *</type>
      <name>gridY</name>
      <anchor>o69</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Grid1DType *</type>
      <name>gridZ</name>
      <anchor>o70</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>bool</name>
    <filename>classbool.html</filename>
  </compound>
  <compound kind="class">
    <name>int</name>
    <filename>classint.html</filename>
  </compound>
  <compound kind="class">
    <name>map&lt; string, int &gt;</name>
    <filename>classmap_3_01string_00_01int_01_4.html</filename>
  </compound>
  <compound kind="class">
    <name>map&lt; string, OhmmsObject * &gt;</name>
    <filename>classmap_3_01string_00_01OhmmsObject_01_5_01_4.html</filename>
  </compound>
  <compound kind="class">
    <name>ParticlePos_t</name>
    <filename>classParticlePos__t.html</filename>
  </compound>
  <compound kind="class">
    <name>ParticlePos_t</name>
    <filename>classParticlePos__t.html</filename>
  </compound>
  <compound kind="class">
    <name>ParticleSet::RealType</name>
    <filename>classParticleSet_1_1RealType.html</filename>
  </compound>
  <compound kind="class">
    <name>RealType</name>
    <filename>classRealType.html</filename>
  </compound>
  <compound kind="class">
    <name>vector&lt; OhmmsObject * &gt;</name>
    <filename>classvector_3_01OhmmsObject_01_5_01_4.html</filename>
  </compound>
  <compound kind="class">
    <name>vector&lt; ParticleIndex_t * &gt;</name>
    <filename>classvector_3_01ParticleIndex__t_01_5_01_4.html</filename>
  </compound>
  <compound kind="class">
    <name>vector&lt; ParticlePos_t * &gt;</name>
    <filename>classvector_3_01ParticlePos__t_01_5_01_4.html</filename>
  </compound>
  <compound kind="class">
    <name>vector&lt; ParticleScalar_t * &gt;</name>
    <filename>classvector_3_01ParticleScalar__t_01_5_01_4.html</filename>
  </compound>
  <compound kind="class">
    <name>vector&lt; ParticleTensor_t * &gt;</name>
    <filename>classvector_3_01ParticleTensor__t_01_5_01_4.html</filename>
  </compound>
  <compound kind="group">
    <name>XMLTags</name>
    <title>Reserved XML tags</title>
    <filename>group__XMLTags.html</filename>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>null_tag</name>
      <anchor>ga0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>position_tag</name>
      <anchor>ga1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>root_tag</name>
      <anchor>ga2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>wfs_tag</name>
      <anchor>ga3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="group">
    <name>PtclAttribConst</name>
    <title>Constructors of ParticleAttrib</title>
    <filename>group__PtclAttribConst.html</filename>
    <member kind="function">
      <type></type>
      <name>ParticleAttrib</name>
      <anchor>ga0</anchor>
      <arglist>(const std::string &amp;tname, const std::string &amp;oname)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleAttrib</name>
      <anchor>ga1</anchor>
      <arglist>(const std::string &amp;tname, const std::string &amp;oname, int n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleAttrib</name>
      <anchor>ga2</anchor>
      <arglist>(unsigned n)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleAttrib</name>
      <anchor>ga3</anchor>
      <arglist>(const ParticleAttrib&lt; T &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getNumGhosts</name>
      <anchor>ga4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>ga5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clearGhosts</name>
      <anchor>ga6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addGhosts</name>
      <anchor>ga7</anchor>
      <arglist>(int n)</arglist>
    </member>
  </compound>
  <compound kind="group">
    <name>nnlist</name>
    <title>Distance-table group</title>
    <filename>group__nnlist.html</filename>
    <class kind="struct">ohmmsqmc::AsymmetricDTD</class>
    <class kind="struct">NoBConds</class>
    <class kind="struct">PeriodicBConds</class>
    <class kind="class">ohmmsqmc::DistanceTable</class>
    <class kind="class">ohmmsqmc::DistanceTableData</class>
    <class kind="struct">ohmmsqmc::SymmetricDTD</class>
  </compound>
  <compound kind="group">
    <name>OrbitalComponent</name>
    <title>class Orbital group</title>
    <filename>group__OrbitalComponent.html</filename>
    <class kind="class">ohmmsqmc::MultiSlaterDeterminant</class>
    <class kind="class">ohmmsqmc::OneBodyJastrow</class>
    <class kind="struct">ohmmsqmc::OrbitalBase</class>
    <class kind="class">ohmmsqmc::SlaterDeterminant</class>
    <class kind="class">ohmmsqmc::TwoBodyJastrow</class>
    <class kind="class">ohmmsqmc::TwoBodyJastrow&lt; FT, false &gt;</class>
    <class kind="class">ohmmsqmc::TwoBodyJastrow&lt; FT, true &gt;</class>
  </compound>
  <compound kind="group">
    <name>WFSBuilder</name>
    <title>Orbital builder group</title>
    <filename>group__WFSBuilder.html</filename>
    <class kind="struct">ohmmsqmc::JastrowBuilder</class>
    <class kind="class">ohmmsqmc::NumericalOrbitalSetBuilder</class>
    <class kind="class">ohmmsqmc::OrbitalBuilderBase</class>
  </compound>
  <compound kind="group">
    <name>MBWfs</name>
    <title>Many-body wave function group</title>
    <filename>group__MBWfs.html</filename>
    <class kind="class">ohmmsqmc::TrialWaveFunction</class>
  </compound>
  <compound kind="group">
    <name>hamiltonian</name>
    <title>Hamiltonian group</title>
    <filename>group__hamiltonian.html</filename>
    <class kind="struct">ohmmsqmc::BareKineticEnergy</class>
    <class kind="struct">ohmmsqmc::CoulombPotentialAB</class>
    <class kind="struct">ohmmsqmc::CoulombPotentialAA</class>
    <class kind="struct">ohmmsqmc::IonIonPotential</class>
    <class kind="struct">ohmmsqmc::LocalCorePolPotential</class>
    <class kind="struct">ohmmsqmc::LocalPPotential</class>
    <class kind="struct">ohmmsqmc::NonLocalPPotential</class>
    <class kind="struct">ohmmsqmc::QMCHamiltonianBase</class>
  </compound>
  <compound kind="group">
    <name>QMCDrivers</name>
    <title>QMC Driver group</title>
    <filename>group__QMCDrivers.html</filename>
    <class kind="class">ohmmsqmc::DMCParticleByParticle</class>
    <class kind="class">ohmmsqmc::DummyQMC</class>
    <class kind="class">ohmmsqmc::MolecuDMC</class>
    <class kind="class">ohmmsqmc::QMCDriver</class>
    <class kind="class">ohmmsqmc::ReptationMC</class>
    <class kind="class">ohmmsqmc::RQMCMultiple</class>
    <class kind="class">ohmmsqmc::VMC</class>
    <class kind="class">ohmmsqmc::VMC_OPT</class>
    <class kind="class">ohmmsqmc::VMCMultiple</class>
    <class kind="class">ohmmsqmc::VMCParticleByParticle</class>
    <class kind="class">ohmmsqmc::VMCPbyPMultiple</class>
  </compound>
  <compound kind="group">
    <name>WalkerByWalker</name>
    <title>QMC Drivers using walker-by-walker update</title>
    <filename>group__WalkerByWalker.html</filename>
    <class kind="class">ohmmsqmc::MolecuDMC</class>
    <class kind="class">ohmmsqmc::VMC</class>
    <class kind="class">ohmmsqmc::VMCMultiple</class>
  </compound>
  <compound kind="group">
    <name>ParticleByParticle</name>
    <title>QMC Drivers using particle-by-particle update</title>
    <filename>group__ParticleByParticle.html</filename>
    <class kind="class">ohmmsqmc::DMCParticleByParticle</class>
    <class kind="class">ohmmsqmc::VMCParticleByParticle</class>
    <class kind="class">ohmmsqmc::VMCPbyPMultiple</class>
  </compound>
  <compound kind="group">
    <name>MultiplePsi</name>
    <title>QMC Drivers for energy differences</title>
    <filename>group__MultiplePsi.html</filename>
    <class kind="class">ohmmsqmc::RQMCMultiple</class>
    <class kind="class">ohmmsqmc::VMCMultiple</class>
    <class kind="class">ohmmsqmc::VMCPbyPMultiple</class>
  </compound>
  <compound kind="group">
    <name>qmcapp</name>
    <title>QMC Application Group</title>
    <filename>group__qmcapp.html</filename>
    <file>qmcapp.cpp</file>
    <class kind="class">ohmmsqmc::HamiltonianPool</class>
    <class kind="class">ohmmsqmc::ParticleSetPool</class>
    <class kind="class">ohmmsqmc::QMCAppBase</class>
    <class kind="class">ohmmsqmc::QMCMain</class>
    <class kind="class">ohmmsqmc::WaveFunctionPool</class>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/AtomicOrbitals/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/AtomicOrbitals/</path>
    <filename>dir_000011.html</filename>
    <file>HeSTOClementiRottie.cpp</file>
    <file>HeSTOClementiRottie.h</file>
    <file>HFAtomicSTOSet.cpp</file>
    <file>HFAtomicSTOSet.h</file>
    <file>HFAtomicSTOSetBuilder.cpp</file>
    <file>HFAtomicSTOSetBuilder.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/Estimators/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Estimators/</path>
    <filename>dir_000012.html</filename>
    <file>LocalEnergyEstimator.h</file>
    <file>MultipleEnergyEstimator.cpp</file>
    <file>MultipleEnergyEstimator.h</file>
    <file>PolarizationEstimator.h</file>
    <file>ScalarEstimatorBase.h</file>
    <file>ScalarEstimatorManager.cpp</file>
    <file>ScalarEstimatorManager.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</path>
    <filename>dir_000002.html</filename>
    <file>Any2GridBuilder.cpp</file>
    <file>Any2GridBuilder.h</file>
    <file>GridMolecularOrbitals.cpp</file>
    <file>GridMolecularOrbitals.h</file>
    <file>GTO2GridBuilder.cpp</file>
    <file>GTO2GridBuilder.h</file>
    <file>GTOMolecularOrbitals.cpp</file>
    <file>GTOMolecularOrbitals.h</file>
    <file>MolecularOrbitalBasis.h</file>
    <file>MolecularOrbitalBuilder.cpp</file>
    <file>MolecularOrbitalBuilder.h</file>
    <file>NumericalMolecularOrbitals.cpp</file>
    <file>NumericalMolecularOrbitals.h</file>
    <file>NumericalRGFBuilder.cpp</file>
    <file>NumericalRGFBuilder.h</file>
    <file>RGFBuilderBase.cpp</file>
    <file>RGFBuilderBase.h</file>
    <file>STO2GridBuilder.cpp</file>
    <file>STO2GridBuilder.h</file>
    <file>STOMolecularOrbitals.cpp</file>
    <file>STOMolecularOrbitals.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</path>
    <filename>dir_000007.html</filename>
    <file>Blasf.h</file>
    <file>Clebsch_Gordan.cpp</file>
    <file>Clebsch_Gordan.h</file>
    <file>ConstScale.h</file>
    <file>CosineFunction.h</file>
    <file>CubicSplineFunctions.cpp</file>
    <file>CubicSplineFunctions.h</file>
    <file>DeterminantOperators.h</file>
    <file>GaussianBasisSet.h</file>
    <file>GaussianTypeOrbital.h</file>
    <file>HDFNumericAttrib.h</file>
    <file>HDFSTLAttrib.h</file>
    <file>HDFTriCubicSpline.h</file>
    <file>LibxmlNumericIO.h</file>
    <file>MatGrid1D.h</file>
    <file>NDimGridBase.h</file>
    <file>NRSplineFunctions.h</file>
    <file>OhmmsBlas.cpp</file>
    <file>OhmmsBlas.h</file>
    <file>OneDimCubicSpline.h</file>
    <file>OneDimGridBase.h</file>
    <file>OneDimGridFunctor.h</file>
    <file>OneDimIntegration.h</file>
    <file>RadialFunctorUtility.h</file>
    <file>RadialOrbitalBase.h</file>
    <file>SlaterBasisSet.h</file>
    <file>SlaterTypeOrbital.h</file>
    <file>SphericalTensor.h</file>
    <file>Transform2GridFunctor.h</file>
    <file>TriCubicSplineT.h</file>
    <file>UOverRN.h</file>
    <file>XYZCubicGrid.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsApp/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsApp/</path>
    <filename>dir_000015.html</filename>
    <file>ProjectData.cpp</file>
    <file>ProjectData.h</file>
    <file>RandomNumberControl.cpp</file>
    <file>RandomNumberControl.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</path>
    <filename>dir_000005.html</filename>
    <file>AttributeSet.h</file>
    <file>DataParserTemplate.h</file>
    <file>DOMProcessor.h</file>
    <file>FileUtility.h</file>
    <file>HDFAttribIO.h</file>
    <file>libxmldefs.h</file>
    <file>OhmmsElementBase.h</file>
    <file>OhmmsIOBase.h</file>
    <file>OhmmsParameter.h</file>
    <file>ParameterSet.h</file>
    <file>RecordProperty.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</path>
    <filename>dir_000013.html</filename>
    <file>OhmmsMatrix.h</file>
    <file>OhmmsMatrixOperators.h</file>
    <file>OhmmsSymmetricMatrix.h</file>
    <file>OhmmsVector.h</file>
    <file>OhmmsVectorOperators.h</file>
    <file>OhmmsVectorRef.h</file>
    <file>Tensor.h</file>
    <file>TinyMatrixRef.h</file>
    <file>TinyVector.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</path>
    <filename>dir_000004.html</filename>
    <file>AsymmetricDistanceTableData.h</file>
    <file>DistanceTable.cpp</file>
    <file>DistanceTable.h</file>
    <file>DistanceTableData.h</file>
    <file>extfunct.h</file>
    <file>FastParticleOperators.h</file>
    <file>HDFParticleAttrib.h</file>
    <file>HDFWalkerIO.cpp</file>
    <file>HDFWalkerIO.h</file>
    <file>MCWalkerConfiguration.cpp</file>
    <file>MCWalkerConfiguration.h</file>
    <file>ParticleSet.BC.cpp</file>
    <file>ParticleSet.cpp</file>
    <file>ParticleSet.h</file>
    <file>PLayoutFunctions.h</file>
    <file>SymmetricDistanceTableData.h</file>
    <file>Walker.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</path>
    <filename>dir_000014.html</filename>
    <file>ParticleAttrib.cpp</file>
    <file>ParticleAttrib.h</file>
    <file>ParticleBase.cpp</file>
    <file>ParticleBase.h</file>
    <file>ParticleFunctions.h</file>
    <file>ParticleMessage.h</file>
    <file>ParticleUtility.h</file>
    <file>RandomSeqGenerator.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</path>
    <filename>dir_000010.html</filename>
    <file>HamiltonianPool.cpp</file>
    <file>HamiltonianPool.h</file>
    <file>InitMolecularSystem.cpp</file>
    <file>InitMolecularSystem.h</file>
    <file>MO2Grid3D.cpp</file>
    <file>MO2Grid3D.h</file>
    <file>mo2grid3d_main.cpp</file>
    <file>ParticleSetPool.cpp</file>
    <file>ParticleSetPool.h</file>
    <file>qmcapp.cpp</file>
    <file>QMCAppBase.cpp</file>
    <file>QMCAppBase.h</file>
    <file>QMCMain.cpp</file>
    <file>QMCMain.h</file>
    <file>WaveFunctionPool.cpp</file>
    <file>WaveFunctionPool.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</path>
    <filename>dir_000009.html</filename>
    <file>DMCParticleByParticle.cpp</file>
    <file>DMCParticleByParticle.h</file>
    <file>DummyQMC.cpp</file>
    <file>DummyQMC.h</file>
    <file>MolecuDMC.cpp</file>
    <file>MolecuDMC.h</file>
    <file>MolecuFixedNodeBranch.h</file>
    <file>MultiChain.h</file>
    <file>PolymerChain.h</file>
    <file>PolymerEstimator.cpp</file>
    <file>PolymerEstimator.h</file>
    <file>QMCDriver.cpp</file>
    <file>QMCDriver.h</file>
    <file>ReptationMC.cpp</file>
    <file>ReptationMC.h</file>
    <file>RQMCMultiple.cpp</file>
    <file>RQMCMultiple.h</file>
    <file>VMC.cpp</file>
    <file>VMC.h</file>
    <file>VMC_OPT.cpp</file>
    <file>VMC_OPT.h</file>
    <file>VMCMoveAll.cpp</file>
    <file>VMCMoveAll.h</file>
    <file>VMCMultiple.cpp</file>
    <file>VMCMultiple.h</file>
    <file>VMCParticleByParticle.cpp</file>
    <file>VMCParticleByParticle.h</file>
    <file>VMCPbyPMultiple.cpp</file>
    <file>VMCPbyPMultiple.h</file>
    <file>WaveFunctionTester.cpp</file>
    <file>WaveFunctionTester.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</path>
    <filename>dir_000006.html</filename>
    <file>BareKineticEnergy.h</file>
    <file>ConservedEnergy.h</file>
    <file>CoulombPotential.h</file>
    <file>EffMKineticEnergy.h</file>
    <file>EwaldSum.h</file>
    <file>HarmonicPotential.h</file>
    <file>IonIonPotential.h</file>
    <file>LocalCorePolPotential.cpp</file>
    <file>LocalCorePolPotential.h</file>
    <file>LocalPPotential.cpp</file>
    <file>LocalPPotential.h</file>
    <file>NonLocalPPotential.cpp</file>
    <file>NonLocalPPotential.h</file>
    <file>PolarizationPotential.h</file>
    <file>QMCHamiltonian.cpp</file>
    <file>QMCHamiltonian.h</file>
    <file>QMCHamiltonianBase.h</file>
    <file>Spline3DPotential.h</file>
    <file>TriCubicSplinePotential.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</path>
    <filename>dir_000003.html</filename>
    <file>Any2Slater.h</file>
    <file>Assign.cpp</file>
    <file>CasinoParser.cpp</file>
    <file>CasinoParser.h</file>
    <file>GamesXmlParser.cpp</file>
    <file>GamesXmlParser.h</file>
    <file>GaussianFCHKParser.cpp</file>
    <file>GaussianFCHKParser.h</file>
    <file>gto2grid.cpp</file>
    <file>gto2slater.cpp</file>
    <file>parse.cpp</file>
    <file>PC.cpp</file>
    <file>QMCGaussianParserBase.cpp</file>
    <file>QMCGaussianParserBase.h</file>
    <file>QMCUtilities.h</file>
    <file>spline.cpp</file>
    <file>spline3.cpp</file>
    <file>spline3_io.cpp</file>
    <file>ylmtest.cpp</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</path>
    <filename>dir_000001.html</filename>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/AtomicOrbitals/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/MolecularOrbitals/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/Spline3D/</dir>
    <file>ChebyshevJastrow.h</file>
    <file>DetSetBuilderWithBasisSet.h</file>
    <file>DiracDeterminant.h</file>
    <file>JastrowBuilder.cpp</file>
    <file>JastrowBuilder.h</file>
    <file>LCOrbitals.h</file>
    <file>MixedSPOSet.h</file>
    <file>MultiSlaterDeterminant.h</file>
    <file>NoCuspJastrow.h</file>
    <file>NumericalOrbitalSetBuilder.cpp</file>
    <file>NumericalOrbitalSetBuilder.h</file>
    <file>OneBodyJastrowFunction.h</file>
    <file>OrbitalBase.h</file>
    <file>OrbitalBuilderBase.cpp</file>
    <file>OrbitalBuilderBase.h</file>
    <file>PadeJastrow.h</file>
    <file>PolarizedJastrow.h</file>
    <file>QDwf.cpp</file>
    <file>QDwf.h</file>
    <file>QDwfBuilder.cpp</file>
    <file>QDwfBuilder.h</file>
    <file>RPAJastrow.h</file>
    <file>SingleParticleOrbitalSet.h</file>
    <file>SlaterDeterminant.h</file>
    <file>SphericalOrbitalSet.h</file>
    <file>SPOSetBase.h</file>
    <file>TrialWaveFunction.cpp</file>
    <file>TrialWaveFunction.h</file>
    <file>TriCubicSplineBuilder.cpp</file>
    <file>TriCubicSplineBuilder.h</file>
    <file>TwoBodyJastrowFunction.h</file>
    <file>TwoBodyJastrowFunction.Shared.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/Spline3D/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/Spline3D/</path>
    <filename>dir_000016.html</filename>
    <file>Spline3DBuilder.cpp</file>
    <file>Spline3DBuilder.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/</path>
    <filename>dir_000000.html</filename>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/Estimators/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/Numerics/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsApp/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsData/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/OhmmsPETE/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/Particle/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/ParticleBase/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/QMCApp/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/QMCDrivers/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/QMCHamiltonians/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/QMCTools/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/QMCWaveFunctions/</dir>
    <dir>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</dir>
    <file>ParticleTags.cpp</file>
    <file>ParticleTags.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</name>
    <path>/home/jnkim/qmcPlusPlus/v0.2/src/Utilities/</path>
    <filename>dir_000008.html</filename>
    <file>BoostRandom.h</file>
    <file>Clock.h</file>
    <file>IteratorUtility.h</file>
    <file>OhmmsInfo.cpp</file>
    <file>OhmmsInfo.h</file>
    <file>OhmmsInform.cpp</file>
    <file>OhmmsInform.h</file>
    <file>OhmmsObject.cpp</file>
    <file>OhmmsObject.h</file>
    <file>OhmmsSpecies.cpp</file>
    <file>OhmmsSpecies.h</file>
    <file>PooledData.h</file>
    <file>RandomFunctors.h</file>
    <file>RandomGenerator.cpp</file>
    <file>RandomGenerator.h</file>
    <file>RandRandom.cpp</file>
    <file>RandRandom.h</file>
    <file>SimpleParser.cpp</file>
    <file>SimpleParser.h</file>
    <file>SpeciesSet.cpp</file>
    <file>SpeciesSet.h</file>
    <file>SprngRandom.h</file>
    <file>UtilityFunctions.h</file>
    <file>XMLTemplate.h</file>
  </compound>
  <compound kind="namespace">
    <name>OHMMS</name>
    <filename>namespaceOHMMS.html</filename>
    <class kind="struct">OHMMS::PLayoutFunc</class>
    <class kind="struct">OHMMS::ProjectData</class>
    <class kind="class">OHMMS::RandomNumberControl</class>
    <member kind="function">
      <type>void</type>
      <name>printXML</name>
      <anchor>a0</anchor>
      <arglist>(const T &amp;, ostream &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>OHMMS::PLayoutFunc</name>
    <filename>structOHMMS_1_1PLayoutFunc.html</filename>
    <base>PtclOnLatticeTraits</base>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>applyBC</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleLayout_t &amp;Lattice, const ParticlePos_t &amp;pin, ParticlePos_t &amp;pout)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>applyBC</name>
      <anchor>e1</anchor>
      <arglist>(const ParticleLayout_t &amp;Lattice, ParticlePos_t &amp;pos)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>OHMMS::ProjectData</name>
    <filename>structOHMMS_1_1ProjectData.html</filename>
    <base>OhmmsElementBase</base>
    <member kind="function">
      <type></type>
      <name>ProjectData</name>
      <anchor>a0</anchor>
      <arglist>(const char *aname=&quot;project&quot;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a1</anchor>
      <arglist>(ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>advance</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rewind</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTitle</name>
      <anchor>a7</anchor>
      <arglist>(const string &amp;atitle)</arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>CurrentRoot</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const char *</type>
      <name>NextRoot</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>PreviousRoot</name>
      <anchor>a10</anchor>
      <arglist>(string &amp;oldroot) const </arglist>
    </member>
    <member kind="variable">
      <type>string</type>
      <name>m_title</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>string</type>
      <name>m_user</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>string</type>
      <name>m_host</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>string</type>
      <name>m_date</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>string</type>
      <name>m_projectroot</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>string</type>
      <name>m_nextroot</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>m_series</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>xmlNodePtr</type>
      <name>m_cur</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>OHMMS::RandomNumberControl</name>
    <filename>classOHMMS_1_1RandomNumberControl.html</filename>
    <base>OhmmsElementBase</base>
    <member kind="function">
      <type></type>
      <name>RandomNumberControl</name>
      <anchor>a0</anchor>
      <arglist>(const char *aname=&quot;random&quot;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a1</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>xmlNodePtr</type>
      <name>initialize</name>
      <anchor>a5</anchor>
      <arglist>(xmlXPathContextPtr)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>NeverBeenInitialized</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>xmlNodePtr</type>
      <name>myCur</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ohmmsqmc</name>
    <filename>namespaceohmmsqmc.html</filename>
    <class kind="struct">ohmmsqmc::AsymmetricDTD</class>
    <class kind="class">ohmmsqmc::DistanceTable</class>
    <class kind="struct">ohmmsqmc::TempDisplacement</class>
    <class kind="class">ohmmsqmc::DistanceTableData</class>
    <class kind="class">ohmmsqmc::HDFWalkerOutput</class>
    <class kind="class">ohmmsqmc::HDFWalkerInput</class>
    <class kind="class">ohmmsqmc::MCWalkerConfiguration</class>
    <class kind="class">ohmmsqmc::ParticleSet</class>
    <class kind="struct">ohmmsqmc::SymmetricDTD</class>
    <class kind="struct">ohmmsqmc::Walker</class>
    <class kind="struct">ohmmsqmc::HePresetHF</class>
    <class kind="struct">ohmmsqmc::HePresetHFBuilder</class>
    <class kind="struct">ohmmsqmc::ComboSTO</class>
    <class kind="struct">ohmmsqmc::HFAtomicSTOSet</class>
    <class kind="class">ohmmsqmc::HFAtomicSTOSetBuilder</class>
    <class kind="struct">ohmmsqmc::DetSetBuilderWithBasisSet</class>
    <class kind="struct">ohmmsqmc::DiracDeterminant</class>
    <class kind="struct">ohmmsqmc::JastrowBuilder</class>
    <class kind="class">ohmmsqmc::LCOrbitals</class>
    <class kind="class">ohmmsqmc::MixedSPOSet</class>
    <class kind="struct">ohmmsqmc::PadeOrbital</class>
    <class kind="struct">ohmmsqmc::Any2GridBuilder</class>
    <class kind="class">ohmmsqmc::GridMolecularOrbitals</class>
    <class kind="struct">ohmmsqmc::GTO2GridBuilder</class>
    <class kind="class">ohmmsqmc::GTOMolecularOrbitals</class>
    <class kind="class">ohmmsqmc::MolecularOrbitalBasis</class>
    <class kind="struct">ohmmsqmc::MolecularOrbitalBuilder</class>
    <class kind="class">ohmmsqmc::NumericalMolecularOrbitals</class>
    <class kind="struct">ohmmsqmc::NumericalRGFBuilder</class>
    <class kind="struct">ohmmsqmc::RGFBuilderBase</class>
    <class kind="struct">ohmmsqmc::STO2GridBuilder</class>
    <class kind="class">ohmmsqmc::STOMolecularOrbitals</class>
    <class kind="class">ohmmsqmc::MultiSlaterDeterminant</class>
    <class kind="class">ohmmsqmc::NumericalOrbitalSetBuilder</class>
    <class kind="class">ohmmsqmc::OneBodyJastrow</class>
    <class kind="struct">ohmmsqmc::OrbitalBase</class>
    <class kind="class">ohmmsqmc::OrbitalBuilderBase</class>
    <class kind="class">ohmmsqmc::PolarizedJastrow</class>
    <class kind="class">ohmmsqmc::QDwfBuilder</class>
    <class kind="struct">ohmmsqmc::SingleParticleOrbitalSet</class>
    <class kind="class">ohmmsqmc::SlaterDeterminant</class>
    <class kind="struct">ohmmsqmc::DummyGrid</class>
    <class kind="struct">ohmmsqmc::SphericalOrbitalSet</class>
    <class kind="class">ohmmsqmc::Spline3DBuilder</class>
    <class kind="struct">ohmmsqmc::SPOSetBase</class>
    <class kind="class">ohmmsqmc::TrialWaveFunction</class>
    <class kind="class">ohmmsqmc::TriCubicSplineBuilder</class>
    <class kind="class">ohmmsqmc::TwoBodyJastrow</class>
    <class kind="class">ohmmsqmc::TwoBodyJastrow&lt; FT, false &gt;</class>
    <class kind="class">ohmmsqmc::TwoBodyJastrow&lt; FT, true &gt;</class>
    <class kind="struct">ohmmsqmc::BareKineticEnergy</class>
    <class kind="struct">ohmmsqmc::ConservedEnergy</class>
    <class kind="struct">ohmmsqmc::CoulombPotentialAB</class>
    <class kind="struct">ohmmsqmc::CoulombPotentialAA</class>
    <class kind="struct">ohmmsqmc::EffMKineticEnergy</class>
    <class kind="struct">ohmmsqmc::HarmonicPotential</class>
    <class kind="struct">ohmmsqmc::IonIonPotential</class>
    <class kind="struct">ohmmsqmc::LocalCorePolPotential</class>
    <class kind="struct">ohmmsqmc::LocalPPotential</class>
    <class kind="struct">ohmmsqmc::NonLocalPPotential</class>
    <class kind="struct">ohmmsqmc::PolarizationPotential</class>
    <class kind="class">ohmmsqmc::QMCHamiltonian</class>
    <class kind="struct">ohmmsqmc::QMCHamiltonianBase</class>
    <class kind="struct">ohmmsqmc::Spline3DPotential</class>
    <class kind="struct">ohmmsqmc::TriCubicSplinePotential</class>
    <class kind="class">ohmmsqmc::LocalEnergyEstimator</class>
    <class kind="struct">ohmmsqmc::MultipleEnergyEstimator</class>
    <class kind="class">ohmmsqmc::PolarizationEstimator</class>
    <class kind="struct">ohmmsqmc::ScalarEstimatorBase</class>
    <class kind="class">ohmmsqmc::ScalarEstimatorManager</class>
    <class kind="class">ohmmsqmc::DMCParticleByParticle</class>
    <class kind="class">ohmmsqmc::DummyQMC</class>
    <class kind="class">ohmmsqmc::MolecuDMC</class>
    <class kind="class">ohmmsqmc::MolecuFixedNodeBranch</class>
    <class kind="struct">ohmmsqmc::Bead</class>
    <class kind="struct">ohmmsqmc::MultiChain</class>
    <class kind="struct">ohmmsqmc::PolymerChain</class>
    <class kind="class">ohmmsqmc::PolymerEstimator</class>
    <class kind="class">ohmmsqmc::QMCDriver</class>
    <class kind="class">ohmmsqmc::ReptationMC</class>
    <class kind="class">ohmmsqmc::RQMCMultiple</class>
    <class kind="class">ohmmsqmc::VMC</class>
    <class kind="class">ohmmsqmc::VMC_OPT</class>
    <class kind="class">ohmmsqmc::VMCMoveAll</class>
    <class kind="class">ohmmsqmc::VMCMultiple</class>
    <class kind="class">ohmmsqmc::VMCParticleByParticle</class>
    <class kind="class">ohmmsqmc::VMCPbyPMultiple</class>
    <class kind="class">ohmmsqmc::WaveFunctionTester</class>
    <class kind="class">ohmmsqmc::HamiltonianPool</class>
    <class kind="class">ohmmsqmc::InitMolecularSystem</class>
    <class kind="struct">ohmmsqmc::BasisGroupType</class>
    <class kind="class">ohmmsqmc::MO2Grid3D</class>
    <class kind="class">ohmmsqmc::ParticleSetPool</class>
    <class kind="class">ohmmsqmc::QMCAppBase</class>
    <class kind="class">ohmmsqmc::QMCMain</class>
    <class kind="class">ohmmsqmc::WaveFunctionPool</class>
    <member kind="typedef">
      <type>TinyVector&lt; int, 4 &gt;</type>
      <name>QuantumNumberType</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LOGPSI</name>
      <anchor>a15a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SIGN</name>
      <anchor>a15a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>UMBRELLAWEIGHT</name>
      <anchor>a15a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LOCALENERGY</name>
      <anchor>a15a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LOCALPOTENTIAL</name>
      <anchor>a15a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>NUMPROPERTIES</name>
      <anchor>a15a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>q_n</name>
      <anchor>a16a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>q_l</name>
      <anchor>a16a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>q_m</name>
      <anchor>a16a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>q_s</name>
      <anchor>a16a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a11</anchor>
      <arglist>(ostream &amp;out, const Walker&lt; T, PA &gt; &amp;rhs)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a12</anchor>
      <arglist>(std::ostream &amp;out, const ComboSTO&lt; T, POS &gt; &amp;asto)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>determineNumOfElectrons</name>
      <anchor>a13</anchor>
      <arglist>(ParticleSet &amp;el, xmlXPathContextPtr acontext)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>delete_iter</name>
      <anchor>a14</anchor>
      <arglist>(IT first, IT last)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::AsymmetricDTD</name>
    <filename>structohmmsqmc_1_1AsymmetricDTD.html</filename>
    <templarg>BC</templarg>
    <base>ohmmsqmc::DistanceTableData</base>
    <member kind="function">
      <type></type>
      <name>AsymmetricDTD</name>
      <anchor>a0</anchor>
      <arglist>(const ParticleSet &amp;source, const ParticleSet &amp;target)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>create</name>
      <anchor>a1</anchor>
      <arglist>(int walkers)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>(int n1, int n2, int nactive)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(const WalkerSetRef &amp;W)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(const ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>move</name>
      <anchor>a5</anchor>
      <arglist>(const ParticleSet &amp;P, const PosType &amp;rnew, IndexType jat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a6</anchor>
      <arglist>(IndexType jat)</arglist>
    </member>
    <member kind="variable">
      <type>const ParticleSet &amp;</type>
      <name>Target</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::DistanceTable</name>
    <filename>classohmmsqmc_1_1DistanceTable.html</filename>
    <member kind="typedef">
      <type>ParticleSet::Scalar_t</type>
      <name>RealType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSet::SingleParticlePos_t</type>
      <name>PosType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>static int</type>
      <name>add</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleSet &amp;s, const char *aname=NULL)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static int</type>
      <name>add</name>
      <anchor>e1</anchor>
      <arglist>(const ParticleSet &amp;s, const ParticleSet &amp;t, const char *aname=NULL)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static DistanceTableData *</type>
      <name>getTable</name>
      <anchor>e2</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static DistanceTableData *</type>
      <name>getTable</name>
      <anchor>e3</anchor>
      <arglist>(const char *atable)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>getTables</name>
      <anchor>e4</anchor>
      <arglist>(int ptag, vector&lt; DistanceTableData * &gt; &amp;tables)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>reset</name>
      <anchor>e5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>create</name>
      <anchor>e6</anchor>
      <arglist>(int walkers)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static bool</type>
      <name>updated</name>
      <anchor>e7</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>update</name>
      <anchor>e8</anchor>
      <arglist>(ParticleSet &amp;t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>update</name>
      <anchor>e9</anchor>
      <arglist>(WalkerSetRef &amp;t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>registerData</name>
      <anchor>e10</anchor>
      <arglist>(PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>copyFromBuffer</name>
      <anchor>e11</anchor>
      <arglist>(PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>static void</type>
      <name>copyToBuffer</name>
      <anchor>e12</anchor>
      <arglist>(PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>DistanceTable</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>static vector&lt; bool &gt;</type>
      <name>Updated</name>
      <anchor>z1_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>static vector&lt; DistanceTableData * &gt;</type>
      <name>TableList</name>
      <anchor>z1_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>static vector&lt; int &gt;</type>
      <name>VisitorID</name>
      <anchor>z1_2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>static map&lt; string, int &gt;</type>
      <name>TableMap</name>
      <anchor>z1_3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::TempDisplacement</name>
    <filename>structohmmsqmc_1_1TempDisplacement.html</filename>
    <templarg>T</templarg>
    <templarg>N</templarg>
    <member kind="function">
      <type></type>
      <name>TempDisplacement</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>r0</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>r1</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>rinv0</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>rinv1</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>TinyVector&lt; T, N &gt;</type>
      <name>dr0</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>TinyVector&lt; T, N &gt;</type>
      <name>dr1</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::DistanceTableData</name>
    <filename>classohmmsqmc_1_1DistanceTableData.html</filename>
    <base>QMCTraits</base>
    <member kind="typedef">
      <type>std::vector&lt; IndexType &gt;</type>
      <name>IndexVectorType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TempDisplacement&lt; RealType, 3 &gt;</type>
      <name>TempDistType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PooledData&lt; RealType &gt;</type>
      <name>BufferType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>WalkerIndex</name>
      <anchor>w7w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SourceIndex</name>
      <anchor>w7w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>VisitorIndex</name>
      <anchor>w7w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>PairIndex</name>
      <anchor>w7w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DistanceTableData</name>
      <anchor>a0</anchor>
      <arglist>(const ParticleSet &amp;source, const ParticleSet &amp;target)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~DistanceTableData</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const ParticleSet &amp;</type>
      <name>origin</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>IndexType</type>
      <name>centers</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>IndexType</type>
      <name>size</name>
      <anchor>a4</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>IndexType</type>
      <name>getTotNadj</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>IndexType</type>
      <name>nadj</name>
      <anchor>a6</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>IndexType</type>
      <name>iadj</name>
      <anchor>a7</anchor>
      <arglist>(int i, int j) const </arglist>
    </member>
    <member kind="function">
      <type>IndexType</type>
      <name>loc</name>
      <anchor>a8</anchor>
      <arglist>(int i, int j) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>evaluate</name>
      <anchor>a9</anchor>
      <arglist>(const WalkerSetRef &amp;W)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>evaluate</name>
      <anchor>a10</anchor>
      <arglist>(const ParticleSet &amp;P)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>move</name>
      <anchor>a11</anchor>
      <arglist>(const ParticleSet &amp;P, const PosType &amp;rnew, IndexType jat)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>update</name>
      <anchor>a12</anchor>
      <arglist>(IndexType jat)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>create</name>
      <anchor>a13</anchor>
      <arglist>(int walkers)=0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>registerData</name>
      <anchor>a14</anchor>
      <arglist>(BufferType &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyToBuffer</name>
      <anchor>a15</anchor>
      <arglist>(BufferType &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyFromBuffer</name>
      <anchor>a16</anchor>
      <arglist>(BufferType &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>print</name>
      <anchor>a17</anchor>
      <arglist>(std::ostream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>PosType</type>
      <name>dr</name>
      <anchor>z5_0</anchor>
      <arglist>(int iw, int iat) const </arglist>
    </member>
    <member kind="function">
      <type>RealType</type>
      <name>r</name>
      <anchor>z5_1</anchor>
      <arglist>(int iw, int iat) const </arglist>
    </member>
    <member kind="function">
      <type>RealType</type>
      <name>rinv</name>
      <anchor>z5_2</anchor>
      <arglist>(int iw, int iat) const </arglist>
    </member>
    <member kind="function">
      <type>PosType</type>
      <name>dr</name>
      <anchor>z5_3</anchor>
      <arglist>(int j) const </arglist>
    </member>
    <member kind="function">
      <type>RealType</type>
      <name>r</name>
      <anchor>z5_4</anchor>
      <arglist>(int j) const </arglist>
    </member>
    <member kind="function">
      <type>RealType</type>
      <name>rinv</name>
      <anchor>z5_5</anchor>
      <arglist>(int j) const </arglist>
    </member>
    <member kind="variable">
      <type>std::bitset&lt; 4 &gt;</type>
      <name>Status</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>IndexType</type>
      <name>activePtcl</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>TinyVector&lt; IndexType, 3 &gt;</type>
      <name>N</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>IndexVectorType</type>
      <name>M</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>IndexVectorType</type>
      <name>J</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>IndexVectorType</type>
      <name>PairID</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; IndexType &gt;</type>
      <name>IJ</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; TempDistType &gt;</type>
      <name>Temp</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>resize</name>
      <anchor>b0</anchor>
      <arglist>(int npairs, int nw=1)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>const ParticleSet &amp;</type>
      <name>Origin</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>npairs_m</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Matrix&lt; PosType &gt;</type>
      <name>dr2_m</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Matrix&lt; RealType &gt;</type>
      <name>r2_m</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Matrix&lt; RealType &gt;</type>
      <name>rinv2_m</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>std::vector&lt; PosType &gt;</type>
      <name>dr_m</name>
      <anchor>z6_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>std::vector&lt; RealType &gt;</type>
      <name>r_m</name>
      <anchor>z6_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>std::vector&lt; RealType &gt;</type>
      <name>rinv_m</name>
      <anchor>z6_2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>DistanceTableData</name>
      <anchor>d0</anchor>
      <arglist>(const DistanceTableData &amp;a)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::HDFWalkerOutput</name>
    <filename>classohmmsqmc_1_1HDFWalkerOutput.html</filename>
    <member kind="function">
      <type></type>
      <name>HDFWalkerOutput</name>
      <anchor>a0</anchor>
      <arglist>(const string &amp;fname, bool append=true)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HDFWalkerOutput</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a2</anchor>
      <arglist>(MCWalkerConfiguration &amp;)</arglist>
    </member>
    <member kind="function">
      <type>hid_t</type>
      <name>getGroupID</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>AppendMode</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>Counter</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>hid_t</type>
      <name>h_file</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>hid_t</type>
      <name>h_config</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::HDFWalkerInput</name>
    <filename>classohmmsqmc_1_1HDFWalkerInput.html</filename>
    <member kind="function">
      <type></type>
      <name>HDFWalkerInput</name>
      <anchor>a0</anchor>
      <arglist>(const string &amp;fname)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HDFWalkerInput</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(MCWalkerConfiguration &amp;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(MCWalkerConfiguration &amp;, int ic)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>Counter</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>hsize_t</type>
      <name>NumSets</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>hid_t</type>
      <name>h_file</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>hid_t</type>
      <name>h_config</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::MCWalkerConfiguration</name>
    <filename>classohmmsqmc_1_1MCWalkerConfiguration.html</filename>
    <base>ohmmsqmc::ParticleSet</base>
    <member kind="typedef">
      <type>Walker&lt; RealType, ParticlePos_t &gt;</type>
      <name>Walker_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Walker_t::PropertyContainer_t</type>
      <name>PropertyContainer_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::vector&lt; Walker_t * &gt;</type>
      <name>WalkerList_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>WalkerList_t::iterator</type>
      <name>iterator</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>WalkerList_t::const_iterator</type>
      <name>const_iterator</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Update_All</name>
      <anchor>w8w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Update_Walker</name>
      <anchor>w8w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Update_Particle</name>
      <anchor>w8w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MCWalkerConfiguration</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MCWalkerConfiguration</name>
      <anchor>a1</anchor>
      <arglist>(const MCWalkerConfiguration &amp;mcw)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MCWalkerConfiguration</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>createWalkers</name>
      <anchor>a3</anchor>
      <arglist>(int numWalkers)</arglist>
    </member>
    <member kind="function">
      <type>iterator</type>
      <name>destroyWalkers</name>
      <anchor>a4</anchor>
      <arglist>(iterator first, iterator last)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyWalkerRefs</name>
      <anchor>a5</anchor>
      <arglist>(Walker_t *head, Walker_t *tail)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a6</anchor>
      <arglist>(int numWalkers, int numPtcls)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>sample</name>
      <anchor>a7</anchor>
      <arglist>(iterator it, RealType tauinv)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getActiveWalkers</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getParticleNum</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>iterator</type>
      <name>begin</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>iterator</type>
      <name>end</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>begin</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>end</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUpdateMode</name>
      <anchor>a14</anchor>
      <arglist>(int updatemode)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLocalEnergy</name>
      <anchor>a15</anchor>
      <arglist>(RealType e)</arglist>
    </member>
    <member kind="function">
      <type>RealType</type>
      <name>getLocalEnergy</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>branch</name>
      <anchor>a17</anchor>
      <arglist>(int maxcopy, int Nmax, int Nmin)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a18</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>loadWalker</name>
      <anchor>a19</anchor>
      <arglist>(Walker_t &amp;awalker)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>createAuxDataSet</name>
      <anchor>a20</anchor>
      <arglist>(int nfield=256)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>registerData</name>
      <anchor>a21</anchor>
      <arglist>(Walker_t &amp;awalker, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyToBuffer</name>
      <anchor>a22</anchor>
      <arglist>(PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyFromBuffer</name>
      <anchor>a23</anchor>
      <arglist>(PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resetWalkerProperty</name>
      <anchor>a24</anchor>
      <arglist>(int ncopy=1)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>OwnWalkers</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>ReadyForPbyP</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>UpdateMode</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>RealType</type>
      <name>LocalEnergy</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>WalkerList_t</type>
      <name>WalkerList</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>initPropertyList</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::ParticleSet</name>
    <filename>classohmmsqmc_1_1ParticleSet.html</filename>
    <base>QMCTraits</base>
    <base>OhmmsElementBase</base>
    <base>ParticleBase&lt; PtclOnLatticeTraits &gt;</base>
    <member kind="typedef">
      <type>ParticleAttrib&lt; GradType &gt;</type>
      <name>ParticleGradient_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleAttrib&lt; ValueType &gt;</type>
      <name>ParticleLaplacian_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleSet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleSet</name>
      <anchor>a1</anchor>
      <arglist>(const ParticleSet &amp;p)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParticleSet</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a3</anchor>
      <arglist>(ostream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(istream &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a6</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a7</anchor>
      <arglist>(int iflag=0)</arglist>
    </member>
    <member kind="function">
      <type>SpeciesSet &amp;</type>
      <name>getSpeciesSet</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const SpeciesSet &amp;</type>
      <name>getSpeciesSet</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>tag</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>SingleParticlePos_t</type>
      <name>makeMove</name>
      <anchor>a11</anchor>
      <arglist>(Index_t iat, const SingleParticlePos_t &amp;displ)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>acceptMove</name>
      <anchor>a12</anchor>
      <arglist>(Index_t iat)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>addProperty</name>
      <anchor>a13</anchor>
      <arglist>(const string &amp;pname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>convert</name>
      <anchor>a14</anchor>
      <arglist>(const ParticlePos_t &amp;pin, ParticlePos_t &amp;pout)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>convert2Unit</name>
      <anchor>a15</anchor>
      <arglist>(const ParticlePos_t &amp;pin, ParticlePos_t &amp;pout)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>convert2Cart</name>
      <anchor>a16</anchor>
      <arglist>(const ParticlePos_t &amp;pin, ParticlePos_t &amp;pout)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>convert2Unit</name>
      <anchor>a17</anchor>
      <arglist>(ParticlePos_t &amp;pout)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>convert2Cart</name>
      <anchor>a18</anchor>
      <arglist>(ParticlePos_t &amp;pout)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>applyBC</name>
      <anchor>a19</anchor>
      <arglist>(const ParticlePos_t &amp;pin, ParticlePos_t &amp;pout)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>applyBC</name>
      <anchor>a20</anchor>
      <arglist>(ParticlePos_t &amp;pos)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>applyBC</name>
      <anchor>a21</anchor>
      <arglist>(const ParticlePos_t &amp;pin, ParticlePos_t &amp;pout, int first, int last)</arglist>
    </member>
    <member kind="variable">
      <type>ParticleGradient_t</type>
      <name>G</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleLaplacian_t</type>
      <name>L</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SpeciesSet</type>
      <name>mySpecies</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>initParticleSet</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Index_t</type>
      <name>ObjectTag</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Index_t</type>
      <name>activePtcl</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>SingleParticlePos_t</type>
      <name>activePos</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; DistanceTableData * &gt;</type>
      <name>DistTables</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>RecordNamedProperty&lt; RealType &gt;</type>
      <name>PropertyList</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected" static="yes">
      <type>static Index_t</type>
      <name>PtclObjectCounter</name>
      <anchor>t0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::SymmetricDTD</name>
    <filename>structohmmsqmc_1_1SymmetricDTD.html</filename>
    <templarg>BC</templarg>
    <base>ohmmsqmc::DistanceTableData</base>
    <member kind="function">
      <type></type>
      <name>SymmetricDTD</name>
      <anchor>a0</anchor>
      <arglist>(const ParticleSet &amp;source, const ParticleSet &amp;target)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>create</name>
      <anchor>a1</anchor>
      <arglist>(int walkers)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>(int m, int nactive)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(const WalkerSetRef &amp;W)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(const ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>move</name>
      <anchor>a5</anchor>
      <arglist>(const ParticleSet &amp;P, const PosType &amp;rnew, IndexType jat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a6</anchor>
      <arglist>(IndexType jat)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::Walker</name>
    <filename>structohmmsqmc_1_1Walker.html</filename>
    <templarg>T</templarg>
    <templarg>PA</templarg>
    <templarg>GA</templarg>
    <member kind="typedef">
      <type>Matrix&lt; T &gt;</type>
      <name>PropertyContainer_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PooledData&lt; T &gt;</type>
      <name>Buffer_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Walker</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Walker</name>
      <anchor>a1</anchor>
      <arglist>(int nptcl)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Walker</name>
      <anchor>a2</anchor>
      <arglist>(const Walker &amp;a)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Walker</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Walker &amp;</type>
      <name>operator=</name>
      <anchor>a4</anchor>
      <arglist>(const Walker &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a6</anchor>
      <arglist>(int nptcl)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>makeCopy</name>
      <anchor>a7</anchor>
      <arglist>(const Walker &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>T *restrict</type>
      <name>getPropertyBase</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const T *restrict</type>
      <name>getPropertyBase</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T *restrict</type>
      <name>getPropertyBase</name>
      <anchor>a10</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>const T *restrict</type>
      <name>getPropertyBase</name>
      <anchor>a11</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resetProperty</name>
      <anchor>a12</anchor>
      <arglist>(T logpsi, T sigN, T ene)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>willDie</name>
      <anchor>a13</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resizeProperty</name>
      <anchor>a15</anchor>
      <arglist>(int n, int m)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>ID</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Age</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Weight</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Multiplicity</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>PropertyContainer_t</type>
      <name>Properties</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>PA</type>
      <name>R</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>GA</type>
      <name>Drift</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Buffer_t</type>
      <name>DataSet</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::HePresetHF</name>
    <filename>structohmmsqmc_1_1HePresetHF.html</filename>
    <base>QMCTraits</base>
    <member kind="enumvalue">
      <name>N</name>
      <anchor>w1w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HePresetHF</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resizeByWalkers</name>
      <anchor>a2</anchor>
      <arglist>(int nw)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(const ParticleSet &amp;P, int iat, VV &amp;phi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(const ParticleSet &amp;P, int iat, VV &amp;phi, GV &amp;dphi, VV &amp;d2phi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(const ParticleSet &amp;P, int first, int last, VM &amp;logdet, GM &amp;dlogdet, VM &amp;d2logdet)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a6</anchor>
      <arglist>(const WalkerSetRef &amp;W, int first, int last, vector&lt; VM &gt; &amp;logdet, vector&lt; GM &gt; &amp;dlogdet, vector&lt; VM &gt; &amp;d2logdet)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTable</name>
      <anchor>a7</anchor>
      <arglist>(DistanceTableData *dtable)</arglist>
    </member>
    <member kind="variable">
      <type>TinyVector&lt; RealType, N &gt;</type>
      <name>C</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>TinyVector&lt; RealType, N &gt;</type>
      <name>Z</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>TinyVector&lt; RealType, N &gt;</type>
      <name>ZZ</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DistanceTableData *</type>
      <name>myTable</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::HePresetHFBuilder</name>
    <filename>structohmmsqmc_1_1HePresetHFBuilder.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>HePresetHFBuilder</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;els, TrialWaveFunction &amp;wfs, ParticleSet &amp;ions)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::ComboSTO</name>
    <filename>structohmmsqmc_1_1ComboSTO.html</filename>
    <templarg>T</templarg>
    <templarg>POS</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SphericalTensor&lt; T, POS &gt;</type>
      <name>SphericalHarmonics_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>GenericSTO&lt; T &gt;</type>
      <name>RadialOrbital_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ComboSTO</name>
      <anchor>a0</anchor>
      <arglist>(const ComboSTO &amp;aSTO)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ComboSTO</name>
      <anchor>a1</anchor>
      <arglist>(int lm, SphericalHarmonics_t &amp;ylm, const vector&lt; RadialOrbital_t * &gt; &amp;rnl, T *c)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>f</name>
      <anchor>a2</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>df</name>
      <anchor>a3</anchor>
      <arglist>(T r)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(T r, T rinv, T &amp;drnl, T &amp;d2rnl)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>operator()</name>
      <anchor>a6</anchor>
      <arglist>(T r, T rinv, const POS &amp;dr, POS &amp;dy, T &amp;d2y)</arglist>
    </member>
    <member kind="variable">
      <type>string</type>
      <name>Name</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>LM</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SphericalHarmonics_t &amp;</type>
      <name>Ylm</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; RadialOrbital_t * &gt;</type>
      <name>Rnl</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; T &gt;</type>
      <name>C</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::HFAtomicSTOSet</name>
    <filename>structohmmsqmc_1_1HFAtomicSTOSet.html</filename>
    <base>QMCTraits</base>
    <member kind="typedef">
      <type>SphericalTensor&lt; RealType, PosType &gt;</type>
      <name>SphericalHarmonics_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>GenericSTO&lt; RealType &gt;</type>
      <name>RadialOrbital_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ComboSTO&lt; RealType, PosType &gt;</type>
      <name>SPO_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HFAtomicSTOSet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HFAtomicSTOSet</name>
      <anchor>a1</anchor>
      <arglist>(int lmax)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resizeByWalkers</name>
      <anchor>a3</anchor>
      <arglist>(int nw)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(const ParticleSet &amp;P, int iat, VV &amp;phi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a6</anchor>
      <arglist>(const ParticleSet &amp;P, int iat, VV &amp;phi, GV &amp;dphi, VV &amp;d2phi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a7</anchor>
      <arglist>(const ParticleSet &amp;P, int first, int last, VM &amp;logdet, GM &amp;dlogdet, VM &amp;d2logdet)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a8</anchor>
      <arglist>(const WalkerSetRef &amp;W, int first, int last, vector&lt; VM &gt; &amp;logdet, vector&lt; GM &gt; &amp;dlogdet, vector&lt; VM &gt; &amp;d2logdet)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTable</name>
      <anchor>a9</anchor>
      <arglist>(DistanceTableData *dtable)</arglist>
    </member>
    <member kind="variable">
      <type>SphericalHarmonics_t</type>
      <name>Ylm</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; RadialOrbital_t * &gt;</type>
      <name>RnlPool</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; SPO_t * &gt;</type>
      <name>Orbital</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>const DistanceTableData *</type>
      <name>myTable</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::HFAtomicSTOSetBuilder</name>
    <filename>classohmmsqmc_1_1HFAtomicSTOSetBuilder.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>HFAtomicSTOSetBuilder</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;els, TrialWaveFunction &amp;psi, ParticleSet &amp;ions)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr)</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>HFAtomicSTOSet::RadialOrbital_t</type>
      <name>RadialOrbital_t</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>HFAtomicSTOSet::SPO_t</type>
      <name>SPO_t</name>
      <anchor>y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>getBasis</name>
      <anchor>d0</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HFAtomicSTOSet *</type>
      <name>getOrbital</name>
      <anchor>d1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DistanceTableData *</type>
      <name>d_table</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>Lmax</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, int &gt;</type>
      <name>RnlID</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; RadialOrbital_t * &gt;</type>
      <name>Rnl</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, SPO_t * &gt;</type>
      <name>OrbSet</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::DetSetBuilderWithBasisSet</name>
    <filename>structohmmsqmc_1_1DetSetBuilderWithBasisSet.html</filename>
    <templarg>BasisBuilderT</templarg>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>DetSetBuilderWithBasisSet</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;p, TrialWaveFunction &amp;psi, BasisBuilderT &amp;abuilder)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>BasisBuilderT &amp;</type>
      <name>builder_ref</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumPtcl</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>string</type>
      <name>BasisName</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::DiracDeterminant</name>
    <filename>structohmmsqmc_1_1DiracDeterminant.html</filename>
    <templarg>SPOSet</templarg>
    <base>ohmmsqmc::OrbitalBase</base>
    <member kind="typedef">
      <type>Matrix&lt; ValueType &gt;</type>
      <name>Determinant_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matrix&lt; GradType &gt;</type>
      <name>Gradient_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matrix&lt; ValueType &gt;</type>
      <name>Laplacian_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DiracDeterminant</name>
      <anchor>a0</anchor>
      <arglist>(SPOSet &amp;spos, int first=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~DiracDeterminant</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DiracDeterminant</name>
      <anchor>a2</anchor>
      <arglist>(const DiracDeterminant&lt; SPOSet &gt; &amp;s)</arglist>
    </member>
    <member kind="function">
      <type>DiracDeterminant&lt; SPOSet &gt; &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const DiracDeterminant&lt; SPOSet &gt; &amp;s)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a4</anchor>
      <arglist>(int first, int nel)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a6</anchor>
      <arglist>(int nel, int morb)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>registerData</name>
      <anchor>a7</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyFromBuffer</name>
      <anchor>a8</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a9</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a10</anchor>
      <arglist>(ParticleSet &amp;P, int iat, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a11</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>restore</name>
      <anchor>a12</anchor>
      <arglist>(int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a13</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a14</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resizeByWalkers</name>
      <anchor>a15</anchor>
      <arglist>(int nwalkers)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rows</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>cols</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluateLog</name>
      <anchor>a18</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a19</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a20</anchor>
      <arglist>(WalkerSetRef &amp;W, ValueVectorType &amp;psi, WalkerSetRef::WalkerGradient_t &amp;G, WalkerSetRef::WalkerLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NP</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>FirstIndex</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>LastIndex</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SPOSet &amp;</type>
      <name>Phi</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>WorkingIndex</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ValueType</type>
      <name>CurrentDet</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Determinant_t</type>
      <name>psiM</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Determinant_t</type>
      <name>psiM_temp</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Determinant_t</type>
      <name>psiMinv</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Gradient_t</type>
      <name>dpsiM</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Gradient_t</type>
      <name>dpsiM_temp</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Laplacian_t</type>
      <name>d2psiM</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Laplacian_t</type>
      <name>d2psiM_temp</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; ValueType &gt;</type>
      <name>psiV</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; GradType &gt;</type>
      <name>dpsiV</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; ValueType &gt;</type>
      <name>d2psiV</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; ValueType &gt;</type>
      <name>workV1</name>
      <anchor>o16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; ValueType &gt;</type>
      <name>workV2</name>
      <anchor>o17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; Determinant_t &gt;</type>
      <name>psiM_v</name>
      <anchor>o18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; Gradient_t &gt;</type>
      <name>dpsiM_v</name>
      <anchor>o19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; Laplacian_t &gt;</type>
      <name>d2psiM_v</name>
      <anchor>o20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ValueType</type>
      <name>curRatio</name>
      <anchor>o21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ValueType</type>
      <name>cumRatio</name>
      <anchor>o22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ValueType *</type>
      <name>FirstAddressOfG</name>
      <anchor>o23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ValueType *</type>
      <name>LastAddressOfG</name>
      <anchor>o24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ValueType *</type>
      <name>FirstAddressOfdV</name>
      <anchor>o25</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ValueType *</type>
      <name>LastAddressOfdV</name>
      <anchor>o26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet::ParticleGradient_t</type>
      <name>myG</name>
      <anchor>o27</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet::ParticleGradient_t</type>
      <name>myG_temp</name>
      <anchor>o28</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet::ParticleLaplacian_t</type>
      <name>myL</name>
      <anchor>o29</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet::ParticleLaplacian_t</type>
      <name>myL_temp</name>
      <anchor>o30</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::JastrowBuilder</name>
    <filename>structohmmsqmc_1_1JastrowBuilder.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>JastrowBuilder</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;p, TrialWaveFunction &amp;psi, PtclPoolType &amp;psets)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>createTwoBodySpin</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur, JeeType *j2)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>createTwoBodyNoSpin</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur, JeeType *j2)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>createOneBody</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur, JneType *j1)</arglist>
    </member>
    <member kind="variable">
      <type>PtclPoolType &amp;</type>
      <name>ptclPool</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>string</type>
      <name>corr_tag</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::LCOrbitals</name>
    <filename>classohmmsqmc_1_1LCOrbitals.html</filename>
    <templarg>BS</templarg>
    <base>OhmmsElementBase</base>
    <member kind="typedef">
      <type>BS::RealType</type>
      <name>RealType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BS::ValueType</type>
      <name>ValueType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BS::PosType</type>
      <name>PosType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BS::GradType</type>
      <name>GradType</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LCOrbitals</name>
      <anchor>a0</anchor>
      <arglist>(BS *bs, int id)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LCOrbitals</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTable</name>
      <anchor>a2</anchor>
      <arglist>(DistanceTableData *atable)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>numOrbitals</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>numBasis</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a6</anchor>
      <arglist>(int nptcl)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resizeByWalkers</name>
      <anchor>a7</anchor>
      <arglist>(int nw)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a8</anchor>
      <arglist>(const ParticleSet &amp;P, int iat, int jorb)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a9</anchor>
      <arglist>(const ParticleSet &amp;P, int iat, VV &amp;psi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a10</anchor>
      <arglist>(const ParticleSet &amp;P, int iat, VV &amp;psi, GV &amp;dpsi, VV &amp;d2psi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a11</anchor>
      <arglist>(const ParticleSet &amp;P, int first, int last, VM &amp;logdet, GM &amp;dlogdet, VM &amp;d2logdet)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a12</anchor>
      <arglist>(const WalkerSetRef &amp;W, int first, int last, vector&lt; VM &gt; &amp;logdet, vector&lt; GM &gt; &amp;dlogdet, vector&lt; VM &gt; &amp;d2logdet)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a13</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a14</anchor>
      <arglist>(std::ostream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a15</anchor>
      <arglist>(std::istream &amp;)</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>Identity</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>ID</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumPtcls</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>BasisSize</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>BS *</type>
      <name>BasisSet</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; ValueType &gt;</type>
      <name>C</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::MixedSPOSet</name>
    <filename>classohmmsqmc_1_1MixedSPOSet.html</filename>
    <templarg>LOType</templarg>
    <base>QMCTraits</base>
    <member kind="typedef">
      <type>TriCubicSplineT&lt; ValueType, RealType &gt;</type>
      <name>NGOType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MixedSPOSet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MixedSPOSet</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a3</anchor>
      <arglist>(NGOType *ngorb)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLocalizedOrbitals</name>
      <anchor>a4</anchor>
      <arglist>(LOType *lo)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resizeByWalkers</name>
      <anchor>a6</anchor>
      <arglist>(int nw)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a7</anchor>
      <arglist>(const ParticleSet &amp;P, int iat, int jorb)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a8</anchor>
      <arglist>(const ParticleSet &amp;P, int iat, VV &amp;psi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a9</anchor>
      <arglist>(const ParticleSet &amp;P, int iat, VV &amp;psi, GV &amp;dpsi, VV &amp;d2psi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a10</anchor>
      <arglist>(const ParticleSet &amp;P, int first, int last, VM &amp;logdet, GM &amp;dlogdet, VM &amp;d2logdet)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a11</anchor>
      <arglist>(const WalkerSetRef &amp;W, int first, int last, vector&lt; VM &gt; &amp;logdet, vector&lt; GM &gt; &amp;dlogdet, vector&lt; VM &gt; &amp;d2logdet)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumberOfOrbitals</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>LOType *</type>
      <name>LocalizedOrbitals</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; NGOType * &gt;</type>
      <name>GridOrbitals</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::PadeOrbital</name>
    <filename>structohmmsqmc_1_1PadeOrbital.html</filename>
    <templarg>T</templarg>
    <base>RadialOrbitalBase</base>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PadeOrbital</name>
      <anchor>a0</anchor>
      <arglist>(const char *node_name=&quot;radfunc&quot;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PadeOrbital</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>f</name>
      <anchor>a3</anchor>
      <arglist>(value_type r) const </arglist>
    </member>
    <member kind="function">
      <type>value_type</type>
      <name>df</name>
      <anchor>a4</anchor>
      <arglist>(value_type r) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>putBasisGroup</name>
      <anchor>a5</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>a0</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>a1</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>a2</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>a3</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>rcut</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>nodeName</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::Any2GridBuilder</name>
    <filename>structohmmsqmc_1_1Any2GridBuilder.html</filename>
    <base>ohmmsqmc::RGFBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>Any2GridBuilder</name>
      <anchor>a0</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addRadialOrbital</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur, const QuantumNumberType &amp;nlms)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addGaussian</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addSlater</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addPade</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>Normalized</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>m_rcut</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>QuantumNumberType</type>
      <name>m_nlms</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::GridMolecularOrbitals</name>
    <filename>classohmmsqmc_1_1GridMolecularOrbitals.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="typedef">
      <type>OneDimGridBase&lt; ValueType &gt;</type>
      <name>GridType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OneDimGridFunctor&lt; ValueType &gt;</type>
      <name>RadialOrbitalType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SphericalOrbitalSet&lt; RadialOrbitalType, GridType &gt;</type>
      <name>CenteredOrbitalType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MolecularOrbitalBasis&lt; CenteredOrbitalType &gt;</type>
      <name>BasisSetType</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GridMolecularOrbitals</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;els, TrialWaveFunction &amp;psi, ParticleSet &amp;ions)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>BasisSetType *</type>
      <name>addBasisSet</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="enumvalue">
      <name>DONOT_EXPAND</name>
      <anchor>y3y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>GAUSSIAN_EXPAND</name>
      <anchor>y3y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>NATURAL_EXPAND</name>
      <anchor>y3y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>expandYlm</name>
      <anchor>d0</anchor>
      <arglist>(const string &amp;rnl, const QuantumNumberType &amp;nlms, int num, CenteredOrbitalType *aos, xmlNodePtr cur1, int expandlm=DONOT_EXPAND)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>BasisSetType *</type>
      <name>BasisSet</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DistanceTableData *</type>
      <name>d_table</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RGFBuilderBase *</type>
      <name>rbuilder</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, int &gt;</type>
      <name>RnlID</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, int &gt;</type>
      <name>CenterID</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, int &gt;</type>
      <name>nlms_id</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::GTO2GridBuilder</name>
    <filename>structohmmsqmc_1_1GTO2GridBuilder.html</filename>
    <base>ohmmsqmc::RGFBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>GTO2GridBuilder</name>
      <anchor>a0</anchor>
      <arglist>(bool normalized=false)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addRadialOrbital</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur, const QuantumNumberType &amp;nlms)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addGrid</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>Normalized</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::GTOMolecularOrbitals</name>
    <filename>classohmmsqmc_1_1GTOMolecularOrbitals.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="typedef">
      <type>GaussianCombo&lt; ValueType &gt;</type>
      <name>RadialOrbitalType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SphericalOrbitalSet&lt; RadialOrbitalType &gt;</type>
      <name>CenteredOrbitalType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MolecularOrbitalBasis&lt; CenteredOrbitalType &gt;</type>
      <name>BasisSetType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GTOMolecularOrbitals</name>
      <anchor>a0</anchor>
      <arglist>(TrialWaveFunction &amp;wfs, ParticleSet &amp;ions, ParticleSet &amp;els)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>BasisSetType *</type>
      <name>addBasisSet</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>BasisSetType *</type>
      <name>BasisSet</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DistanceTableData *</type>
      <name>d_table</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, int &gt;</type>
      <name>RnlID</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, int &gt;</type>
      <name>CenterID</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::MolecularOrbitalBasis</name>
    <filename>classohmmsqmc_1_1MolecularOrbitalBasis.html</filename>
    <templarg>COT</templarg>
    <base>QMCTraits</base>
    <member kind="function">
      <type></type>
      <name>MolecularOrbitalBasis</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTable</name>
      <anchor>a1</anchor>
      <arglist>(DistanceTableData *atable)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize</name>
      <anchor>a3</anchor>
      <arglist>(int nptcl)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resizeByWalkers</name>
      <anchor>a4</anchor>
      <arglist>(int nw)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(const ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a6</anchor>
      <arglist>(const ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluateAll</name>
      <anchor>a7</anchor>
      <arglist>(const ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a8</anchor>
      <arglist>(const WalkerSetRef &amp;W)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a9</anchor>
      <arglist>(COT *aos)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>print</name>
      <anchor>a10</anchor>
      <arglist>(std::ostream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>const ValueType *restrict</type>
      <name>y</name>
      <anchor>a11</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>const GradType *restrict</type>
      <name>dy</name>
      <anchor>a12</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>const ValueType *restrict</type>
      <name>d2y</name>
      <anchor>a13</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>const ValueType *restrict</type>
      <name>y</name>
      <anchor>a14</anchor>
      <arglist>(int iw, int ia)</arglist>
    </member>
    <member kind="function">
      <type>const GradType *restrict</type>
      <name>dy</name>
      <anchor>a15</anchor>
      <arglist>(int iw, int ia)</arglist>
    </member>
    <member kind="function">
      <type>const ValueType *restrict</type>
      <name>d2y</name>
      <anchor>a16</anchor>
      <arglist>(int iw, int ia)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumPtcls</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumWalkers</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>TotalBasis</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>I</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>Basis</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; COT * &gt;</type>
      <name>AOs</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; ValueType &gt;</type>
      <name>Y</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; GradType &gt;</type>
      <name>dY</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; ValueType &gt;</type>
      <name>d2Y</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DistanceTableData *</type>
      <name>myTable</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::MolecularOrbitalBuilder</name>
    <filename>structohmmsqmc_1_1MolecularOrbitalBuilder.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="typedef">
      <type>map&lt; string, ParticleSet * &gt;</type>
      <name>PtclPoolType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MolecularOrbitalBuilder</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;p, TrialWaveFunction &amp;psi, PtclPoolType &amp;psets)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>putSpecial</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>putOpen</name>
      <anchor>a3</anchor>
      <arglist>(const string &amp;fname_in)</arglist>
    </member>
    <member kind="variable">
      <type>PtclPoolType &amp;</type>
      <name>ptclPool</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::NumericalMolecularOrbitals</name>
    <filename>classohmmsqmc_1_1NumericalMolecularOrbitals.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>NumericalMolecularOrbitals</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;els, TrialWaveFunction &amp;wfs, ParticleSet &amp;ions)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GridMolecularOrbitals *</type>
      <name>Original</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::NumericalRGFBuilder</name>
    <filename>structohmmsqmc_1_1NumericalRGFBuilder.html</filename>
    <base>ohmmsqmc::RGFBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>NumericalRGFBuilder</name>
      <anchor>a0</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addGrid</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addRadialOrbital</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur, const QuantumNumberType &amp;nlms)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::RGFBuilderBase</name>
    <filename>structohmmsqmc_1_1RGFBuilderBase.html</filename>
    <base>QMCTraits</base>
    <member kind="typedef">
      <type>OneDimGridBase&lt; RealType &gt;</type>
      <name>GridType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OneDimGridFunctor&lt; ValueType &gt;</type>
      <name>RadialOrbitalType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SphericalOrbitalSet&lt; RadialOrbitalType, GridType &gt;</type>
      <name>CenteredOrbitalType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RGFBuilderBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RGFBuilderBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setOrbitalSet</name>
      <anchor>a2</anchor>
      <arglist>(CenteredOrbitalType *oset, const std::string &amp;acenter)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>addGrid</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>addRadialOrbital</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur, const QuantumNumberType &amp;nlms)=0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>print</name>
      <anchor>a5</anchor>
      <arglist>(const std::string &amp;aroot, int omode)</arglist>
    </member>
    <member kind="variable">
      <type>std::string</type>
      <name>m_species</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>CenteredOrbitalType *</type>
      <name>m_orbitals</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Counter</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>hid_t</type>
      <name>m_file_id</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>hid_t</type>
      <name>m_group_id</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::STO2GridBuilder</name>
    <filename>structohmmsqmc_1_1STO2GridBuilder.html</filename>
    <base>ohmmsqmc::RGFBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>STO2GridBuilder</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addRadialOrbital</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur, const QuantumNumberType &amp;nlms)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::STOMolecularOrbitals</name>
    <filename>classohmmsqmc_1_1STOMolecularOrbitals.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="typedef">
      <type>SlaterCombo&lt; RealType &gt;</type>
      <name>RadialOrbitalType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SphericalOrbitalSet&lt; RadialOrbitalType &gt;</type>
      <name>CenteredOrbitalType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MolecularOrbitalBasis&lt; CenteredOrbitalType &gt;</type>
      <name>BasisSetType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>STOMolecularOrbitals</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;els, TrialWaveFunction &amp;wfs, ParticleSet &amp;ions)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>BasisSetType *</type>
      <name>addBasisSet</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="enumvalue">
      <name>DONOT_EXPAND</name>
      <anchor>y3y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>GAUSSIAN_EXPAND</name>
      <anchor>y3y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>NATURAL_EXPAND</name>
      <anchor>y3y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>expandYlm</name>
      <anchor>d0</anchor>
      <arglist>(const string &amp;rnl, const QuantumNumberType &amp;nlms, int num, CenteredOrbitalType *aos, xmlNodePtr cur1, bool expandlm)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>Normalized</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>BasisSetType *</type>
      <name>BasisSet</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DistanceTableData *</type>
      <name>d_table</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, int &gt;</type>
      <name>RnlID</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, int &gt;</type>
      <name>CenterID</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, int &gt;</type>
      <name>nlms_id</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::MultiSlaterDeterminant</name>
    <filename>classohmmsqmc_1_1MultiSlaterDeterminant.html</filename>
    <templarg>SPOSet</templarg>
    <base>ohmmsqmc::OrbitalBase</base>
    <member kind="typedef">
      <type>SlaterDeterminant&lt; SPOSet &gt;</type>
      <name>DeterminantSet_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MultiSlaterDeterminant</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MultiSlaterDeterminant</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a2</anchor>
      <arglist>(DeterminantSet_t *sdet, RealType c)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initParameters</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluateLog</name>
      <anchor>a6</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a7</anchor>
      <arglist>(int i, int j) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a8</anchor>
      <arglist>(WalkerSetRef &amp;W, ValueVectorType &amp;psi, WalkerSetRef::WalkerGradient_t &amp;G, WalkerSetRef::WalkerLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>registerData</name>
      <anchor>a9</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyFromBuffer</name>
      <anchor>a10</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a11</anchor>
      <arglist>(ParticleSet &amp;P, int iat, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>restore</name>
      <anchor>a12</anchor>
      <arglist>(int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a13</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a14</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a15</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a16</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; DeterminantSet_t * &gt;</type>
      <name>SDets</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; RealType &gt;</type>
      <name>C</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::NumericalOrbitalSetBuilder</name>
    <filename>classohmmsqmc_1_1NumericalOrbitalSetBuilder.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="typedef">
      <type>GridMolecularOrbitals::BasisSetType</type>
      <name>MOBasisSetType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>LCOrbitals&lt; MOBasisSetType &gt;</type>
      <name>LOType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MixedSPOSet&lt; LOType &gt;</type>
      <name>SPOSetType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TriCubicSplineT&lt; ValueType, RealType &gt;</type>
      <name>NumericalOrbitalType</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>DiracDeterminant&lt; SPOSetType &gt;</type>
      <name>Det_t</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SlaterDeterminant&lt; SPOSetType &gt;</type>
      <name>SlaterDeterminant_t</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>NumericalOrbitalSetBuilder</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;p, TrialWaveFunction &amp;psi, PtclPoolType &amp;psets)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SlaterDeterminant_t *</type>
      <name>addSlaterDeterminant</name>
      <anchor>d0</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SPOSetType *</type>
      <name>createSPOSet</name>
      <anchor>d1</anchor>
      <arglist>(xmlNodePtr cur, const string &amp;ref, int norb)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GridMolecularOrbitals *</type>
      <name>LocalizedBasisBuilder</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PtclPoolType &amp;</type>
      <name>ptclPool</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>XYZCubicGrid&lt; RealType &gt; *</type>
      <name>GridXYZ</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MOBasisSetType *</type>
      <name>MOBasisSet</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, NumericalOrbitalType * &gt;</type>
      <name>NumericalOrbitals</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, LOType * &gt;</type>
      <name>LocalizedOrbitals</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, SPOSetType * &gt;</type>
      <name>SPOSet</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, Det_t * &gt;</type>
      <name>DetSet</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; SlaterDeterminant_t * &gt;</type>
      <name>SlaterDetSet</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::OneBodyJastrow</name>
    <filename>classohmmsqmc_1_1OneBodyJastrow.html</filename>
    <templarg>FT</templarg>
    <base>ohmmsqmc::OrbitalBase</base>
    <member kind="typedef">
      <type>FT</type>
      <name>FuncType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OneBodyJastrow</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;els, DistanceTableData *dt)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~OneBodyJastrow</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluateLog</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a5</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a6</anchor>
      <arglist>(ParticleSet &amp;P, int iat, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>restore</name>
      <anchor>a7</anchor>
      <arglist>(int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a8</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a9</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>registerData</name>
      <anchor>a10</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyFromBuffer</name>
      <anchor>a11</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a12</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a13</anchor>
      <arglist>(WalkerSetRef &amp;W, ValueVectorType &amp;psi, WalkerSetRef::WalkerGradient_t &amp;G, WalkerSetRef::WalkerLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; FT * &gt;</type>
      <name>F</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const DistanceTableData *</type>
      <name>d_table</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType</type>
      <name>curVal</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType</type>
      <name>curLap</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GradType</type>
      <name>curGrad</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueVectorType</type>
      <name>U</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueVectorType</type>
      <name>d2U</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GradVectorType</type>
      <name>dU</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType *</type>
      <name>FirstAddressOfdU</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType *</type>
      <name>LastAddressOfdU</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::OrbitalBase</name>
    <filename>structohmmsqmc_1_1OrbitalBase.html</filename>
    <base>QMCTraits</base>
    <member kind="typedef">
      <type>ParticleAttrib&lt; ValueType &gt;</type>
      <name>ValueVectorType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleAttrib&lt; GradType &gt;</type>
      <name>GradVectorType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SourceIndex</name>
      <anchor>w5w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>VisitorIndex</name>
      <anchor>w5w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>WalkerIndex</name>
      <anchor>w5w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OrbitalBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~OrbitalBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setOptimizable</name>
      <anchor>a2</anchor>
      <arglist>(bool optimizeit)</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>reset</name>
      <anchor>a3</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>resizeByWalkers</name>
      <anchor>a4</anchor>
      <arglist>(int nwalkers)</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual ValueType</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual ValueType</type>
      <name>evaluateLog</name>
      <anchor>a6</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>evaluate</name>
      <anchor>a7</anchor>
      <arglist>(WalkerSetRef &amp;W, ValueVectorType &amp;psi, WalkerSetRef::WalkerGradient_t &amp;G, WalkerSetRef::WalkerLaplacian_t &amp;L)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual ValueType</type>
      <name>ratio</name>
      <anchor>a8</anchor>
      <arglist>(ParticleSet &amp;P, int iat, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>update</name>
      <anchor>a9</anchor>
      <arglist>(ParticleSet &amp;P, int iat)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>restore</name>
      <anchor>a10</anchor>
      <arglist>(int iat)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual ValueType</type>
      <name>ratio</name>
      <anchor>a11</anchor>
      <arglist>(ParticleSet &amp;P, int iat)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>update</name>
      <anchor>a12</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL, int iat)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual ValueType</type>
      <name>evaluate</name>
      <anchor>a13</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual ValueType</type>
      <name>registerData</name>
      <anchor>a14</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>copyFromBuffer</name>
      <anchor>a15</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)=0</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>Optimizable</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ValueType</type>
      <name>LogValue</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ValueType</type>
      <name>SignValue</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::OrbitalBuilderBase</name>
    <filename>classohmmsqmc_1_1OrbitalBuilderBase.html</filename>
    <member kind="typedef">
      <type>TrialWaveFunction::RealType</type>
      <name>RealType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TrialWaveFunction::ValueType</type>
      <name>ValueType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TrialWaveFunction::PosType</type>
      <name>PosType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TrialWaveFunction::GradType</type>
      <name>GradType</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, ParticleSet * &gt;</type>
      <name>PtclPoolType</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OrbitalBuilderBase</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;p, TrialWaveFunction &amp;psi)</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)=0</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>wfs_tag</name>
      <anchor>ga3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>param_tag</name>
      <anchor>s1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>dtable_tag</name>
      <anchor>s2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>jastrow_tag</name>
      <anchor>s3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>detset_tag</name>
      <anchor>s4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>sd_tag</name>
      <anchor>s5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>det_tag</name>
      <anchor>s6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>spo_tag</name>
      <anchor>s7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>basisset_tag</name>
      <anchor>s8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>basis_tag</name>
      <anchor>s9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static std::string</type>
      <name>basisfunc_tag</name>
      <anchor>s10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ParticleSet &amp;</type>
      <name>targetPtcl</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>TrialWaveFunction &amp;</type>
      <name>targetPsi</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::PolarizedJastrow</name>
    <filename>classohmmsqmc_1_1PolarizedJastrow.html</filename>
    <base>ohmmsqmc::OrbitalBase</base>
    <member kind="function">
      <type></type>
      <name>PolarizedJastrow</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PolarizedJastrow</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur, VarRegistry&lt; RealType &gt; &amp;vlist)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluateLog</name>
      <anchor>a4</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a6</anchor>
      <arglist>(WalkerSetRef &amp;W, ValueVectorType &amp;psi, WalkerSetRef::WalkerGradient_t &amp;G, WalkerSetRef::WalkerLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a7</anchor>
      <arglist>(ParticleSet &amp;P, int iat, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>restore</name>
      <anchor>a8</anchor>
      <arglist>(int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a9</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a10</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a11</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a12</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>registerData</name>
      <anchor>a13</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyFromBuffer</name>
      <anchor>a14</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="variable">
      <type>ParameterSet</type>
      <name>m_param</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>alpha</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::QDwfBuilder</name>
    <filename>classohmmsqmc_1_1QDwfBuilder.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>QDwfBuilder</name>
      <anchor>a0</anchor>
      <arglist>(TrialWaveFunction &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>SingleParticleOrbitalSet&lt; QDwf &gt;</type>
      <name>SPOSet_t</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::SingleParticleOrbitalSet</name>
    <filename>structohmmsqmc_1_1SingleParticleOrbitalSet.html</filename>
    <templarg>OT</templarg>
    <member kind="typedef">
      <type>OT</type>
      <name>SPOrbital_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OT::value_type</type>
      <name>value_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SingleParticleOrbitalSet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>add</name>
      <anchor>a1</anchor>
      <arglist>(SPOrbital_t *afunction)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resizeByWalkers</name>
      <anchor>a3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(const PTCL &amp;P, int iat, VV &amp;psi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a6</anchor>
      <arglist>(const PTCL &amp;P, int iat, VV &amp;psi, GV &amp;dpsi, VV &amp;d2psi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a7</anchor>
      <arglist>(const PTCL &amp;P, int first, int last, VM &amp;logdet, GM &amp;dlogdet, VM &amp;d2logdet)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a8</anchor>
      <arglist>(const WREF &amp;W, int first, int last, vector&lt; VM &gt; &amp;logdet, vector&lt; GM &gt; &amp;dlogdet, vector&lt; VM &gt; &amp;d2logdet)</arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; SPOrbital_t * &gt;</type>
      <name>Phi</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::SlaterDeterminant</name>
    <filename>classohmmsqmc_1_1SlaterDeterminant.html</filename>
    <templarg>SPOSet</templarg>
    <base>ohmmsqmc::OrbitalBase</base>
    <member kind="typedef">
      <type>DiracDeterminant&lt; SPOSet &gt;</type>
      <name>Determinant_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SlaterDeterminant</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SlaterDeterminant</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a2</anchor>
      <arglist>(Determinant_t *det)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluateLog</name>
      <anchor>a5</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>resizeByWalkers</name>
      <anchor>a6</anchor>
      <arglist>(int nwalkers)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a8</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a9</anchor>
      <arglist>(WalkerSetRef &amp;W, ValueVectorType &amp;psi, WalkerSetRef::WalkerGradient_t &amp;G, WalkerSetRef::WalkerLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>registerData</name>
      <anchor>a10</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyFromBuffer</name>
      <anchor>a11</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a12</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a13</anchor>
      <arglist>(ParticleSet &amp;P, int iat, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>restore</name>
      <anchor>a14</anchor>
      <arglist>(int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a15</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a16</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a17</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL, int iat)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; int &gt;</type>
      <name>M</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Determinant_t * &gt;</type>
      <name>Dets</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::DummyGrid</name>
    <filename>structohmmsqmc_1_1DummyGrid.html</filename>
    <member kind="function">
      <type>void</type>
      <name>locate</name>
      <anchor>a0</anchor>
      <arglist>(double r)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::SphericalOrbitalSet</name>
    <filename>structohmmsqmc_1_1SphericalOrbitalSet.html</filename>
    <templarg>ROT</templarg>
    <templarg>GT</templarg>
    <member kind="typedef">
      <type>DistanceTableData::RealType</type>
      <name>RealType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>DistanceTableData::ValueType</type>
      <name>ValueType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>DistanceTableData::PosType</type>
      <name>PosType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>SphericalTensor&lt; ValueType, PosType &gt;</type>
      <name>SphericalHarmonics_t</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ROT</type>
      <name>RadialOrbital_t</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SphericalOrbitalSet</name>
      <anchor>a0</anchor>
      <arglist>(int lmax, bool addsignforM=false)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SphericalOrbitalSet</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>basis</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a3</anchor>
      <arglist>(DistanceTableData *atable)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a5</anchor>
      <arglist>(int source, int iat, int offset, VM &amp;y)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a6</anchor>
      <arglist>(int source, int iat, int offset, VM &amp;y, GM &amp;dy, VM &amp;d2y)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a7</anchor>
      <arglist>(int source, int first, int nptcl, int offset, VM &amp;y, GM &amp;dy, VM &amp;d2y)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluateW</name>
      <anchor>a8</anchor>
      <arglist>(int source, int first, int nptcl, int offset, int nw, int nstride, VM &amp;y, GM &amp;dy, VM &amp;d2y)</arglist>
    </member>
    <member kind="variable">
      <type>const DistanceTableData *</type>
      <name>myTable</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SphericalHarmonics_t</type>
      <name>Ylm</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>LM</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>NL</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; GT * &gt;</type>
      <name>Grids</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; ROT * &gt;</type>
      <name>Rnl</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; QuantumNumberType &gt;</type>
      <name>RnlID</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::Spline3DBuilder</name>
    <filename>classohmmsqmc_1_1Spline3DBuilder.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>Spline3DBuilder</name>
      <anchor>a0</anchor>
      <arglist>(TrialWaveFunction &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>Grid3D *</type>
      <name>getFullGrid</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>SingleParticleOrbitalSet&lt; Spline3D &gt;</type>
      <name>SPOSet_t</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Spline3DSet *</type>
      <name>d_orbitals</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Grid3D *</type>
      <name>grid_ref</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::SPOSetBase</name>
    <filename>structohmmsqmc_1_1SPOSetBase.html</filename>
    <base>QMCTraits</base>
    <member kind="typedef">
      <type>ParticleAttrib&lt; ValueType &gt;</type>
      <name>ValueVectorType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleAttrib&lt; GradType &gt;</type>
      <name>GradVectorType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SPOSetBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SPOSetBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::TrialWaveFunction</name>
    <filename>classohmmsqmc_1_1TrialWaveFunction.html</filename>
    <member kind="typedef">
      <type>OrbitalBase::RealType</type>
      <name>RealType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OrbitalBase::ValueType</type>
      <name>ValueType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OrbitalBase::PosType</type>
      <name>PosType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OrbitalBase::GradType</type>
      <name>GradType</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TrialWaveFunction</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TrialWaveFunction</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RealType</type>
      <name>getSign</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>getLogPsi</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a4</anchor>
      <arglist>(OrbitalBase *aterm)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resizeByWalkers</name>
      <anchor>a6</anchor>
      <arglist>(int nwalkers)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasSPOSet</name>
      <anchor>a7</anchor>
      <arglist>(const string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addSPOSet</name>
      <anchor>a8</anchor>
      <arglist>(OhmmsElementBase *spo)</arglist>
    </member>
    <member kind="function">
      <type>OhmmsElementBase *</type>
      <name>getSPOSet</name>
      <anchor>a9</anchor>
      <arglist>(const string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a10</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluateLog</name>
      <anchor>a11</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluateLog</name>
      <anchor>a12</anchor>
      <arglist>(ParticleSet &amp;P, bool all)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluateLog</name>
      <anchor>a13</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;fixedG, ParticleSet::ParticleLaplacian_t &amp;fixedL)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a14</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a15</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a16</anchor>
      <arglist>(ParticleSet &amp;P, int iat, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>restore</name>
      <anchor>a17</anchor>
      <arglist>(int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update2</name>
      <anchor>a18</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>registerData</name>
      <anchor>a19</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyFromBuffer</name>
      <anchor>a20</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a21</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a22</anchor>
      <arglist>(WalkerSetRef &amp;W, OrbitalBase::ValueVectorType &amp;psi)</arglist>
    </member>
    <member kind="variable">
      <type>VarRegistry&lt; RealType &gt;</type>
      <name>VarList</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet::ParticleGradient_t</type>
      <name>G</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet::ParticleLaplacian_t</type>
      <name>L</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>TrialWaveFunction</name>
      <anchor>d0</anchor>
      <arglist>(const TrialWaveFunction &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>TotalDim</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>WorkingPtcl</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RealType</type>
      <name>SignValue</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType</type>
      <name>LogValue</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; OrbitalBase * &gt;</type>
      <name>Z</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; OhmmsElementBase * &gt;</type>
      <name>SPOSet</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet::ParticleGradient_t</type>
      <name>delta_G</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet::ParticleLaplacian_t</type>
      <name>delta_L</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::TriCubicSplineBuilder</name>
    <filename>classohmmsqmc_1_1TriCubicSplineBuilder.html</filename>
    <base>ohmmsqmc::OrbitalBuilderBase</base>
    <member kind="function">
      <type></type>
      <name>TriCubicSplineBuilder</name>
      <anchor>a0</anchor>
      <arglist>(TrialWaveFunction &amp;a, Grid3D *agrid)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr)</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>SingleParticleOrbitalSet&lt; TriCubicSpline &gt;</type>
      <name>SPOSet_t</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>TriCubicSplineSet *</type>
      <name>m_orbitals</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Grid3D *</type>
      <name>grid_ref</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::TwoBodyJastrow</name>
    <filename>classohmmsqmc_1_1TwoBodyJastrow.html</filename>
    <templarg>FT</templarg>
    <templarg>SharedFunction</templarg>
    <base>ohmmsqmc::OrbitalBase</base>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::TwoBodyJastrow&lt; FT, false &gt;</name>
    <filename>classohmmsqmc_1_1TwoBodyJastrow_3_01FT_00_01false_01_4.html</filename>
    <templarg>FT</templarg>
    <base>ohmmsqmc::OrbitalBase</base>
    <member kind="typedef">
      <type>FT</type>
      <name>FuncType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TwoBodyJastrow</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;p, DistanceTableData *dtable)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TwoBodyJastrow</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluateLog</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a5</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a6</anchor>
      <arglist>(ParticleSet &amp;P, int iat, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>restore</name>
      <anchor>a7</anchor>
      <arglist>(int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a8</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a9</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>registerData</name>
      <anchor>a10</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyFromBuffer</name>
      <anchor>a11</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a12</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a13</anchor>
      <arglist>(WalkerSetRef &amp;W, ValueVectorType &amp;psi, WalkerSetRef::WalkerGradient_t &amp;G, WalkerSetRef::WalkerLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; FT * &gt;</type>
      <name>F</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const DistanceTableData *</type>
      <name>d_table</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>N</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>NN</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType</type>
      <name>DiffVal</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType</type>
      <name>DiffValSum</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueVectorType</type>
      <name>U</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueVectorType</type>
      <name>d2U</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueVectorType</type>
      <name>curLap</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueVectorType</type>
      <name>curVal</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GradVectorType</type>
      <name>dU</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GradVectorType</type>
      <name>curGrad</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType *</type>
      <name>FirstAddressOfdU</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType *</type>
      <name>LastAddressOfdU</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Matrix&lt; int &gt;</type>
      <name>PairID</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::TwoBodyJastrow&lt; FT, true &gt;</name>
    <filename>classohmmsqmc_1_1TwoBodyJastrow_3_01FT_00_01true_01_4.html</filename>
    <templarg>FT</templarg>
    <base>ohmmsqmc::OrbitalBase</base>
    <member kind="typedef">
      <type>FT</type>
      <name>FuncType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TwoBodyJastrow</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;p, DistanceTableData *dtable)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TwoBodyJastrow</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluateLog</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;G, ParticleSet::ParticleLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a5</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>ratio</name>
      <anchor>a6</anchor>
      <arglist>(ParticleSet &amp;P, int iat, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>restore</name>
      <anchor>a7</anchor>
      <arglist>(int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a8</anchor>
      <arglist>(ParticleSet &amp;P, int iat)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a9</anchor>
      <arglist>(ParticleSet &amp;P, ParticleSet::ParticleGradient_t &amp;dG, ParticleSet::ParticleLaplacian_t &amp;dL, int iat)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>registerData</name>
      <anchor>a10</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyFromBuffer</name>
      <anchor>a11</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a12</anchor>
      <arglist>(ParticleSet &amp;P, PooledData&lt; RealType &gt; &amp;buf)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a13</anchor>
      <arglist>(WalkerSetRef &amp;W, ValueVectorType &amp;psi, WalkerSetRef::WalkerGradient_t &amp;G, WalkerSetRef::WalkerLaplacian_t &amp;L)</arglist>
    </member>
    <member kind="variable">
      <type>FT</type>
      <name>F</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const DistanceTableData *</type>
      <name>d_table</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>N</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>NN</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType</type>
      <name>DiffVal</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType</type>
      <name>DiffValSum</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueVectorType</type>
      <name>U</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueVectorType</type>
      <name>d2U</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueVectorType</type>
      <name>curLap</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueVectorType</type>
      <name>curVal</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GradVectorType</type>
      <name>dU</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GradVectorType</type>
      <name>curGrad</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType *</type>
      <name>FirstAddressOfdU</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ValueType *</type>
      <name>LastAddressOfdU</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::BareKineticEnergy</name>
    <filename>structohmmsqmc_1_1BareKineticEnergy.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>BareKineticEnergy</name>
      <anchor>a0</anchor>
      <arglist>(RealType m=1.0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~BareKineticEnergy</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr)</arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>M</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::ConservedEnergy</name>
    <filename>structohmmsqmc_1_1ConservedEnergy.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>ConservedEnergy</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ConservedEnergy</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::CoulombPotentialAB</name>
    <filename>structohmmsqmc_1_1CoulombPotentialAB.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>CoulombPotentialAB</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;ions, ParticleSet &amp;els)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~CoulombPotentialAB</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Centers</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; RealType &gt;</type>
      <name>Z</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DistanceTableData *</type>
      <name>d_table</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::CoulombPotentialAA</name>
    <filename>structohmmsqmc_1_1CoulombPotentialAA.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>CoulombPotentialAA</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~CoulombPotentialAA</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>C</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DistanceTableData *</type>
      <name>d_table</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::EffMKineticEnergy</name>
    <filename>structohmmsqmc_1_1EffMKineticEnergy.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>EffMKineticEnergy</name>
      <anchor>a0</anchor>
      <arglist>(const Grid1D &amp;aGrid1D, const std::vector&lt; int &gt; &amp;intvals, const std::vector&lt; int &gt; &amp;priority, const std::vector&lt; double &gt; &amp;inveffm, RealType m=1.0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~EffMKineticEnergy</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>M</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>MatGrid1D *</type>
      <name>inveffm_grid</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::HarmonicPotential</name>
    <filename>structohmmsqmc_1_1HarmonicPotential.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>HarmonicPotential</name>
      <anchor>a0</anchor>
      <arglist>(RealType omega=1.0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HarmonicPotential</name>
      <anchor>a1</anchor>
      <arglist>(ParticleSet &amp;center, ParticleSet &amp;visitor)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HarmonicPotential</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a5</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Centers</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; RealType &gt;</type>
      <name>Omega</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DistanceTableData *</type>
      <name>d_table</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::IonIonPotential</name>
    <filename>structohmmsqmc_1_1IonIonPotential.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>IonIonPotential</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;ref)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~IonIonPotential</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>FirstTime</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ValueType</type>
      <name>d_sum</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DistanceTableData *</type>
      <name>d_ii</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet &amp;</type>
      <name>PtclRef</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; RealType &gt;</type>
      <name>Z</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::LocalCorePolPotential</name>
    <filename>structohmmsqmc_1_1LocalCorePolPotential.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>LocalCorePolPotential</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;ions, ParticleSet &amp;els)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LocalCorePolPotential</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>z9_0</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>z9_1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>FirstTime</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nCenters</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nParticles</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>eCoreCore</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet &amp;</type>
      <name>IonSys</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DistanceTableData *</type>
      <name>d_ie</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DistanceTableData *</type>
      <name>d_ii</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; CPP_Param * &gt;</type>
      <name>InpCPP</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; CPP_Param * &gt;</type>
      <name>Centers</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; PosType &gt;</type>
      <name>CoreCoreDipole</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; PosType &gt;</type>
      <name>CoreElDipole</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <class kind="struct">ohmmsqmc::LocalCorePolPotential::CPP_Param</class>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::LocalCorePolPotential::CPP_Param</name>
    <filename>structohmmsqmc_1_1LocalCorePolPotential_1_1CPP__Param.html</filename>
    <member kind="function">
      <type></type>
      <name>CPP_Param</name>
      <anchor>a0</anchor>
      <arglist>(RealType a=1.0, RealType r=1.0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set</name>
      <anchor>a1</anchor>
      <arglist>(RealType a, RealType r)</arglist>
    </member>
    <member kind="function">
      <type>RealType</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(RealType r)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>alpha</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>C</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>r_b</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>one_over_rr</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::LocalPPotential</name>
    <filename>structohmmsqmc_1_1LocalPPotential.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="typedef">
      <type>OneDimGridBase&lt; ValueType &gt;</type>
      <name>GridType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OneDimGridFunctor&lt; ValueType &gt;</type>
      <name>LocalPotentialType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LocalPPotential</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;ions, ParticleSet &amp;els)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LocalPPotential</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>DistanceTableData *</type>
      <name>d_table</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; RadialPotentialSet * &gt;</type>
      <name>PP</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>const ParticleSet::ParticleIndex_t &amp;</type>
      <name>Centers</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <class kind="struct">ohmmsqmc::LocalPPotential::RadialPotentialSet</class>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::LocalPPotential::RadialPotentialSet</name>
    <filename>structohmmsqmc_1_1LocalPPotential_1_1RadialPotentialSet.html</filename>
    <member kind="function">
      <type></type>
      <name>~RadialPotentialSet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a1</anchor>
      <arglist>(GridType *agrid, LocalPotentialType *pp)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(DistanceTableData *d_table, int iat)</arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; LocalPotentialType * &gt;</type>
      <name>lpp_m</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; GridType * &gt;</type>
      <name>grid_m</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::NonLocalPPotential</name>
    <filename>structohmmsqmc_1_1NonLocalPPotential.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="typedef">
      <type>OneDimGridBase&lt; ValueType &gt;</type>
      <name>GridType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OneDimGridFunctor&lt; ValueType &gt;</type>
      <name>LocalPotentialType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>NonLocalPPotential</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSet &amp;ions, ParticleSet &amp;els, TrialWaveFunction &amp;psi)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~NonLocalPPotential</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>DistanceTableData *</type>
      <name>d_table</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; RadialPotentialSet * &gt;</type>
      <name>PP</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>const ParticleSet::ParticleIndex_t &amp;</type>
      <name>Centers</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>maxnonloc</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>maxsgridpts</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>maxangmom</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>TrialWaveFunction &amp;</type>
      <name>Psi</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <class kind="struct">ohmmsqmc::NonLocalPPotential::RadialPotentialSet</class>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::NonLocalPPotential::RadialPotentialSet</name>
    <filename>structohmmsqmc_1_1NonLocalPPotential_1_1RadialPotentialSet.html</filename>
    <member kind="typedef">
      <type>vector&lt; PosType &gt;</type>
      <name>SpherGridType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~RadialPotentialSet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a1</anchor>
      <arglist>(GridType *agrid, LocalPotentialType *pp)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a2</anchor>
      <arglist>(int angmom, GridType *agrid, LocalPotentialType *pp)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addknot</name>
      <anchor>a3</anchor>
      <arglist>(PosType xyz, ValueType weight)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resize_warrays</name>
      <anchor>a4</anchor>
      <arglist>(int n, int m, int l)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>randomize_grid</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a6</anchor>
      <arglist>(ParticleSet &amp;W, DistanceTableData *d_table, int iat, TrialWaveFunction &amp;Psi)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a7</anchor>
      <arglist>(DistanceTableData *d_table, int iat)</arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; LocalPotentialType * &gt;</type>
      <name>lpp_m</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; GridType * &gt;</type>
      <name>lgrid_m</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>lmax</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>Rmax</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>angpp_m</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>wgt_angpp_m</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; LocalPotentialType * &gt;</type>
      <name>nlpp_m</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; GridType * &gt;</type>
      <name>nlgrid_m</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SpherGridType</type>
      <name>sgridxyz_m</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SpherGridType</type>
      <name>rrotsgrid_m</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; ValueType &gt;</type>
      <name>sgridweight_m</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; ValueType &gt;</type>
      <name>psiratio</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; ValueType &gt;</type>
      <name>vrad</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; ValueType &gt;</type>
      <name>wvec</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; ValueType &gt;</type>
      <name>Amat</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; ValueType &gt;</type>
      <name>lpol</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::PolarizationPotential</name>
    <filename>structohmmsqmc_1_1PolarizationPotential.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>PolarizationPotential</name>
      <anchor>a0</anchor>
      <arglist>(double field)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PolarizationPotential</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>Efield</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::QMCHamiltonian</name>
    <filename>classohmmsqmc_1_1QMCHamiltonian.html</filename>
    <member kind="typedef">
      <type>QMCHamiltonianBase::RealType</type>
      <name>RealType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>QMCHamiltonianBase::ValueType</type>
      <name>ValueType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>QMCHamiltonianBase::Return_t</type>
      <name>Return_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QMCHamiltonian</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~QMCHamiltonian</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add</name>
      <anchor>a2</anchor>
      <arglist>(QMCHamiltonianBase *h, const string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>remove</name>
      <anchor>a3</anchor>
      <arglist>(const string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add2WalkerProperty</name>
      <anchor>a4</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>startIndex</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>getName</name>
      <anchor>a6</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>operator[]</name>
      <anchor>a7</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>saveProperty</name>
      <anchor>a9</anchor>
      <arglist>(IT first)</arglist>
    </member>
    <member kind="function">
      <type>QMCHamiltonianBase *</type>
      <name>getHamiltonian</name>
      <anchor>a10</anchor>
      <arglist>(const string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>getLocalEnergy</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>getLocalPotential</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTau</name>
      <anchor>a13</anchor>
      <arglist>(RealType tau)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a14</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Return_t</type>
      <name>LocalEnergy</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; QMCHamiltonianBase * &gt;</type>
      <name>H</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; int &gt;</type>
      <name>Hindex</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; Return_t &gt;</type>
      <name>Hvalue</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; string &gt;</type>
      <name>Hname</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::map&lt; string, int &gt;</type>
      <name>Hmap</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::QMCHamiltonianBase</name>
    <filename>structohmmsqmc_1_1QMCHamiltonianBase.html</filename>
    <base>QMCTraits</base>
    <member kind="typedef">
      <type>RealType</type>
      <name>Return_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QMCHamiltonianBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~QMCHamiltonianBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>put</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)=0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTau</name>
      <anchor>a5</anchor>
      <arglist>(RealType tau)</arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>Tau</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>Value</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::Spline3DPotential</name>
    <filename>structohmmsqmc_1_1Spline3DPotential.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>Spline3DPotential</name>
      <anchor>a0</anchor>
      <arglist>(Grid3D *agrid, const string &amp;fname)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Spline3DPotential</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>Return_t</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(WalkerSetRef &amp;P, ValueVectorType &amp;LE)</arglist>
    </member>
    <member kind="variable">
      <type>Grid3D *</type>
      <name>full_Grid</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Spline3D *</type>
      <name>pot_m</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::TriCubicSplinePotential</name>
    <filename>structohmmsqmc_1_1TriCubicSplinePotential.html</filename>
    <base>ohmmsqmc::QMCHamiltonianBase</base>
    <member kind="function">
      <type></type>
      <name>TriCubicSplinePotential</name>
      <anchor>a0</anchor>
      <arglist>(double mbyepsq, Grid3D *agrid, const string &amp;fname)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TriCubicSplinePotential</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a2</anchor>
      <arglist>(ParticleSet &amp;P)</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>evaluate</name>
      <anchor>a3</anchor>
      <arglist>(ParticleSet &amp;P, RealType &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>evaluate</name>
      <anchor>a4</anchor>
      <arglist>(WalkerSetRef &amp;P, ValueVectorType &amp;LE)</arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>Efac</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Grid3D *</type>
      <name>DeviceGrid</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>TriCubicSpline *</type>
      <name>pot_m</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::LocalEnergyEstimator</name>
    <filename>classohmmsqmc_1_1LocalEnergyEstimator.html</filename>
    <templarg>T</templarg>
    <base>ohmmsqmc::ScalarEstimatorBase</base>
    <member kind="typedef">
      <type>ScalarEstimatorBase&lt; T &gt;::Walker_t</type>
      <name>Walker_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LocalEnergyEstimator</name>
      <anchor>a0</anchor>
      <arglist>(QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add2Record</name>
      <anchor>a1</anchor>
      <arglist>(RecordNamedProperty&lt; T &gt; &amp;record)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>accumulate</name>
      <anchor>a2</anchor>
      <arglist>(const Walker_t &amp;awalker, T wgt)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>report</name>
      <anchor>a4</anchor>
      <arglist>(RecordNamedProperty&lt; T &gt; &amp;record, T wgtinv)</arglist>
    </member>
    <member kind="enumvalue">
      <name>ENERGY_INDEX</name>
      <anchor>y4y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ENERGY_SQ_INDEX</name>
      <anchor>y4y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>POTENTIAL_INDEX</name>
      <anchor>y4y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LE_MAX</name>
      <anchor>y4y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>LocalEnergyIndex</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>LocalPotentialIndex</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>FirstHamiltonian</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>SizeOfHamiltonians</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; string &gt;</type>
      <name>elocal_name</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; T &gt;</type>
      <name>elocal</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::MultipleEnergyEstimator</name>
    <filename>structohmmsqmc_1_1MultipleEnergyEstimator.html</filename>
    <base>ohmmsqmc::ScalarEstimatorBase&lt; ParticleSet::RealType &gt;</base>
    <member kind="typedef">
      <type>ParticleSet::RealType</type>
      <name>RealType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ScalarEstimatorBase&lt; RealType &gt;::Walker_t</type>
      <name>Walker_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matrix&lt; RealType &gt;</type>
      <name>EnergyContainer_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ENERGY_INDEX</name>
      <anchor>w7w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ENERGY_SQ_INDEX</name>
      <anchor>w7w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>WEIGHT_INDEX</name>
      <anchor>w7w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LE_INDEX</name>
      <anchor>w7w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MultipleEnergyEstimator</name>
      <anchor>a0</anchor>
      <arglist>(QMCHamiltonian &amp;h, int hcopy=1)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add2Record</name>
      <anchor>a1</anchor>
      <arglist>(RecordNamedProperty&lt; RealType &gt; &amp;record)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>accumulate</name>
      <anchor>a2</anchor>
      <arglist>(const Walker_t &amp;awalker, RealType wgt)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>report</name>
      <anchor>a4</anchor>
      <arglist>(RecordNamedProperty&lt; RealType &gt; &amp;record, RealType wgtinv)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initialize</name>
      <anchor>a5</anchor>
      <arglist>(MCWalkerConfiguration &amp;W, vector&lt; QMCHamiltonian * &gt; &amp;h, vector&lt; TrialWaveFunction * &gt; &amp;psi, RealType tau, bool require_register=false)</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>CurrentWalker</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumWalkers</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>FirstColumnIndex</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>FirstHamiltonian</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumCopies</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumOperators</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; RealType &gt;</type>
      <name>RatioIJ</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; RealType &gt;</type>
      <name>esum</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; RealType &gt;</type>
      <name>elocal</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; string &gt;</type>
      <name>esum_name</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; string &gt;</type>
      <name>elocal_name</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::PolarizationEstimator</name>
    <filename>classohmmsqmc_1_1PolarizationEstimator.html</filename>
    <templarg>T</templarg>
    <base>ohmmsqmc::ScalarEstimatorBase</base>
    <member kind="typedef">
      <type>ScalarEstimatorBase&lt; T &gt;::Walker_t</type>
      <name>Walker_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PolarizationEstimator</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add2Record</name>
      <anchor>a1</anchor>
      <arglist>(RecordNamedProperty&lt; T &gt; &amp;record)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>accumulate</name>
      <anchor>a2</anchor>
      <arglist>(const Walker_t &amp;awalker, T wgt)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>report</name>
      <anchor>a4</anchor>
      <arglist>(RecordNamedProperty&lt; T &gt; &amp;record, T wgtinv)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; T &gt;</type>
      <name>z_sum</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>pindex_0</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>pindex_1</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::ScalarEstimatorBase</name>
    <filename>structohmmsqmc_1_1ScalarEstimatorBase.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>MCWalkerConfiguration::Walker_t</type>
      <name>Walker_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ScalarEstimatorBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>average</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>variance</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>add2Record</name>
      <anchor>a3</anchor>
      <arglist>(RecordNamedProperty&lt; T &gt; &amp;record)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>accumulate</name>
      <anchor>a4</anchor>
      <arglist>(const Walker_t &amp;awalker, T wgt)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>report</name>
      <anchor>a5</anchor>
      <arglist>(RecordNamedProperty&lt; T &gt; &amp;record, T wgtinv)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>reset</name>
      <anchor>a6</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>CollectSum</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>b_average</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>b_variance</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::ScalarEstimatorManager</name>
    <filename>classohmmsqmc_1_1ScalarEstimatorManager.html</filename>
    <base>QMCTraits</base>
    <member kind="typedef">
      <type>ScalarEstimatorBase&lt; RealType &gt;</type>
      <name>EstimatorType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ScalarEstimatorManager</name>
      <anchor>a0</anchor>
      <arglist>(QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ScalarEstimatorManager</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>accumulate</name>
      <anchor>a4</anchor>
      <arglist>(const MCWalkerConfiguration &amp;W)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resetReportSettings</name>
      <anchor>a5</anchor>
      <arglist>(const string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reportHeader</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>flushreport</name>
      <anchor>a7</anchor>
      <arglist>(int iter)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>report</name>
      <anchor>a8</anchor>
      <arglist>(int iter)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>flush</name>
      <anchor>a9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>finalize</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>addColumn</name>
      <anchor>a12</anchor>
      <arglist>(const char *aname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setColumn</name>
      <anchor>a13</anchor>
      <arglist>(int i, RealType v)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>add</name>
      <anchor>a14</anchor>
      <arglist>(EstimatorType *newestimator, const string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setStride</name>
      <anchor>a15</anchor>
      <arglist>(int istride)</arglist>
    </member>
    <member kind="function">
      <type>EstimatorType *</type>
      <name>getEstimator</name>
      <anchor>a16</anchor>
      <arglist>(const string &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>RealType</type>
      <name>average</name>
      <anchor>a17</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>RealType</type>
      <name>variance</name>
      <anchor>a18</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setWeight</name>
      <anchor>a19</anchor>
      <arglist>(RealType w)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setCollectionMode</name>
      <anchor>a20</anchor>
      <arglist>(bool collect)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>RootName</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>Stride</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>WeightIndex</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ostream *</type>
      <name>OutStream</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RealType</type>
      <name>WeightSum</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>QMCHamiltonian &amp;</type>
      <name>H</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RecordNamedProperty&lt; RealType &gt;</type>
      <name>BlockAverages</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::map&lt; string, int &gt;</type>
      <name>EstimatorMap</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; EstimatorType * &gt;</type>
      <name>Estimators</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::DMCParticleByParticle</name>
    <filename>classohmmsqmc_1_1DMCParticleByParticle.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>DMCParticleByParticle</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setBranchInfo</name>
      <anchor>a3</anchor>
      <arglist>(const string &amp;aname)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>DMCParticleByParticle</name>
      <anchor>d0</anchor>
      <arglist>(const DMCParticleByParticle &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DMCParticleByParticle &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const DMCParticleByParticle &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>IndexType</type>
      <name>PopIndex</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>IndexType</type>
      <name>EtrialIndex</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>BranchInfo</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::DummyQMC</name>
    <filename>classohmmsqmc_1_1DummyQMC.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>DummyQMC</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>DummyQMC</name>
      <anchor>d0</anchor>
      <arglist>(const DummyQMC &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DummyQMC &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const DummyQMC &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::MolecuDMC</name>
    <filename>classohmmsqmc_1_1MolecuDMC.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>MolecuDMC</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>advanceWalkerByWalker</name>
      <anchor>a1</anchor>
      <arglist>(BRANCHER &amp;Branch)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr q)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setBranchInfo</name>
      <anchor>a4</anchor>
      <arglist>(const string &amp;fname)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>MolecuDMC</name>
      <anchor>d0</anchor>
      <arglist>(const MolecuDMC &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MolecuDMC &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const MolecuDMC &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::string</type>
      <name>BranchInfo</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::MolecuFixedNodeBranch</name>
    <filename>classohmmsqmc_1_1MolecuFixedNodeBranch.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>MolecuFixedNodeBranch</name>
      <anchor>a0</anchor>
      <arglist>(T tau, int nideal)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator()</name>
      <anchor>a1</anchor>
      <arglist>(T psi0, T psi1) const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>branchGF</name>
      <anchor>a2</anchor>
      <arglist>(T tau, T emixed, T reject) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setEguess</name>
      <anchor>a3</anchor>
      <arglist>(T eg)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>branch</name>
      <anchor>a4</anchor>
      <arglist>(int iter, MCWalkerConfiguration &amp;w)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>update</name>
      <anchor>a5</anchor>
      <arglist>(T pop_now, T eavg)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a6</anchor>
      <arglist>(xmlNodePtr cur, OhmmsInform *LogOut)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>checkBranchData</name>
      <anchor>a7</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>updateBranchData</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Tau</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>Feed</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>E_T</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T</type>
      <name>logN</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Nideal</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Nmax</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Nmin</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>MaxCopy</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>EgBufferSize</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Counter</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumGeneration</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>xmlNodePtr</type>
      <name>branchPtr</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>xmlNodePtr</type>
      <name>egPtr</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::deque&lt; T &gt;</type>
      <name>Eg</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>MolecuFixedNodeBranch</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::Bead</name>
    <filename>structohmmsqmc_1_1Bead.html</filename>
    <base>ohmmsqmc::Walker&lt; RealType, ParticlePos_t &gt;</base>
    <member kind="typedef">
      <type>MCWalkerConfiguration::Walker_t</type>
      <name>Walker_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MCWalkerConfiguration::RealType</type>
      <name>RealType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MCWalkerConfiguration::ParticlePos_t</type>
      <name>ParticlePos_t</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Bead</name>
      <anchor>a0</anchor>
      <arglist>(const Bead &amp;a)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Bead</name>
      <anchor>a1</anchor>
      <arglist>(const Walker_t &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>Bead &amp;</type>
      <name>operator=</name>
      <anchor>a2</anchor>
      <arglist>(const Bead &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>makeCopyBead</name>
      <anchor>a3</anchor>
      <arglist>(const Bead &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>Resize_Grad_and_Action</name>
      <anchor>a4</anchor>
      <arglist>(int n, int m)</arglist>
    </member>
    <member kind="variable">
      <type>Vector&lt; ParticlePos_t * &gt;</type>
      <name>Gradients</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; RealType &gt;</type>
      <name>Action</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::MultiChain</name>
    <filename>structohmmsqmc_1_1MultiChain.html</filename>
    <base>std::deque</base>
    <member kind="typedef">
      <type>MCWalkerConfiguration::Walker_t</type>
      <name>Walker_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MCWalkerConfiguration::RealType</type>
      <name>RealType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MultiChain</name>
      <anchor>a0</anchor>
      <arglist>(Walker_t *awalker, int len, int direction, int npsi)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MultiChain</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>flip</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>GrowthDirection</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Middle</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Last</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nPsi</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>SumRatio</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>LogRatioActionIJ</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Vector&lt; RealType &gt;</type>
      <name>UmbrellaWeight</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Vector&lt; int &gt;</type>
      <name>TotalSign</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::PolymerChain</name>
    <filename>structohmmsqmc_1_1PolymerChain.html</filename>
    <base>std::deque</base>
    <member kind="typedef">
      <type>MCWalkerConfiguration::Walker_t</type>
      <name>Walker_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MCWalkerConfiguration::ParticleGradient_t</type>
      <name>ParticleGradient_t</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MCWalkerConfiguration::RealType</type>
      <name>RealType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PolymerChain</name>
      <anchor>a0</anchor>
      <arglist>(Walker_t *awalker, int len, int movables)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PolymerChain</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>size_t</type>
      <name>getID</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>subCuts</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addCuts</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resizeArrays</name>
      <anchor>a5</anchor>
      <arglist>(int npsi=1)</arglist>
    </member>
    <member kind="function">
      <type>Walker_t *</type>
      <name>makeEnds</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>updateEnds</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>average</name>
      <anchor>a8</anchor>
      <arglist>(Walker_t &amp;center)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>flip</name>
      <anchor>a9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>MoveHead</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NumCuts</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Middle</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>Last</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>nPsi</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>NumMoves</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>AcceptedMoves</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>SumRatioPrimary</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Vector&lt; int &gt;</type>
      <name>RefSign</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Vector&lt; int &gt;</type>
      <name>TotalSign</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Vector&lt; RealType &gt;</type>
      <name>UmbrellaWeight</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Vector&lt; RealType &gt;</type>
      <name>LogRatioActionIJ</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; Walker_t * &gt;</type>
      <name>heads</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; Walker_t * &gt;</type>
      <name>tails</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>std::vector&lt; Walker_t * &gt;</type>
      <name>repository</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; ParticleGradient_t * &gt;</type>
      <name>Gradients</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Matrix&lt; ParticleGradient_t * &gt;</type>
      <name>HeadGradients</name>
      <anchor>o16</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::PolymerEstimator</name>
    <filename>classohmmsqmc_1_1PolymerEstimator.html</filename>
    <member kind="function">
      <type></type>
      <name>PolymerEstimator</name>
      <anchor>a0</anchor>
      <arglist>(PolymerChain &amp;reptile, int npsi=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PolymerEstimator</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clean</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resetReportSettings</name>
      <anchor>a3</anchor>
      <arglist>(const string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>report</name>
      <anchor>a5</anchor>
      <arglist>(int iter)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>accumulate</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PolymerChain &amp;</type>
      <name>Reptile</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>Middle</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>Counter</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>ReptileLength</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>nPsi</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>EpotLength</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>EpotSize</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>ElocSize</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstream *</type>
      <name>fout</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstream *</type>
      <name>OutLocEn</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstream *</type>
      <name>OutPotEn</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Vector&lt; double &gt;</type>
      <name>AvgLocalEnergy</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Vector&lt; double &gt;</type>
      <name>AvgPotentialEnergy</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Vector&lt; double &gt;</type>
      <name>TotalWeight</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>PEavg</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; double &gt;</type>
      <name>PE2</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::QMCDriver</name>
    <filename>classohmmsqmc_1_1QMCDriver.html</filename>
    <base>QMCTraits</base>
    <member kind="typedef">
      <type>MCWalkerConfiguration::Walker_t</type>
      <name>Walker_t</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QMCDriver</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~QMCDriver</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setFileRoot</name>
      <anchor>a2</anchor>
      <arglist>(const string &amp;aname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>add_H_and_Psi</name>
      <anchor>a3</anchor>
      <arglist>(QMCHamiltonian *h, TrialWaveFunction *psi)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initialize</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>process</name>
      <anchor>a5</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>run</name>
      <anchor>a6</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>put</name>
      <anchor>a7</anchor>
      <arglist>(xmlNodePtr cur)=0</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>QMCDriver</name>
      <anchor>b0</anchor>
      <arglist>(const QMCDriver &amp;a)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>putQMCInfo</name>
      <anchor>b1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addWalkers</name>
      <anchor>b2</anchor>
      <arglist>(int nwalkers)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>pStride</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>AcceptIndex</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>IndexType</type>
      <name>nBlocks</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>IndexType</type>
      <name>nSteps</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>IndexType</type>
      <name>nAccept</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>IndexType</type>
      <name>nReject</name>
      <anchor>p5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>IndexType</type>
      <name>nTargetWalkers</name>
      <anchor>p6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>RealType</type>
      <name>Tau</name>
      <anchor>p7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>RealType</type>
      <name>FirstStep</name>
      <anchor>p8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>RealType</type>
      <name>e_ref</name>
      <anchor>p9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>xmlNodePtr</type>
      <name>qmcNode</name>
      <anchor>p10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ParameterSet</type>
      <name>m_param</name>
      <anchor>p11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>string</type>
      <name>QMCType</name>
      <anchor>p12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>string</type>
      <name>RootName</name>
      <anchor>p13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MCWalkerConfiguration &amp;</type>
      <name>W</name>
      <anchor>p14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>TrialWaveFunction &amp;</type>
      <name>Psi</name>
      <anchor>p15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>QMCHamiltonian &amp;</type>
      <name>H</name>
      <anchor>p16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ScalarEstimatorManager *</type>
      <name>Estimators</name>
      <anchor>p17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; TrialWaveFunction * &gt;</type>
      <name>Psi1</name>
      <anchor>p18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; QMCHamiltonian * &gt;</type>
      <name>H1</name>
      <anchor>p19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ParticleSet::ParticlePos_t</type>
      <name>drift</name>
      <anchor>p20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ParticleSet::ParticlePos_t</type>
      <name>deltaR</name>
      <anchor>p21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>OhmmsInform *</type>
      <name>LogOut</name>
      <anchor>p22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ostrstream</type>
      <name>log_buffer</name>
      <anchor>p23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PooledData&lt; RealType &gt;</type>
      <name>HamPool</name>
      <anchor>p24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected" static="yes">
      <type>static int</type>
      <name>Counter</name>
      <anchor>t0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::ReptationMC</name>
    <filename>classohmmsqmc_1_1ReptationMC.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>ReptationMC</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ReptationMC</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr q)</arglist>
    </member>
    <member kind="typedef" protection="protected">
      <type>MCWalkerConfiguration::Walker_t</type>
      <name>Walker_t</name>
      <anchor>x0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>moveReptile</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>initReptile</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>UseBounce</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>ClonePolymer</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>PolymerLength</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>NumCuts</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>NumTurns</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PolymerChain *</type>
      <name>Reptile</name>
      <anchor>p5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ReptationMC</name>
      <anchor>d0</anchor>
      <arglist>(const ReptationMC &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ReptationMC &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const ReptationMC &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::RQMCMultiple</name>
    <filename>classohmmsqmc_1_1RQMCMultiple.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>RQMCMultiple</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~RQMCMultiple</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr q)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>moveReptile</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>initReptile</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>resizeArrays</name>
      <anchor>b2</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>ReptileLength</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>MinusDirection</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>PlusDirection</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>Directionless</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>forward</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>backward</name>
      <anchor>p5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>ianchor</name>
      <anchor>p6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>itail</name>
      <anchor>p7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>inext</name>
      <anchor>p8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>NumTurns</name>
      <anchor>p9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>nptcl</name>
      <anchor>p10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>nPsi</name>
      <anchor>p11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>MultiChain *</type>
      <name>Reptile</name>
      <anchor>p12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Bead *</type>
      <name>NewBead</name>
      <anchor>p13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Vector&lt; RealType &gt;</type>
      <name>SumRatioAction</name>
      <anchor>p14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Vector&lt; RealType &gt;</type>
      <name>LogRatioActionIJ</name>
      <anchor>p15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Vector&lt; RealType &gt;</type>
      <name>sumratio</name>
      <anchor>p16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Vector&lt; RealType &gt;</type>
      <name>WReptile</name>
      <anchor>p17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Vector&lt; RealType &gt;</type>
      <name>logpsi</name>
      <anchor>p18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Vector&lt; int &gt;</type>
      <name>NewTotalSign</name>
      <anchor>p19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Vector&lt; int &gt;</type>
      <name>WeightSign</name>
      <anchor>p20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Vector&lt; int &gt;</type>
      <name>RefSign</name>
      <anchor>p21</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>RQMCMultiple</name>
      <anchor>d0</anchor>
      <arglist>(const RQMCMultiple &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>RQMCMultiple &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const RQMCMultiple &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>NewLogRatioAction</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>NewSumRatio</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>accept</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet::ParticlePos_t</type>
      <name>gRand</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::VMC</name>
    <filename>classohmmsqmc_1_1VMC.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>VMC</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>VMC</name>
      <anchor>d0</anchor>
      <arglist>(const VMC &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>VMC &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const VMC &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>advanceWalkerByWalker</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::VMC_OPT</name>
    <filename>classohmmsqmc_1_1VMC__OPT.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <base>MinimizeFunction</base>
    <member kind="enumvalue">
      <name>ENERGY</name>
      <anchor>w2w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ENERGYSQ</name>
      <anchor>w2w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VMC_OPT</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~VMC_OPT</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>run_vmc</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ValueType</type>
      <name>correlatedSampling</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>scalar &amp;</type>
      <name>Params</name>
      <anchor>a6</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>scalar</type>
      <name>Params</name>
      <anchor>a7</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>scalar</type>
      <name>Cost</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>NumParams</name>
      <anchor>a9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addConfiguration</name>
      <anchor>a10</anchor>
      <arglist>(const string &amp;a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>WriteStuff</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>resetWaveFunctions</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>checkParameters</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>putOptParams</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>RealType</type>
      <name>evalCost</name>
      <anchor>d3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>checkConfigurations</name>
      <anchor>d4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>VMC_OPT</name>
      <anchor>d5</anchor>
      <arglist>(const VMC_OPT &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>VMC_OPT &amp;</type>
      <name>operator=</name>
      <anchor>d6</anchor>
      <arglist>(const VMC_OPT &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; WalkerData * &gt;</type>
      <name>RefConf</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>UseWeight</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::deque&lt; scalar &gt;</type>
      <name>costList</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::deque&lt; vector&lt; scalar &gt; &gt;</type>
      <name>paramList</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; scalar &gt;</type>
      <name>OptParams</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; string &gt;</type>
      <name>IDtag</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; string &gt;</type>
      <name>ConfigFile</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>optmethod</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>NumCostCalls</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>NumSamples</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RealType</type>
      <name>cg_tolerance</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RealType</type>
      <name>cg_stepsize</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RealType</type>
      <name>cg_epsilon</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RealType</type>
      <name>w_en</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RealType</type>
      <name>w_var</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RealType</type>
      <name>CostValue</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>QMCHamiltonian</type>
      <name>H_KE</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <class kind="struct">ohmmsqmc::VMC_OPT::WalkerData</class>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::VMC_OPT::WalkerData</name>
    <filename>structohmmsqmc_1_1VMC__OPT_1_1WalkerData.html</filename>
    <member kind="function">
      <type></type>
      <name>WalkerData</name>
      <anchor>a0</anchor>
      <arglist>(int n=1)</arglist>
    </member>
    <member kind="variable">
      <type>ValueType</type>
      <name>LogPsi</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>RealType</type>
      <name>Vloc</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet::ParticleGradient_t</type>
      <name>G</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleSet::ParticleLaplacian_t</type>
      <name>L</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::VMCMoveAll</name>
    <filename>classohmmsqmc_1_1VMCMoveAll.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>VMCMoveAll</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h, xmlNodePtr q)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>VMCMoveAll</name>
      <anchor>d0</anchor>
      <arglist>(const VMCMoveAll &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>VMCMoveAll &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const VMCMoveAll &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>advanceAllWalkers</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet::ParticlePos_t</type>
      <name>drift</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet::ParticlePos_t</type>
      <name>deltaR</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::VMCMultiple</name>
    <filename>classohmmsqmc_1_1VMCMultiple.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>VMCMultiple</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>advanceWalkerByWalker</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>VMCMultiple</name>
      <anchor>d0</anchor>
      <arglist>(const VMCMultiple &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>VMCMultiple &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const VMCMultiple &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MultipleEnergyEstimator *</type>
      <name>multiEstimator</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>nPsi</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; RealType &gt;</type>
      <name>logpsi</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; RealType &gt;</type>
      <name>sumratio</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; RealType &gt;</type>
      <name>invsumratio</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::VMCParticleByParticle</name>
    <filename>classohmmsqmc_1_1VMCParticleByParticle.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>VMCParticleByParticle</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>VMCParticleByParticle</name>
      <anchor>d0</anchor>
      <arglist>(const VMCParticleByParticle &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>VMCParticleByParticle &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const VMCParticleByParticle &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::VMCPbyPMultiple</name>
    <filename>classohmmsqmc_1_1VMCPbyPMultiple.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>VMCPbyPMultiple</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~VMCPbyPMultiple</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>ParticleSet::ParticleGradient_t</type>
      <name>ParticleGradient_t</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>ParticleSet::ParticleLaplacian_t</type>
      <name>ParticleLaplacian_t</name>
      <anchor>y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>VMCPbyPMultiple</name>
      <anchor>d0</anchor>
      <arglist>(const VMCPbyPMultiple &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>VMCPbyPMultiple &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const VMCPbyPMultiple &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>resize</name>
      <anchor>d2</anchor>
      <arglist>(int ncopy, int nptcls)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>nPsi</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleGradient_t</type>
      <name>dG</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; ParticleGradient_t * &gt;</type>
      <name>G</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; ParticleLaplacian_t * &gt;</type>
      <name>dL</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; RealType &gt;</type>
      <name>ratio</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; RealType &gt;</type>
      <name>ratioij</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; RealType &gt;</type>
      <name>UmbrellaWeight</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; RealType &gt;</type>
      <name>sumratio</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; RealType &gt;</type>
      <name>invsumratio</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MultipleEnergyEstimator *</type>
      <name>multiEstimator</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::WaveFunctionTester</name>
    <filename>classohmmsqmc_1_1WaveFunctionTester.html</filename>
    <base>ohmmsqmc::QMCDriver</base>
    <member kind="function">
      <type></type>
      <name>WaveFunctionTester</name>
      <anchor>a0</anchor>
      <arglist>(MCWalkerConfiguration &amp;w, TrialWaveFunction &amp;psi, QMCHamiltonian &amp;h, xmlNodePtr q)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>run</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr q)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>WaveFunctionTester</name>
      <anchor>d0</anchor>
      <arglist>(const WaveFunctionTester &amp;a)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>WaveFunctionTester &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const WaveFunctionTester &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::HamiltonianPool</name>
    <filename>classohmmsqmc_1_1HamiltonianPool.html</filename>
    <base>OhmmsElementBase</base>
    <member kind="typedef">
      <type>std::map&lt; std::string, QMCHamiltonian * &gt;</type>
      <name>PoolType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HamiltonianPool</name>
      <anchor>a0</anchor>
      <arglist>(const char *aname=&quot;hamiltonian&quot;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a1</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>QMCHamiltonian *</type>
      <name>getPrimary</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>QMCHamiltonian *</type>
      <name>getHamiltonian</name>
      <anchor>a7</anchor>
      <arglist>(const std::string &amp;pname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setParticleSetPool</name>
      <anchor>a8</anchor>
      <arglist>(ParticleSetPool *pset)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setWaveFunctionPool</name>
      <anchor>a9</anchor>
      <arglist>(WaveFunctionPool *pset)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addCoulombPotential</name>
      <anchor>a10</anchor>
      <arglist>(xmlNodePtr cur, ParticleSet *target)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addPseudoPotential</name>
      <anchor>a11</anchor>
      <arglist>(xmlNodePtr cur, ParticleSet *target)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addCorePolPotential</name>
      <anchor>a12</anchor>
      <arglist>(xmlNodePtr cur, ParticleSet *target)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>QMCHamiltonian *</type>
      <name>primaryH</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>QMCHamiltonian *</type>
      <name>curH</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSetPool *</type>
      <name>ptclPool</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WaveFunctionPool *</type>
      <name>psiPool</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PoolType</type>
      <name>myPool</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::InitMolecularSystem</name>
    <filename>classohmmsqmc_1_1InitMolecularSystem.html</filename>
    <base>OhmmsElementBase</base>
    <member kind="function">
      <type></type>
      <name>InitMolecularSystem</name>
      <anchor>a0</anchor>
      <arglist>(ParticleSetPool *pset, const char *aname=&quot;mosystem&quot;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a1</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initAtom</name>
      <anchor>a5</anchor>
      <arglist>(ParticleSet *els)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initMolecule</name>
      <anchor>a6</anchor>
      <arglist>(ParticleSet *ions, ParticleSet *els)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSetPool *</type>
      <name>ptclPool</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ohmmsqmc::BasisGroupType</name>
    <filename>structohmmsqmc_1_1BasisGroupType.html</filename>
    <member kind="function">
      <type></type>
      <name>BasisGroupType</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BasisGroupType</name>
      <anchor>a1</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>Excluded</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>L</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>xmlNodePtr</type>
      <name>curPtr</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::MO2Grid3D</name>
    <filename>classohmmsqmc_1_1MO2Grid3D.html</filename>
    <base>ohmmsqmc::QMCAppBase</base>
    <member kind="typedef">
      <type>OrbitalBase::RealType</type>
      <name>RealType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OrbitalBase::ValueType</type>
      <name>ValueType</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>OrbitalBase::PosType</type>
      <name>PosType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MO2Grid3D</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MO2Grid3D</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>validateXML</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>execute</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>xmlNodePtr</type>
      <name>generateNumericalOrbitals</name>
      <anchor>a4</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyOrbitalSet</name>
      <anchor>a5</anchor>
      <arglist>(map&lt; string, TriCubicSplineT&lt; ValueType &gt; * &gt; &amp;other)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>selectCore</name>
      <anchor>d0</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>getEigVectors</name>
      <anchor>d1</anchor>
      <arglist>(xmlNodePtr cur, const Matrix&lt; RealType &gt; &amp;A)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>xmlNodePtr</type>
      <name>copyDeterminant</name>
      <anchor>d2</anchor>
      <arglist>(xmlNodePtr cur, bool addg)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>xmlNodePtr</type>
      <name>copyDeterminantSet</name>
      <anchor>d3</anchor>
      <arglist>(xmlNodePtr cur, xmlNodePtr splinePtr)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSetPool *</type>
      <name>ptclPool</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MCWalkerConfiguration *</type>
      <name>Electrons</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet *</type>
      <name>Ions</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>xmlNodePtr</type>
      <name>dsetPtr</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>xmlNodePtr</type>
      <name>normalPtr</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>xmlNodePtr</type>
      <name>corePtr</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, TriCubicSplineT&lt; ValueType &gt; * &gt;</type>
      <name>SPOSet</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::ParticleSetPool</name>
    <filename>classohmmsqmc_1_1ParticleSetPool.html</filename>
    <base>OhmmsElementBase</base>
    <member kind="typedef">
      <type>map&lt; string, ParticleSet * &gt;</type>
      <name>PoolType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleSetPool</name>
      <anchor>a0</anchor>
      <arglist>(const char *aname=&quot;particleset&quot;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a1</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>ParticleSet *</type>
      <name>getParticleSet</name>
      <anchor>a6</anchor>
      <arglist>(const string &amp;pname)</arglist>
    </member>
    <member kind="function">
      <type>MCWalkerConfiguration *</type>
      <name>getWalkerSet</name>
      <anchor>a7</anchor>
      <arglist>(const string &amp;pname)</arglist>
    </member>
    <member kind="function">
      <type>PoolType &amp;</type>
      <name>getPool</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>map&lt; string, ParticleSet * &gt;</type>
      <name>myPool</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::QMCAppBase</name>
    <filename>classohmmsqmc_1_1QMCAppBase.html</filename>
    <member kind="function">
      <type></type>
      <name>QMCAppBase</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~QMCAppBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>parse</name>
      <anchor>a2</anchor>
      <arglist>(const string &amp;infile)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>saveXml</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>validateXML</name>
      <anchor>a4</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>execute</name>
      <anchor>a5</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>string</type>
      <name>InFileRoot</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>xmlDocPtr</type>
      <name>m_doc</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>xmlNodePtr</type>
      <name>m_root</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>OHMMS::ProjectData</type>
      <name>myProject</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>OHMMS::RandomNumberControl</type>
      <name>myRandomControl</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::QMCMain</name>
    <filename>classohmmsqmc_1_1QMCMain.html</filename>
    <base>ohmmsqmc::QMCAppBase</base>
    <member kind="enumeration">
      <name>QMCRunType</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>DUMMY_RUN</name>
      <anchor>w5w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>VMC_RUN</name>
      <anchor>w5w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>DMC_RUN</name>
      <anchor>w5w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>RMC_RUN</name>
      <anchor>w5w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>OPTIMIZE_RUN</name>
      <anchor>w5w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QMCMain</name>
      <anchor>a0</anchor>
      <arglist>(int argc, char **argv)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~QMCMain</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>validateXML</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>execute</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>runQMC</name>
      <anchor>d0</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>setMCWalkers</name>
      <anchor>d1</anchor>
      <arglist>(xmlXPathContextPtr cur)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>processPWH</name>
      <anchor>d2</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>QMCRunType</type>
      <name>curRunType</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::string</type>
      <name>curMethod</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>QMCDriver *</type>
      <name>qmcDriver</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MCWalkerConfiguration *</type>
      <name>qmcSystem</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSetPool *</type>
      <name>ptclPool</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WaveFunctionPool *</type>
      <name>psiPool</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HamiltonianPool *</type>
      <name>hamPool</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>PrevConfigFile</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; xmlNodePtr &gt;</type>
      <name>m_walkerset</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ohmmsqmc::WaveFunctionPool</name>
    <filename>classohmmsqmc_1_1WaveFunctionPool.html</filename>
    <base>OhmmsElementBase</base>
    <member kind="function">
      <type></type>
      <name>WaveFunctionPool</name>
      <anchor>a0</anchor>
      <arglist>(const char *aname=&quot;wavefunction&quot;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>get</name>
      <anchor>a1</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a2</anchor>
      <arglist>(std::istream &amp;is)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>put</name>
      <anchor>a3</anchor>
      <arglist>(xmlNodePtr cur)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>TrialWaveFunction *</type>
      <name>getPrimary</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>TrialWaveFunction *</type>
      <name>getWaveFunction</name>
      <anchor>a7</anchor>
      <arglist>(const std::string &amp;pname)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setParticleSetPool</name>
      <anchor>a8</anchor>
      <arglist>(ParticleSetPool *pset)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>TrialWaveFunction *</type>
      <name>primaryPsi</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::map&lt; std::string, TrialWaveFunction * &gt;</type>
      <name>myPool</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSetPool *</type>
      <name>ptclPool</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::vector&lt; OrbitalBuilderBase * &gt;</type>
      <name>orbitalBuilders</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>Pooma</name>
    <filename>namespacePooma.html</filename>
    <class kind="class">Pooma::Clock</class>
  </compound>
  <compound kind="class">
    <name>Pooma::Clock</name>
    <filename>classPooma_1_1Clock.html</filename>
    <member kind="function">
      <type>void</type>
      <name>start</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>stop</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>cpu_time</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>static double</type>
      <name>value</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>static const bool</type>
      <name>highSpeed</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>start_time</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>stop_time</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>std</name>
    <filename>namespacestd.html</filename>
  </compound>
</tagfile>
