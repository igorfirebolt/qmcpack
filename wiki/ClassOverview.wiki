#summary Overview of basic classes
== Summary ==
QMCPACK adopts many advanced C++ techniques based on template. Ultimately, one should be able to generate an executable tailored for an application by template instantiation but more conservative approaches are taken in the current implementation. It is too time consuming: compilation can take hours.

The guiding principles are
 * use template programming for computationally simple and critical components
 * use standard object-oriented practices for physical abstractions
 * use design patterns

UML diagrams for QMCPACK can be found at [PackageDiagrams Package Diagrams of QMCPACK]

== Directory structure ==
`src` directory contains

||PETE||OhmmsPETE||Numerics||Optimize||
||OhmmsData||Utilities||Platforms||OhmmsApps||
||Message||OOMPI||
||Lattice||ParticleBase||Particle||
||QMCWaveFunctions||QMCHamiltonians||QMCDrivers||Estimators||
||QMCApps||

== Global definitions ==
=== Namespaces ===
||*qmcplusplus`* || main QMC namespace ||
||*OHMMS`* ||: imported from OHMMS package ||
||*`APPNAMESPACE`* ||: identical to qmcplusplus namespace when used by QMCPACK. Base packages are guarded by `namespace APPNAMESPACE { }` to enable other applications to use PETE-based and common packages, e.g., Lattice, without importing QMC packages.||

=== Configuration files ===
An executable is built for a fixed dimensional problem using a given precision.
 * `build/src/config.h`: automatically generated by cmake. Default properties are defined in `topdir/CMakeLists.txt` with a template configuration file `topdir/src/config.h.cmake.in`
 * `topdir/src/Configuration.h` : common traits

Any class or function can use the traits defined in `src/Configuration.h` with
<code>
#include "Configuration.h"
</code>
At the compile time, most of the computationally critical classes are instantiated for the physical dimension, precision and the value type.

Many classes are inherited from QMCTraits so that consistent data types are used within an application instead of explicit names. For example, use
{{{
 QMCTraits::PosType pos;
}}}
to create a variable `pos` of a D-dimensional fixed vector.

== Base packages ==
Expression Template is essential for optimal performances. With optimizing compilers, we can practically ignore C++ overhead. However, beware that not all compilers are created equal.

Two directories contain classes based on PETE (Portable Expression Template Engine)
 * PETE: imported from Portable Expression Template Engine library from LANL
 * OhmmsPETE: extended PETE for general containers useful for physical simulations

=== Fundamental classes ===
 * `TinyVector<T,D>` : D-dimensional vector and used to represent a position of a particle
 * `Tensor<T,D>` : D-dimensional tensor. Used extensively with `TinyVector<T,D>` to handle basic tensor-vector operators

=== Convenience classes ===
These classes are *temporary replacements* for equivalent classes of standard libraries like blitz and boost. 
 * `Vector<T>` : one-dimensional array of type T. 
 * `Matrix<T>` : two-dimensional array of type T.
 * `Array<T,N>` : N-dimensional array of type T.

 * They provide minimum methods for numerical operations, such as assignment and copy operators.
 * Although any datatype can be used for the template parameter T, it is best to limit the datatype T to an intrinsic type or a simple type like `TinyVector<T,D>`. 
 * Do not use a pointer type for `T`.
 * These classes use `std::vector` as their container. The same limitations of `std::vector` apply to these classes.

== Physical abstraction packages == 
=== Particle classes ===
Classes for atomistic simulations.
 * `CrystalLattice<T,D,bool ORTHO=false>`: D-dimensional unit cell to represent a simulation box
 * `ParticleSet`:N-particle system. The main object which interact with QMC classes, such as QMCWaveFunctions and QMCHamiltonians
 * `MCWalkerSet`: derived from ParticleSet to handle a number of copies of an N-particle system. The main object for Monte Carlo Simulations.

