//////////////////////////////////////////////////////////////////
// (c) Copyright 2005- by Jeongnim Kim
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//   Jeongnim Kim
//   National Center for Supercomputing Applications &
//   Materials Computation Center
//   University of Illinois, Urbana-Champaign
//   Urbana, IL 61801
//   e-mail: jnkim@ncsa.uiuc.edu
//   Tel:    217-244-6319 (NCSA) 217-333-3324 (MCC)
//
// Supported by 
//   National Center for Supercomputing Applications, UIUC
//   Materials Computation Center, UIUC
//////////////////////////////////////////////////////////////////
// -*- C++ -*-
#include "QMCDrivers/QMCOptimizeSingle.h"
#include "Particle/HDFWalkerIO.h"
#include "Particle/DistanceTable.h"
#include "OhmmsData/AttributeSet.h"
#include "Message/CommOperators.h"
#include "Optimize/CGOptimization.h"
#include "Optimize/DampedDynamics.h"
#include "QMCDrivers/VMC/VMCSingle.h"

namespace qmcplusplus {

  QMCOptimizeSingle::QMCOptimizeSingle(MCWalkerConfiguration& w,
      TrialWaveFunction& psi, QMCHamiltonian& h):
  QMCDriver(w,psi,h), 
  PartID(0), NumParts(1), WarmupBlocks(10),
  optTarget(0), optSolver(0), vmcEngine(0),
  wfNode(NULL), optNode(NULL)
  { 
    //set the optimization flag
    QMCDriverMode.set(QMC_OPTIMIZE,1);
    //read to use vmc output (just in case)
    RootName = "pot";
    QMCType ="QMCOptimizeSingle";
    //default method is cg
    optmethod = "cg";
    m_param.add(WarmupBlocks,"warmupBlocks","int");
  }

  /** Clean up the vector */
  QMCOptimizeSingle::~QMCOptimizeSingle() 
  { 
    delete vmcEngine;
    delete optSolver;
  }

  /** Add configuration files for the optimization
   * @param a root of a hdf5 configuration file
   */
  void QMCOptimizeSingle::addConfiguration(const string& a) {
    if(a.size()) ConfigFile.push_back(a);
  }

  /** Reimplement QMCDriver::run
   */
  bool
  QMCOptimizeSingle::run() {

    optTarget->setCommunicator(qmcComm);

    //close files automatically generated by QMCDriver
    branchEngine->finalize();
    app_log() << "<optimization-report>" << endl;
    if(WarmupBlocks) 
    {
      app_log() << "<vmc stage=\"warm-up\" blocks=\"" << WarmupBlocks << "\">" << endl;
      vmcEngine->setValue("blocks",WarmupBlocks);
      vmcEngine->run();
      vmcEngine->setValue("blocks",nBlocks);
      app_log() << "</vmc>" << endl;
    }

    vmcEngine->setValue("recordWalkers",1);//set record 
    vmcEngine->setValue("current",0);//reset CurrentStep
    app_log() << "<vmc stage=\"main\" blocks=\"" << nBlocks << "\">" << endl;
    vmcEngine->run();
    app_log() << "</vmc>" << endl;

    //cleanup walkers
    W.destroyWalkers(W.begin(), W.end());

    app_log() << "<opt stage=\"setup\">" << endl;
    app_log() << "  <log>"<<endl;
    //reset the rootname
    optTarget->setRootName(RootName);
    optTarget->setWaveFunctionNode(wfNode);

    //get configuration from the previous run
    //optTarget->getConfigurations(h5FileRoot);
    optTarget->getConfigurations(RootName);
    optTarget->checkConfigurations();
    app_log() << "  </log>"<<endl;
    app_log() << "</opt>" << endl;

    app_log() << "<opt stage=\"main\" walkers=\""<< W.getActiveWalkers() << "\">" << endl;
    app_log() << "  <log>" << endl;

    branchEngine->E_T=vmcEngine->getBranchEngine()->E_T;
    optTarget->setTargetEnergy(branchEngine->E_T);

    bool success=optSolver->optimize(optTarget);
    app_log() << "  </log>" << endl;
    optTarget->reportParameters();
    app_log() << "</opt>" << endl;
    app_log() << "</optimization-report>" << endl;

    return (optTarget->getReportCounter() > 0);
  }

  /** Parses the xml input file for parameter definitions for the wavefunction optimization.
   * @param q current xmlNode 
   * @return true if successful
   */
  bool
  QMCOptimizeSingle::put(xmlNodePtr q) {

    xmlNodePtr qsave=q;
    xmlNodePtr cur=qsave->children;
    int pid=OHMMS::Controller->mycontext();
    while(cur != NULL) {
      string cname((const char*)(cur->name));
      if(cname == "mcwalkerset") {
        mcwalkerNodePtr.push_back(cur);
      } else if(cname == "optimizer") {
        xmlChar* att= xmlGetProp(cur,(const xmlChar*)"method");
        if(att) { optmethod = (const char*)att; }
        optNode=cur;
      } else if(cname == "optimize") {
        xmlChar* att= xmlGetProp(cur,(const xmlChar*)"method");
        if(att) { optmethod = (const char*)att; }
      }
      cur=cur->next;
    }  

    //create VMC engine
    if(vmcEngine ==0)
    {
      vmcEngine = new VMCSingle(W,Psi,H);
      vmcEngine->setCommunicator(qmcComm);
    }

    string h5in;//pass empty string so that it does try to read anything
    vmcEngine->setStatus(RootName,h5in,AppendRun);
    vmcEngine->process(qsave);

    if(optSolver ==0)
    {
      if(optmethod == "anneal") 
      {
        app_log() << " Annealing optimization using DampedDynamics"<<endl;
        optSolver = new DampedDynamics<RealType>;
      } 
      else
      {
        app_log() << " Conjugate-gradient optimization using CGOptimization"<<endl;
        optSolver = new CGOptimization<RealType>;
      }
      //set the stream
      optSolver->setOstream(&app_log());
    }

    if(optNode == NULL) 
      optSolver->put(qmcNode);
    else
      optSolver->put(optNode);

    if(optTarget == 0) 
    {
      optTarget = new QMCCostFunction(W,Psi,H);
      optTarget->setStream(&app_log());
    }
    return optTarget->put(q);
  }
}
/***************************************************************************
 * $RCSfile$   $Author: jnkim $
 * $Revision: 1286 $   $Date: 2006-08-17 12:33:18 -0500 (Thu, 17 Aug 2006) $
 * $Id: QMCOptimizeSingle.cpp 1286 2006-08-17 17:33:18Z jnkim $ 
 ***************************************************************************/
