#include "Particle/DistanceTableData.h"
#include "Particle/DistanceTable.h"
#include "QMCWaveFunctions/Jastrow/BsplineJastrowBuilder.h"
#include "QMCWaveFunctions/Jastrow/BsplineFunctor.h"
#include "QMCWaveFunctions/Jastrow/OneBodyJastrowOrbital.h"
#include "QMCWaveFunctions/Jastrow/TwoBodyJastrowOrbital.h"
#include "QMCWaveFunctions/Jastrow/DiffTwoBodyJastrowOrbital.h"
#include "QMCWaveFunctions/Jastrow/DiffOneBodyJastrowOrbital.h"


namespace qmcplusplus {

  bool
  BsplineJastrowBuilder::put(xmlNodePtr cur)
  {
    bool PrintTables=true;
    xmlNodePtr kids = cur->xmlChildrenNode;
    typedef BsplineFunctor<RealType> RadFuncType;

    // Create a one-body Jastrow
    if (sourcePtcl) 
    {
      typedef OneBodyJastrowOrbital<RadFuncType> J1Type;
      typedef DiffOneBodyJastrowOrbital<RadFuncType> dJ1Type;

      J1Type *J1 = new J1Type(*sourcePtcl, targetPtcl);
      dJ1Type *dJ1 = new dJ1Type(*sourcePtcl, targetPtcl);

      // Find the number of the source species
      SpeciesSet &sSet = sourcePtcl->getSpeciesSet();
      int numSpecies = sSet.getTotalNum();
      bool success=false;
      while (kids != NULL) 
      {
	std::string kidsname = (char*)kids->name;
	if (kidsname == "correlation") 
        {
          RealType cusp=0.0;
          string elementType;
          OhmmsAttributeSet rAttrib;
          rAttrib.add(elementType,"elementType");
          rAttrib.add(cusp,"cusp");
          rAttrib.put(kids);

	  BsplineFunctor<double> *functor = new BsplineFunctor<double>(cusp);
	  int ig = sSet.findSpecies (elementType);
	  if (ig < numSpecies) 
          {//ignore
            functor->put (kids);
            functor->addOptimizables(targetPsi.VarList);
            J1->addFunc (ig,functor);
            dJ1->addFunc(ig,functor);
            success=true;
#if !defined(HAVE_MPI)
            if(PrintTables) 
            {
              string fname="J1."+elementType+".dat";
              ofstream fout(fname.c_str());
              fout.setf(ios::scientific, ios::floatfield);
              fout << "# One-body Jastrow generated by AnyContraints::createTwoBody" << endl;
              functor->print(fout);
            }
#endif
          }
	}
	kids = kids->next;
      }

      if(success)
      {
        //assign derivatives to J1
        //dJ1->initialize();
        //J1->setDiffOrbital(dJ1);
        //J1->dPsi=dJ1;

        targetPsi.addOrbital(J1);
        J1->setOptimizable(true);
      }
      else
      {
        app_warning() << "  BsplineJastrowBuilder failed to add an One-Body Jastrow." << endl;
        delete J1;
        delete dJ1;
      }
    } 
    // Create a two-body Jastrow
    else 
    {
      typedef TwoBodyJastrowOrbital<BsplineFunctor<RealType> > J2Type;
      //typedef DiffTwoBodyJastrowOrbital<BsplineFunctor<RealType> > dJ2Type;

      J2Type *J2 = new J2Type(targetPtcl);
      //dJ2Type *dJ2 = new dJ2Type(targetPtcl);

      SpeciesSet& species(targetPtcl.getSpeciesSet());
      RealType q=species(0,species.addAttribute("charge"));

      //std::map<std::string,RadFuncType*> functorMap;
      while (kids != NULL) 
      {
	std::string kidsname((const char*)kids->name);
	if (kidsname == "correlation") 
        {
          OhmmsAttributeSet rAttrib;
          RealType cusp=-1e10;
          string pairType("0");
          string spA("0");
          string spB("0");
          rAttrib.add(spA,"speciesA");
          rAttrib.add(spB,"speciesB");
          rAttrib.add(cusp,"cusp");
          rAttrib.put(kids);
          if(pairType[0]=='0')
          {
            pairType=spA+spB;
          }
          else
          {//overwrite the species
            spA=pairType[0]; spB=pairType[1];
          }

          int ia = species.findSpecies(spA);
          int ib = species.findSpecies(spB);
          if(ia==species.size() || ib == species.size())
          {
            APP_ABORT("BsplineJastrowBuilder::put failed. Species are incorrect");
          }

          if(cusp<-1e6)
          { 
            if(ia==ib) cusp=0.25*q;
            else cusp=0.5*q;
          }

          app_log() << "  BspilneJastrowBuilder adds a functor with cusp = " << cusp << endl;
	  RadFuncType *functor = new RadFuncType(cusp);
	  functor->put (kids);
	  functor->addOptimizables(targetPsi.VarList);

          J2->addFunc(pairType,ia,ib,functor);
          //dJ2->addFunc(pairType,ia,ib,functor);

#if !defined(HAVE_MPI)
          if(PrintTables) 
          {
            string fname="J2."+pairType+".dat";
            ofstream fout(fname.c_str());
            fout.setf(ios::scientific, ios::floatfield);
            fout << "# Two-body Jastrow generated by AnyContraints::createTwoBody" << endl;
            functor->print(fout);
          }
#endif
	}
	kids = kids->next;
      }

      //dJ2->initialize();
      //J2->setDiffOrbital(dJ2);

      targetPsi.addOrbital(J2);
      J2->setOptimizable(true);
    }

    return true;
  }

}
